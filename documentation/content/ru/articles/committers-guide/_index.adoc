---
authors:
  - 
    author: 'The FreeBSD Documentation Project'
copyright: '1999-2022 The FreeBSD Documentation Project'
description: 'Вводная информация для коммиттеров FreeBSD'
tags: "[\"FreeBSD Committer's Guide\", \"Guide\", \"Community\"]"
title: 'Руководство коммиттера'
trademarks: ["freebsd", "coverity", "git", "github", "gitlab", "ibm", "intel", "general"]
weight: 25
---

= Руководство коммиттера
:doctype: article
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:images-path: articles/committers-guide/

ifdef::env-beastie[]
ifdef::backend-html5[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
:imagesdir: ../../../images/{images-path}
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[.abstract-title]
Аннотация

В этом документе представлена информация для сообщества коммиттеров FreeBSD. Все новые коммиттеры должны прочитать этот документ перед началом работы, а существующим коммиттерам настоятельно рекомендуется периодически его пересматривать.

Почти все разработчики FreeBSD имеют права на коммит в один или несколько репозиториев. Однако некоторые разработчики не имеют таких прав, и часть информации здесь применима и к ним. (Например, некоторые люди имеют права только для работы с базой данных отчетов о проблемах.) Дополнительную информацию можно найти в crossref:committers-guide[non-committers, Вопросы, специфичные для разработчиков без прав на коммит].

Этот документ также может быть интересен участникам сообщества FreeBSD, которые хотят узнать больше о том, как работает проект.

'''

toc::[]

[[admin]]
== Административные детали

[.informaltable]
[cols="1,1", frame="none"]
|===

|_Способ логина_
|man:ssh[1], только протокол версии 2

|_Главный хост для входа в оболочку_
|`freefall.FreeBSD.org`

|_Референсные машины_
|`ref*.FreeBSD.org`, `universe*.freeBSD.org` (см. также ссылку link:https://www.FreeBSD.org/internal/machines/[Хосты проекта FreeBSD])

|_Узел SMTP_
|`smtp.FreeBSD.org:587` (см. также crossref:committers-guide[smtp-setup, Настройка доступа SMTP]).

|`_src/_` Git-репозиторий
|`ssh://git@gitrepo.FreeBSD.org/src.git`

|`_doc/_` Git-репозиторий
|`ssh://git@gitrepo.FreeBSD.org/doc.git`

|`_ports/_` Git-репозиторий
|`ssh://git@gitrepo.FreeBSD.org/ports.git`

|_Внутренние списки рассылки_
|developers (технически называемый all-developers), doc-developers, doc-committers, ports-developers, ports-committers, src-developers, src-committers. (Каждый репозиторий проекта имеет свои собственные списки рассылки -developers и -committers. Архивы этих списков можно найти в файлах [.filename]#/local/mail/repository-name-developers-archive# и [.filename]#/local/mail/repository-name-committers-archive# на `freefall.FreeBSD.org`.)

|_Ежемесячные отчеты основной команды (Core Team)_
|[.filename]#/home/core/public/reports# на кластере `FreeBSD.org`.

|_Ежемесячные отчеты команды управления портами_
|[.filename]#/home/portmgr/public/monthly-reports# в кластере `FreeBSD.org`.

|_Важные ветки Git в `src/`:_
|`stable/n` (`n`-STABLE), `main` (-CURRENT)
|===

Для подключения к хостам проекта требуется man:ssh[1]. Дополнительную информацию
можно найти в crossref:committers-guide[ssh.guide, Руководстве по быстрому началу работы с SSH].

Полезные ссылки:

* link:https://www.FreeBSD.org/internal/[Внутренние страницы проекта FreeBSD]
* link:https://www.FreeBSD.org/internal/machines/[Узлы проекта FreeBSD]
* link:https://www.FreeBSD.org/administration/[Административные группы проекта FreeBSD]

[[pgpkeys]]
== Ключи OpenPGP для FreeBSD

Криптографические ключи, соответствующие стандарту OpenPGP (__Pretty Good Privacy__), используются проектом FreeBSD для аутентификации коммиттеров. Сообщения, содержащие важную информацию, такие как публичные SSH-ключи, могут быть подписаны с помощью OpenPGP-ключа, чтобы доказать, что они действительно отправлены коммиттером. Дополнительную информацию можно найти в https://nostarch.com/releases/pgp_release.pdf[PGP & GPG: Email for the Practical Paranoid от Michael Lucas] и https://en.wikipedia.org/wiki/Pretty_Good_Privacy[].

[[pgpkeys-creating]]
=== Создание ключа

Существующие ключи можно использовать, но сначала их следует проверить с помощью [.filename]#documentation/tools/checkkey.sh#. В этом случае убедитесь, что у ключа есть FreeBSD user ID.

Для тех, у кого ещё нет ключа OpenPGP или требуется новый ключ, соответствующий требованиям безопасности FreeBSD, здесь показано, как его сгенерировать.

[[pgpkeys-create-steps]]
[.procedure]
====
. Установите [.filename]#security/gnupg#. Добавьте следующие строки в [.filename]#~/.gnupg/gpg.conf#, чтобы задать минимально приемлемые настройки для подписи и предпочтений новых ключей (подробнее см. в link:https://www.gnupg.org/documentation/manuals/gnupg/GPG-Options.html[документации по опциям GnuPG]):
+
[.programlisting]
....
# Sorted list of preferred algorithms for signing (strongest to weakest).
personal-digest-preferences SHA512 SHA384 SHA256 SHA224
# Default preferences for new keys
default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 CAMELLIA256 AES192 CAMELLIA192 AES CAMELLIA128 CAST5 BZIP2 ZLIB ZIP Uncompressed
....
. Сгенерировать ключ:
+
[source, shell]
....
% gpg --full-gen-key
gpg (GnuPG) 2.1.8; Copyright (C) 2015 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Warning: using insecure memory!
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection? 1
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 2048 <.>
Requested keysize is 2048 bits
Please specify how long the key should be valid.
	 0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0) 3y <.>
Key expires at Wed Nov  4 17:20:20 2015 MST
Is this correct? (y/N) y
GnuPG needs to construct a user ID to identify your key.

Real name: Chucky Daemon <.>
Email address: notreal@example.com
Comment:
You selected this USER-ID:
"Chucky Daemon <notreal@example.com>"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
You need a Passphrase to protect your secret key.
....

<.> 2048-битные ключи с трехлетним сроком действия обеспечивают достаточную защиту на данный момент (2022-10).

<.> Срок действия ключа в три года достаточно мал, чтобы устаревшие ключи, ослабленные растущей мощностью компьютеров, перестали использоваться, но достаточно велик, чтобы уменьшить проблемы управления ключами.

<.> Используйте здесь своё настоящее имя, предпочтительно совпадающее с указанным в удостоверении личности, выданном государством, чтобы другим было проще подтвердить вашу личность. Текст, который может помочь другим идентифицировать вас, можно ввести в раздел `Комментарий`.
+
После ввода адреса электронной почты запрашивается парольная фраза. Методы создания безопасной парольной фразы вызывают споры. Вместо того чтобы предлагать один способ, вот несколько ссылок на сайты, описывающие различные методы: https://world.std.com/~reinhold/diceware.html[], https://www.iusmentis.com/security/passphrasefaq/[], https://xkcd.com/936/[], https://en.wikipedia.org/wiki/Passphrase[].
====

Защитите закрытый ключ и парольную фразу. Если закрытый ключ или парольная фраза могли быть скомпрометированы или раскрыты, немедленно уведомите mailto:accounts@FreeBSD.org[accounts@FreeBSD.org] и отзовите ключ.

Фиксация нового ключа показана в crossref:committers-guide[commit-steps, Шаги для новых коммиттеров].

[[kerberos-ldap]]
== Kerberos и LDAP веб-пароль для кластера FreeBSD

Кластер FreeBSD требует пароль Kerberos для доступа к определенным сервисам. Пароль Kerberos также служит веб-паролем LDAP, поскольку LDAP проксирует запросы к Kerberos в кластере. Некоторые из сервисов, требующих его, включают:

* https://bugs.freebsd.org/bugzilla[Bugzilla]

Для создания новой учетной записи Kerberos в кластере FreeBSD или сброса пароля Kerberos для существующей учетной записи с использованием генератора случайных паролей:

[source, shell]
....
% ssh kpasswd.freebsd.org
....

[NOTE]
====
Это должно быть выполнено с компьютера за пределами кластера FreeBSD.org.
====

Пароль Kerberos также можно установить вручную, войдя в `freefall.FreeBSD.org` и выполнив:

[source, shell]
....
% kpasswd
....

[NOTE]
====
Если ранее не использовались аутентифицированные через Kerberos службы кластера FreeBSD.org, будет отображено сообщение `Client unknown`. Эта ошибка означает, что сначала необходимо использовать метод `ssh kpasswd.freebsd.org`, показанный выше, для инициализации учётной записи Kerberos.
====

[[committer.types]]
== Типы битов коммита (прав на коммит)

Репозиторий FreeBSD содержит ряд компонентов, которые в совокупности поддерживают исходный код базовой операционной системы, документацию, инфраструктуру портов сторонних приложений и различные поддерживаемые утилиты. При выделении прав на коммит (commit bits) в FreeBSD указываются области дерева, где эти права могут быть использованы. Как правило, области, связанные с правами, отражают, кто авторизовал их выделение. Дополнительные области полномочий могут быть добавлены позже: в этом случае коммиттер должен следовать стандартной процедуре выделения прав на коммит для соответствующей области дерева, получив одобрение от соответствующей инстанции и, возможно, наставника для этой области на некоторый период времени.

[.informaltable]
[cols="1,1,1", frame="none"]
|===

|__Тип коммиттера__
|__Ответственный__
|__Компоненты дерева исходного кода__

|src
|srcmgr@
|src/

|doc
|doceng@
|документация doc/, ports/, src/

|ports
|portmgr@
|ports/
|===

Биты коммитов, выделенные до разработки концепции областей ответственности, могут быть подходящими для использования во многих частях дерева. Однако здравый смысл подсказывает, что коммиттер, ранее не работавший в определённой области дерева, должен перед коммитом получить рецензирование (review), согласование от соответствующего ответственного лица и/или работать с наставником. Поскольку правила поддержки кода различаются в зависимости от области дерева, это важно как для самого коммиттера, работающего в менее знакомой области, так и для других участников, работающих с деревом.

Коммиттерам рекомендуется запрашивать рецензирование своей работы в рамках обычного процесса разработки, независимо от области дерева, в которой происходит работа.

=== Политика активности коммиттеров в других деревьях

* Все коммиттеры могут изменять файлы [.filename]#src/share/misc/committers-*.dot#, [.filename]#src/usr.bin/calendar/calendars/calendar.freebsd# и [.filename]#ports/astro/xearth/files#.
* Документационные коммиттеры могут вносить изменения в документацию в файлы [.filename]#src#, такие как руководства, README, базы данных fortune, календарные файлы и исправления комментариев, без одобрения коммиттера src, при условии соблюдения обычных правил и внимания к коммитам.
* Любой коммиттер может вносить изменения в любое другое дерево с пометкой "Approved by" от некурируемого коммиттера с соответствующими правами. Курируемые коммиттеры (имеющие наставника) могут предоставлять пометку "Reviewed by", но не "Approved by".
* Коммиттеры могут получить дополнительный бит по обычному процессу: найти наставника, который предложит их srcmgr, doceng или portmgr, в зависимости от ситуации. После одобрения их добавят в 'access', и начнётся стандартный период наставничества, который будет включать продолжение отметки "Approved by" в течение некоторого времени.

[[doc-blanket-approval]]
==== Неявное (по умолчанию) одобрение для документации

Некоторые типы исправлений имеют "одобрение по умолчанию" от {doceng}, что позволяет любому коммиттеру исправлять эти категории проблем в любой части дерева документации. Эти исправления не требуют одобрения или проверки от коммиттера документации, если у автора нет прав на коммит в документацию.

Общее одобрение применяется к следующим типам исправлений:

* Опечатки
* Тривиальные исправления
+
Пунктуация, URL-адреса, даты, пути и имена файлов с устаревшей или некорректной информацией, а также другие распространённые ошибки, которые могут ввести читателей в заблуждение.

За годы в дереве документации были неявно одобрены некоторые случаи. Этот список показывает наиболее распространённые из них:

* Изменения в [.filename]#documentation/content/ru/books/porters-handbook/versions/_index.adoc#
+
extref:{porters-handbook}versions[Значения __FreeBSD_version (Руководство по созданию портов)], в основном используется коммиттерами src.
* Изменения в [.filename]#doc/shared/contrib-additional.adoc#
+
Сопровождение раздела extref:{contributors}[Дополнительные участники FreeBSD, contrib-additional].
* Все link:#commit-steps[Шаги для новых коммиттеров], связанные с документацией
* Рекомендации по безопасности; Уведомления об ошибках; Релизы;
+
{security-officer} и {re} используют эти разделы.
* Изменения в [.filename]#website/content/ru/donations/donors.adoc#
+
{donations} использует этот документ.

Перед любым коммитом необходимо выполнить тестовую сборку; подробности см. в разделах «Обзор» и «Процесс сборки документации FreeBSD» extref:{fdp-primer}[Руководства для новых участников проекта документации FreeBSD].

[[git-primer]]
== Руководство по Git

[[git-basics]]
=== Основы Git

При поиске по ключевым словам "Git Primer" можно найти множество хороших материалов. Страницы Дэниела Милера link:https://danielmiessler.com/study/git/[Введение в Git] и Вилли Виллуса link:https://gist.github.com/williewillus/068e9a8543de3a7ef80adb2938657b6b[Git - Краткое введение] являются хорошими обзорами. Книга по Git также полная, но гораздо длиннее: https://git-scm.com/book/en/v2. Также обратите внимание на сайт https://dangitgit.com/, посвящённый распространённым ловушкам и подводным камням Git, на случай, если вам нужно исправить ошибки. Наконец, введение, link:https://eagain.net/articles/git-for-computer-scientists/[ориентированное на компьютерных учёных], оказалось полезным для некоторых в объяснении мировоззрения Git.

Этот документ предполагает, что вы уже читали про это, и постарается не повторять основы (хотя кратко их рассмотрит).

[[git-mini-primer]]
=== Мини-руководство по Git

Это руководство имеет менее амбициозные цели, чем старое руководство по Subversion, но должно охватить основы.

==== Область применения

Если вы хотите загрузить FreeBSD, собрать его из исходных кодов и в целом поддерживать актуальность таким способом, это руководство для вас. Оно охватывает получение исходных кодов, их обновление, бинарный поиск (bisect) и кратко затрагивает способы работы с локальными изменениями. В нём изложены основы, а также даны полезные ссылки на более глубокие материалы для случаев, когда читателю будет недостаточно базовой информации. Другие разделы этого руководства посвящены более сложным темам, связанным с участием в проекте.

Цель этого раздела — выделить те аспекты Git, которые необходимы для отслеживания исходных кодов. Предполагается базовое понимание Git. В интернете есть множество вводных руководств по Git, но https://git-scm.com/book/en/v2[Книга по Git] предлагает одно из лучших изложений.

[[git-mini-primer-getting-started]]
==== Начало работы для разработчиков

Этот раздел описывает доступ на чтение и запись для коммиттеров, чтобы отправлять коммиты от разработчиков или контрибьюторов.

[[git-mini-daily-use]]
===== Повседневное использование

[NOTE]
====
В приведенных ниже примерах замените `${repo}` на имя нужного репозитория FreeBSD: `doc`, `ports` или `src`.
====

* Клонировать репозиторий:
+
[source, shell]
....
% git clone -o freebsd --config remote.freebsd.fetch='+refs/notes/*:refs/notes/*' https://git.freebsd.org/${repo}.git
....
+
В результате у вас в качестве удалённых (remote) должны быть официальные зеркала:
+
[source, shell]
....
% git remote -v
freebsd  https://git.freebsd.org/${repo}.git (fetch)
freebsd  https://git.freebsd.org/${repo}.git (push)
....

* Настройка данных коммиттера FreeBSD:
+
Хук для коммита в repo.freebsd.org проверяет, что поле "Commit" соответствует информации о коммиттере в FreeBSD.org. Самый простой способ получить предлагаемую конфигурацию — выполнить скрипт `/usr/local/bin/gen-gitconfig.sh` на freefall:
+
[source, shell]
....
% gen-gitconfig.sh
[...]
% git config user.name (your name in gecos)
% git config user.email (your login)@FreeBSD.org
....

* Установите URL для отправки (push URL):
+
[source, shell]
....
% git remote set-url --push freebsd git@gitrepo.freebsd.org:${repo}.git
....
+
В таком случае у вас должны быть раздельные URL для извлечения (fetch) и отправки (push) как наиболее эффективная настройка:
+
[source, shell]
....
% git remote -v
freebsd  https://git.freebsd.org/${repo}.git (fetch)
freebsd  git@gitrepo.freebsd.org:${repo}.git (push)
....
+
Еще раз обратите внимание, что `gitrepo.freebsd.org` является псевдонимом для `repo.freebsd.org`.

* Установка хука для шаблона сообщения коммита:
+
Для репозитория документации:
+
[source, shell]
....
% cd .git/hooks
% ln -s ../../.hooks/prepare-commit-msg
....
+
Для репозитория портов:
+
[source, shell]
....
% git config --add core.hooksPath .hooks
....
+
Для репозитория src:
+
[source, shell]
....
% cd .git/hooks
% ln -s ../../tools/tools/git/hooks/prepare-commit-msg
....

[[admin-branch]]
===== Ветка "admin"

Файлы `access` и `mentors` хранятся в отдельной (orphan) ветке `internal/admin` в каждом репозитории.

Следующий пример показывает, как переключиться (check out) на ветку `internal/admin` в локальной ветке с именем `admin`:

[source, shell]
....
% git config --add remote.freebsd.fetch '+refs/internal/*:refs/internal/*'
% git fetch
% git checkout -b admin internal/admin
....
В качестве альтернативы вы можете добавить рабочее дерево для ветки `admin`:

[source, shell]
....
git worktree add -b admin ../${repo}-admin internal/admin
....

Для просмотра ветки `internal/admin` в веб-интерфейсе: `https://cgit.freebsd.org/${repo}/log/?h=internal/admin`

Для отправки (push) укажите полную спецификацию ссылки:

[source, shell]
....
git push freebsd HEAD:refs/internal/admin
....

==== Как поддерживать актуальную копию дерева исходных кодов FreeBSD src
[[keeping_current]]
Первый шаг: клонирование дерева. Это загружает всё дерево целиком. Существует два способа загрузки. Большинству пользователей потребуется глубокое клонирование репозитория. Однако бывают случаи, когда может потребоваться поверхностное клонирование.

===== Названия веток
FreeBSD-CURRENT использует ветку `main`.

`main` — это ветка по умолчанию.

Для FreeBSD-STABLE названия веток включают `stable/12` и `stable/13`.

Для FreeBSD-RELEASE, названия веток разработки выпусков включают `releng/12.4` и `releng/13.2`.

https://www.freebsd.org/releng/[] отображает:

* ветки `main` и `stable/⋯` открыты
* ветки `releng/⋯`, каждая из которых замораживается при создании тега релиза.

Примеры:

* тег https://cgit.freebsd.org/src/tag/?h=release/13.1.0[release/13.1.0] на ветке https://cgit.freebsd.org/src/log/?h=releng/13.1[releng/13.1]
* тег https://cgit.freebsd.org/src/tag/?h=release/13.2.0[release/13.2.0] на ветке https://cgit.freebsd.org/src/log/?h=releng/13.2[releng/13.2].

===== Репозитории
Пожалуйста, обратитесь к разделу crossref:committers-guide[admin,Административные детали] для получения актуальной информации о том, где взять исходные коды FreeBSD. Значение $URL ниже можно получить с этой страницы.

Примечание: Проект не использует подмодули, так как они плохо подходят для наших рабочих процессов и модели разработки. То, как мы отслеживаем изменения в сторонних приложениях, обсуждается в другом месте и, как правило, мало интересует обычного пользователя.

===== Полный клон
Полный клон загружает всё дерево целиком, включая всю историю и ветки. Это самый простой способ. Он также позволяет использовать функцию Git `worktree`, чтобы все активные ветки были извлечены в отдельные каталоги, но с единственной копией репозитория.
[source, shell]
....
% git clone -o freebsd $URL -b branch [<directory>]
....
-- создаст полную копию. `branch` должна быть одной из веток, перечисленных в предыдущем разделе. Если параметр `branch` не указан: будет использоваться ветка по умолчанию (`main`). Если параметр `<directory>` не указан: имя нового каталога будет соответствовать имени репозитория ([.filename]#doc#, [.filename]#ports# или [.filename]#src#).

Вам понадобится полный клон, если вас интересует история, вы планируете вносить локальные изменения или работать более чем с одной веткой. Это также самый простой способ поддерживать актуальность. Если вас интересует история, но вы работаете только с одной веткой и у вас мало места, вы также можете использовать `--single-branch`, чтобы загрузить только одну ветку (хотя некоторые коммиты слияния не будут ссылаться на ветку, из которой произошло слияние, что может быть важно для некоторых пользователей, интересующихся детальными версиями истории).

===== Частичный клон

Частичный клон копирует только самый актуальный код, но не включает или включает лишь малую часть истории. Это может быть полезно, когда вам нужно собрать определённую ревизию FreeBSD или когда вы только начинаете и планируете более полно отслеживать дерево. Также вы можете использовать его, чтобы ограничить историю только определённым количеством ревизий. Однако обратите внимание на существенное ограничение этого подхода, описанное ниже.

[source, shell]
....
% git clone -o freebsd -b branch --depth 1 $URL [dir]
....

Это клонирует репозиторий, но будет содержать только самую последнюю версию в репозитории. Остальная история не загружается. Если позже вы передумаете, вы можете выполнить `git fetch --unshallow`, чтобы получить старую историю.

[WARNING]
====
При частичном клонировании вы потеряете счетчик коммитов в выводе команды uname. Это может затруднить определение необходимости обновления системы при выпуске бюллетеня безопасности.
====

===== Сборка

После загрузки сборка выполняется так, как описано в руководстве, например:
[source, shell]
....
% cd src
% make buildworld
% make buildkernel
% make installkernel
% make installworld
....
так что здесь это не будет рассматриваться подробно.

Если вы хотите собрать собственное ядро, в extref:{handbook}kernelconfig[разделе конфигурации ядра, kernelconfig] руководства FreeBSD рекомендуется создать файл MYKERNEL в sys/${ARCH}/conf с вашими изменениями на основе GENERIC. Чтобы Git игнорировал MYKERNEL, его можно добавить в .git/info/exclude.

===== Обновление

Для обновления обоих типов деревьев используются одинаковые команды. Это загружает (pull) все изменения, сделанные после последнего обновления.
[source, shell]
....
% git pull --ff-only
....
обновит дерево. В Git 'перемотка' (fast forward) — это слияние, которое только перемещает указатель ветки и не требует пересоздания коммитов. Если всегда выполнять слияние/загрузку (merge/pull) с перемоткой, это гарантирует точную копию дерева FreeBSD. Это важно, если вы хотите поддерживать локальные патчи.

См. ниже, как управлять локальными изменениями. Самый простой способ — использовать `--autostash` в команде `git pull`, но доступны и более сложные варианты.

==== Выбор конкретной версии

В Git команда `git checkout` используется для переключения как между ветками, так и между конкретными версиями. Версии в Git представляют собой длинные хеши, а не последовательные номера.

Когда вы извлекаете конкретную версию, просто укажите нужный хэш в командной строке (команда `git log` может помочь вам определиться, какой хэш выбрать):
[source, shell]
....
% git checkout 08b8197a74
....
и вам это скопировано (checkout). Вы увидите сообщение, похожее на следующее:
[source, shell]
....
Note: checking out '08b8197a742a96964d2924391bf9fdfeb788865d'.

You are in a 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 08b8197a742a hook gpiokeys.4 to the build
....
где последняя строка формируется из хэша, который вы использовали для извлечения рабочей копии, и первой строки сообщения коммита из этой ревизии. Хэш может быть сокращен до минимальной уникальной длины. Сам Git не всегда последователен в том, сколько цифр он отображает.

==== Бинарный поиск (bisect)
Иногда что-то идёт не так. Последняя версия работала, но только что обновлённая — нет. Разработчик может попросить вас провести бинарный поиск проблемы, чтобы определить, какой коммит вызвал регрессию.

Git упрощает поиск изменений с помощью мощной команды `git bisect`. Вот краткое описание, как её использовать. Для получения дополнительной информации вы можете посмотреть https://www.metaltoad.com/blog/beginners-guide-git-bisect-process-elimination или https://git-scm.com/docs/git-bisect. Страница man git-bisect хорошо описывает, что может пойти не так, что делать, когда версии не собираются, в каких ситуациях вам лучше использовать другие условия поиска, а не 'хорошо (good)' и 'плохо (bad)', и так далее, но это здесь не будет рассматриваться.

`git bisect start --first-parent` запустит процесс бинарного поиска. Далее необходимо указать диапазон для проверки. `git bisect good XXXXXX` укажет рабочую версию, а `git bisect bad XXXXX` — нерабочую версию. Нерабочая версия почти всегда будет HEAD (специальный тег для текущего состояния). Рабочая версия будет последней, которую вы проверяли. Аргумент `--first-parent` необходим, чтобы последующие команды `git bisect` не пытались переключиться на ветку вендора, в которой отсутствует полное дерево исходников FreeBSD.

[TIP]
====
Если вы хотите узнать последнюю версию, которую вы извлекли, используйте `git reflog`:
[source, shell]
....
5ef0bd68b515 (HEAD -> main, freebsd/main, freebsd/HEAD) HEAD@{0}: pull --ff-only: Fast-forward
a8163e165c5b (upstream/main) HEAD@{1}: checkout: moving from b6fb97efb682994f59b21fe4efb3fcfc0e5b9eeb to main
...
....
показывает, как я перемещаю рабочее дерево в ветку `main` (a816...) и затем обновляю его из вышестоящего репозитория (до 5ef0...). В этом случае, bad будет HEAD (или 5ef0bd68b515), а good — a8163e165c5b. Как видно из вывода, HEAD@{1} также часто работает, но не является безошибочным, если вы выполняли другие действия с деревом Git после обновления, но до того, как обнаружили необходимость в бинарном поиске.
====

Установите сначала «хорошую» версию, затем установите «плохую» (хотя порядок не имеет значения). При установке «плохой» версии вы получите некоторую статистику по процессу:
[source, shell]
....
% git bisect start --first-parent
% git bisect good a8163e165c5b
% git bisect bad HEAD
Bisecting: 1722 revisions left to test after this (roughly 11 steps)
[c427b3158fd8225f6afc09e7e6f62326f9e4de7e] Fixup r361997 by balancing parens.  Duh.
....

Затем вы собираете и устанавливаете эту версию. Если она работает корректно, введите `git bisect good`, в противном случае — `git bisect bad`. Если версия не компилируется, введите `git bisect skip`. После каждого шага вы будете получать сообщение, аналогичное приведённому выше. По завершении сообщите о проблемной версии разработчику (или исправьте ошибку самостоятельно и отправьте патч). Команда `git bisect reset` завершит процесс и вернёт вас туда, откуда вы начали (обычно на вершину ветки `main`). Ещё раз, руководство по git-bisect (ссылка выше) — это хороший ресурс на случай возникновения проблем или нестандартных ситуаций.

[[git-gpg-signing]]
==== Подписание коммитов, тегов и отправок с помощью GnuPG

Git умеет подписывать коммиты, теги и отправки (push). Когда вы подписываете Git-коммит или тег, вы можете доказать, что отправленный код действительно принадлежит вам и не был изменён во время передачи. Вы также можете подтвердить, что именно вы отправили код, а не кто-то другой.

Более подробная документация по подписанию коммитов и тегов доступна в главе https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work[Инструменты Git - Подписание вашей работы] книги по Git.

Обоснование подписания отправок можно найти в https://github.com/git/git/commit/a85b377d0419a9dfaca8af2320cc33b051cbed04[коммите, где представлена эта функция].

Лучший способ — просто указать Git, что вы всегда хотите подписывать коммиты, теги и отправки. Это можно сделать, установив несколько переменных конфигурации:

[source, shell]
....
% git config --add user.signingKey LONG-KEY-ID
% git config --add commit.gpgSign true
% git config --add tag.gpgSign true
% git config --add push.gpgSign if-asked
....

// push.gpgSign should probably be set to `yes` once we enable it, or be set with --global, so that it is enabled for all repositories.

[NOTE]
======
Чтобы избежать возможных конфликтов, убедитесь, что вы указали длинный идентификатор ключа для Git. Вы можете получить длинный идентификатор с помощью команды: `gpg --list-secret-keys --keyid-format LONG`.
======

[TIP]
======
Для использования конкретных подключей, без разрешения GnuPG подключей в первичный ключ, добавьте `!` к ключу. Например, для шифрования с подключом `DEADBEEF` используйте `DEADBEEF!`.
======

===== Проверка подписей

Подпись коммита можно проверить, выполнив команду `git verify-commit <хэш коммита>` или `git log --show-signature`.

Подписи тегов можно проверить с помощью `git verify-tag <имя тега>` или `git tag -v <имя тега>`.

////
Commented out for now until we decide what to do.

Git pushes are a bit different, they live in a special ref in the repository.
TODO: write how to verify them

////

==== Особенности портов
Дерево портов работает аналогичным образом. Названия ветвей отличаются, и репозитории расположены в других местах.

Веб-интерфейс cgit для работы в браузере доступен по адресу https://cgit.FreeBSD.org/ports/ . Рабочий репозиторий Git находится по адресу https://git.FreeBSD.org/ports.git и ssh://anongit@git.FreeBSD.org/ports.git (или `anongit@git.FreeBSD.org:ports.git`).

Также доступно зеркало на GitHub, см. extref:{handbook}/mirrors[Внешние зеркала, mirrors] для обзора. Ветка _latest_ называется `main`. Ветки _quarterly_ именуются `yyyyQn`, где 'yyyy' — год, а 'n' — квартал.

[[port-commit-message-formats]]
===== Форматы сообщений коммитов

В репозитории портов доступен перехватчик, который помогает оформлять сообщения коммитов в https://cgit.freebsd.org/ports/tree/.hooks/prepare-commit-msg[.hooks/prepare-commit-message]. Его можно включить, выполнив команду ``git config --add core.hooksPath .hooks``.

Основная идея заключается в том, что сообщение коммита должно быть оформлено следующим образом:

....
category/port: Summary.

Description of why the changes where made (Объяснение, почему были сделаны изменения ).

PR:	    12345
....

[IMPORTANT]
====
Первая строка — это тема коммита, в ней указывается, какой порт был изменён, и краткое описание коммита. Она должна содержать 50 символов или меньше.

Пустая строка должна отделять его от остальной части сообщения о коммите.

Остальная часть сообщения о коммите должна быть перенесена на границе 72 символов.

Еще одна пустая строка должна быть добавлена, если есть какие-либо поля метаданных, чтобы их можно было легко отличить от сообщения о коммите.
====

==== Управление локальными изменениями
Этот раздел посвящен отслеживанию локальных изменений. Если у вас нет локальных изменений, вы можете пропустить этот раздел.

Один важный момент для всех: все изменения остаются локальными, пока они не будут отправлены (push). В отличие от Subversion, Git использует распределённую модель. Для пользователей в большинстве случаев разница невелика. Однако, если у вас есть локальные изменения, вы можете использовать тот же инструмент для управления ими, что и для получения изменений из FreeBSD. Все изменения, которые вы не отправили, являются локальными и могут быть легко изменены (это делает git rebase, обсуждаемый ниже).

===== Сохранение локальных изменений
Самый простой способ сохранить локальные изменения (особенно незначительные) — использовать `git stash`. В простейшем случае вы используете `git stash`, чтобы записать изменения (что помещает их в стек stash). Большинство людей используют это для сохранения изменений перед обновлением дерева, как описано выше. Затем они используют `git stash apply`, чтобы повторно применить изменения к дереву. Stash представляет собой стек изменений, который можно просмотреть с помощью `git stash list`. Подробности приведены в man-странице git-stash (https://git-scm.com/docs/git-stash).

Этот метод подходит, когда у вас есть небольшие изменения в дереве. Если у вас что-то более сложное, вероятно, лучше будет создать локальную ветку и выполнять перебазирование. Сохранение изменений также интегрировано в команду `git pull`: просто добавьте `--autostash` в командную строку.

===== Сохранение локальной ветки
[[keeping_a_local_branch]]
С помощью Git гораздо проще поддерживать локальную ветку, чем в Subversion. В Subversion необходимо выполнять коммит слияния и разрешать конфликты. Это выполнимо, но может привести к запутанной истории изменений, которую будет сложно передать в вышестоящий репозиторий, если это потребуется, или сложно воспроизвести при необходимости. Git также позволяет выполнять коммит слияния, но с теми же проблемами. Это один из способов управления веткой, но наименее гибкий.

В дополнение к слиянию, Git поддерживает концепцию «перебазирования» (rebase), которая позволяет избежать этих проблем. Команда `git rebase` воспроизводит все коммиты ветки в конце родительской ветки. Мы рассмотрим наиболее распространённые сценарии, возникающие при её использовании.

====== Создать ветку

Предположим, вы хотите внести изменение в команду `ls` FreeBSD, чтобы она никогда не использовала цветовое выделение. Существует множество причин для этого, но в данном примере мы будем использовать это в качестве базового сценария. Команда `ls` в FreeBSD периодически изменяется, и вам нужно будет адаптироваться к этим изменениям. К счастью, с помощью `git rebase` это обычно происходит автоматически.
[source, shell]
....
% cd src
% git checkout main
% git checkout -b no-color-ls
% cd bin/ls
% vi ls.c     # hack the changes in
% git diff    # check the changes
diff --git a/bin/ls/ls.c b/bin/ls/ls.c
index 7378268867ef..cfc3f4342531 100644
--- a/bin/ls/ls.c
+++ b/bin/ls/ls.c
@@ -66,6 +66,7 @@ __FBSDID("$FreeBSD$");
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#undef COLORLS
 #ifdef COLORLS
 #include <termcap.h>
 #include <signal.h>
% # these look good, make the commit...
% git commit ls.c
....

Коммит откроет редактор, чтобы описать выполненные изменения. После ввода описания у вас будет собственная **локальная** ветка в Git-репозитории. Соберите и установите изменения, как обычно, следуя указаниям в руководстве. Git отличается от других систем контроля версий тем, что нужно явно указывать, какие файлы коммитить. Я предпочитаю делать это в командной строке коммита, но также можно использовать `git add`, как описано в более подробных руководствах.

====== Время обновить

Когда приходит время внедрить новую версию, процесс почти такой же, как и без веток. Вы выполняете обновление, как описано выше, но перед обновлением нужно выполнить одну дополнительную команду и одну после. Ниже предполагается, что вы начинаете с неизменённого дерева. Важно начинать операции перебазирования с чистого дерева (Git требует этого).

[source, shell]
....
% git checkout main
% git pull --ff-only
% git rebase -i main no-color-ls
....

Это откроет редактор, в котором будут перечислены все коммиты. В данном примере не изменяйте его содержимое. Обычно это делается при обновлении базовой версии (хотя также можно использовать команду Git rebase для управления коммитами в ветке).

После завершения вышеуказанных действий необходимо перенести коммиты для `ls.c` со старой версии FreeBSD на новую.

Иногда возникают конфликты слияния. Это нормально. Не паникуйте. Вместо этого решайте их так же, как и любые другие конфликты слияния. Чтобы упростить, я опишу лишь распространённую проблему, которая может возникнуть. Ссылка на полное руководство приведена в конце этого раздела.

Допустим, изменения включают переход на terminfo в вышестоящем коде, а также изменение названия опции. При обновлении вы можете увидеть следующее:
[source, shell]
....
Auto-merging bin/ls/ls.c
CONFLICT (content): Merge conflict in bin/ls/ls.c
error: could not apply 646e0f9cda11... no color ls
Resolve all conflicts manually, mark them as resolved with
"git add/rm <conflicted_files>", then run "git rebase --continue".
You can instead skip this commit: run "git rebase --skip".
To abort and get back to the state before "git rebase", run "git rebase --abort".
Could not apply 646e0f9cda11... no color ls
....
что выглядит пугающе.

Если открыть редактор, вы увидите типичное разрешение конфликта с трёхсторонним слиянием, с которым вы могли сталкиваться в других системах управления исходным кодом (остальная часть ls.c опущена):
[source, shell]
....
 <<<<<<< HEAD
 #ifdef COLORLS_NEW
 #include <terminfo.h>
 =======
 #undef COLORLS
 #ifdef COLORLS
 #include <termcap.h>
 >>>>>>> 646e0f9cda11... no color ls
....

Новый код идет первым, а ваш код - вторым.

Правильное решение здесь — просто добавить `#undef COLORLS_NEW` перед `#ifdef`, а затем удалить старые изменения:
[source, shell]
....
#undef COLORLS_NEW
#ifdef COLORLS_NEW
#include <terminfo.h>
....
и сохранить файл.

Ребазирование было прервано, поэтому вам необходимо завершить его:
[source, shell]
....
% git add ls.c
% git rebase --continue
....

что указывает Git, что файл `ls.c` исправлен и можно продолжить операцию перебазирования. Поскольку возник конфликт, система откроет редактор для обновления сообщения коммита (если это необходимо). Если сообщение коммита по-прежнему корректно, просто закройте редактор.

Если вы застряли в процессе перебазирования, не паникуйте. Команда `git rebase --abort` вернёт вас к исходному состоянию. Однако важно начинать с неизменённого дерева. Примечание: упомянутая выше команда `git reflog` будет полезна в этой ситуации, так как она содержит список всех (промежуточных) коммитов, которые вы можете просмотреть, изучить или выбрать через `cherry-pick`.

Для более подробного ознакомления с этой темой, см. довольно обширное руководство по адресу: https://www.freecodecamp.org/news/the-ultimate-guide-to-git-merge-and-git-rebase/. Этот ресурс будет полезен для решения проблем, которые возникают нечасто, но слишком специфичны для данного руководства.

===== Переключение на другую ветку FreeBSD
Если вы хотите перейти с ветки stable/12 на ветку current и у вас есть полный клон репозитория, будет достаточно выполнить следующую команду:
[source, shell]
....
% git checkout main
% # build and install here...
....
Однако, если у вас есть локальная ветка, есть несколько важных замечаний. Во-первых, перебазирование переписывает историю, поэтому вам, скорее всего, захочется сохранить её каким-либо образом. Во-вторых, переключение между ветками часто вызывает больше конфликтов. Если предположить, что приведённый выше пример относился к ветке stable/12, то для перехода на ветку `main` я бы рекомендовал следующее:
[source, shell]
....
% git checkout no-color-ls
% git checkout -b no-color-ls-stable-12   # create another name for this branch
% git rebase -i stable/12 no-color-ls --onto main
....

Что делает вышеописанное: извлекается ветка no-color-ls. Затем для неё создаётся новое имя (no-color-ls-stable-12) на случай, если потребуется вернуться к ней. После этого выполняется перебазирование на ветку `main`. Это позволит найти все коммиты в текущей ветке no-color-ls (вплоть до точки её ответвления от stable/12) и затем воспроизвести их на ветке `main`, создав там новую ветку no-color-ls (поэтому я и попросил вас создать резервное имя).

[[mfc-with-git]]
=== Процедуры MFC (Merge From Current)
==== Краткое содержание

Рабочий процесс MFC можно обобщить как `git cherry-pick -x` плюс `git commit --amend` для корректировки сообщения коммита. Для нескольких коммитов используйте `git rebase -i`, чтобы объединить их вместе и отредактировать сообщение коммита.

==== Одиночный коммит MFC

[source, shell]
....
% git checkout stable/X
% git cherry-pick -x $HASH --edit
....

Для коммитов MFC, например, импорта от вендора, вам потребуется указать одного родителя для целей выборочного применения (cherry-pick). Обычно это будет «первый родитель» ветки, из которой вы применяете изменения, то есть:

[source, shell]
....
% git checkout stable/X
% git cherry-pick -x $HASH -m 1 --edit
....

Если что-то пойдет не так, вам потребуется либо прервать выборочное применение с помощью `git cherry-pick --abort`, либо исправить проблему и выполнить `git cherry-pick --continue`.

После завершения выборочного применения выполните отправку с помощью `git push`. Если возникнет ошибка из-за проигрыша в гонке коммитов, используйте `git pull --rebase` и повторите попытку отправки.

==== MFC в ветку RELENG

MFC в ветки, требующие одобрения, требуют немного больше внимания. Процесс одинаков как для обычного слияния, так и для прямого коммита в исключительной ситуации.

* Сначала выполните слияние или прямой коммит в соответствующую ветку `stable/X`, прежде чем сливать в ветку `releng/X.Y`.
* Используйте хэш из ветки `stable/X` для MFC в ветку `releng/X.Y`.
* Оставляйте обе строки "cherry picked from" в сообщении коммита.
* Обязательно добавьте строку `Approved by:` при работе в редакторе.

[source, shell]
....
% git checkout releng/13.0
% git cherry-pick -x $HASH --edit
....

Если вы забыли добавить строку `Approved by:`, вы можете выполнить `git commit --amend`, чтобы отредактировать сообщение коммита перед отправкой изменения.

==== Множественный коммит MFC

[source, shell]
....
% git checkout -b tmp-branch stable/X
% for h in $HASH_LIST; do git cherry-pick -x $h; done
% git rebase -i stable/X
# отметить каждый коммит после первого как 'squash'
# При необходимости обновить сообщение коммита, чтобы отразить все его элементы.
# Обязательно сохранить строки "cherry picked from".
% git push freebsd HEAD:stable/X
....

Если отправка не удалась из-за проигрыша в гонке коммитов, выполните перебазирование и повторите попытку:

[source, shell]
....
% git checkout stable/X
% git pull
% git checkout tmp-branch
% git rebase stable/X
% git push freebsd HEAD:stable/X
....

После завершения MFC вы можете удалить временную ветку:

[source, shell]
....
% git checkout stable/X
% git branch -d tmp-branch
....

==== MFC — импорт от вендора

Импорты от вендоров — это единственное в дереве, что создает коммит слияния в ветке `main`. Коммиты слияния выборочным переносом (cherry-pick) в stable/XX представляют дополнительную сложность, поскольку у коммита слияния два родителя. Как правило, вам понадобится разница с первым родителем, так как это разница с `main` (хотя могут быть и исключения).

[source, shell]
....
% git cherry-pick -x -m 1 $HASH
....
обычно это то, что вам нужно. Это укажет выборочному переносу применить правильный diff.

Бывают, надеюсь, редкие случаи, когда возможно, что ветка `main` была объединена в обратном порядке скриптом преобразования. Если это произойдет (а мы пока таких случаев не обнаружили), вам следует изменить указанное выше на `-m 2`, чтобы выбрать правильного родителя. Просто выполните:
[source, shell]
....
% git cherry-pick --abort
% git cherry-pick -x -m 2 $HASH
....
для этого. Опция `--abort` выполнит очистку после неудачной первой попытки.

==== Переделка MFC

Если вы делаете MFC, и всё идет ужасно неправильно, и вы хотите начать сначала, то самый простой способ — использовать `git reset --hard`, как показано ниже:
[source, shell]
....
% git reset --hard freebsd/stable/12
....
хотя если у вас есть некоторые ревизии, которые вы хотите сохранить, а другие — нет, использование `git rebase -i` предпочтительнее.

==== Некоторые соображения о MFC

При внесении исходных коммитов в стабильные и релизные ветки мы преследуем следующие цели:

* Четко обозначить прямые коммиты, отличая их от коммитов, вносящих изменения из другой ветки.
* Избегать внесения известных нарушений в стабильные ветки и ветки выпуска релизов (releng).
* Позволить разработчикам определять, какие изменения были или не были перенесены из одной ветки в другую.

С помощью Subversion мы использовали следующие практики для достижения этих целей:

* Использование тегов `MFC` и `MFS` для пометки коммитов, которые сделали слияние изменения из другой ветки.
* Объединение (squash) исправляющих (fixup) коммитов с основным коммитом при слиянии изменения.
* Запись информации о слияниях для корректной работы `svn mergeinfo --show-revs`.

С помощью Git нам потребуется использовать другие стратегии для достижения тех же целей. Этот документ призван определить лучшие практики для коммитов слияния исходного кода с использованием Git, которые достигают этих целей. В целом мы стремимся использовать встроенные возможности Git для достижения этих целей, а не применять практики, основанные на модели Subversion.

Общее замечание: в связи с техническими различиями в Git, мы не будем использовать "коммиты слияния" Git (созданные через `git merge`) в стабильных ветках или ветках releng. Вместо этого, когда в документе упоминаются "коммиты слияния", имеется в виду коммит, изначально сделанный в `main`, который реплицируется или "переносится" в стабильную ветку, или коммит из стабильной ветки, который реплицируется в ветку releng с помощью вариации команды `git cherry-pick`.

==== Поиск подходящих хэшей для MFC

Git предоставляет встроенную поддержку этого через команды `git cherry` и `git log --cherry`. Эти команды сравнивают исходные различия коммитов (но не другие метаданные, такие как сообщения журнала), чтобы определить, идентичны ли два коммита. Это хорошо работает, когда каждый коммит из `main` переносится как отдельный коммит в стабильную ветку, но перестаёт работать, если несколько коммитов из `main` объединяются в один коммит в стабильной ветке. Проект активно использует `git cherry-pick -x` с сохранением всех строк для обхода этих трудностей и разрабатывает автоматизированные инструменты для использования этого подхода.

==== Стандарты сообщений коммитов
===== Пометка MFC

Проект принял следующую практику для пометки MFC:

* Используйте флаг `-x` с командой `git cherry-pick`. Это добавляет строку в сообщение коммита, которая включает хэш оригинального коммита при слиянии. Поскольку это добавляется непосредственно Git, коммиттерам не нужно вручную редактировать журнал коммитов при слиянии.

При слиянии нескольких коммитов сохраняйте все строки "cherry picked from".

===== Обрезать метаданные?

Одной из областей, которая не была чётко задокументирована в Subversion (и даже в CVS), является форматирование метаданных в сообщениях журнала для коммитов MFC. Должны ли они включать метаданные из исходного коммита без изменений или должны быть изменены для отражения информации о самом коммите MFC?

Исторически практика различалась, хотя некоторые различия зависят от области. Например, MFC, относящиеся к PR, обычно включают поле PR в MFC, чтобы коммиты MFC включались в аудит-трекер системы отслеживания ошибок. В других областях ситуация менее ясна. Например, Phabricator показывает разницу последнего коммита, помеченного для обзора, поэтому включение URL-адресов Phabricator заменяет основной коммит на завершенные коммиты. Список рецензентов также неясен. Если рецензент одобрил изменение для `main`, означает ли это, что он одобрил коммит MFC? Верно ли это только для идентичного кода или лишь с незначительной доработкой? Очевидно, это неверно для более масштабных доработок. Даже для идентичного кода: что, если коммит не конфликтует, но вносит изменение ABI? Рецензент мог одобрить коммит для `main` из-за нарушения ABI, но может не одобрить слияние того же коммита в неизменном виде. Придется полагаться на собственное наилучшее суждение до тех пор, пока не будут согласованы четкие руководящие принципы.

Для MFC, регулируемых re@, добавляются новые поля метаданных, такие как тег Approved by для одобренных коммитов. Эти новые метаданные должны быть добавлены через `git commit --amend` или аналогичные средства после того, как исходный коммит будет проверен и одобрен. Мы также можем захотеть зарезервировать некоторые поля метаданных в коммитах MFC, такие как URL-адреса Phabricator, для использования re@ в будущем.

Сохранение существующих метаданных обеспечивает очень простой рабочий процесс. Разработчики используют `git cherry-pick -x` без необходимости редактировать сообщение журнала.

Если же мы решим изменять метаданные в MFC, разработчикам придется явно редактировать сообщения журнала с помощью `git cherry-pick --edit` или `git commit --amend`. Однако по сравнению с svn, по крайней мере, существующее сообщение о фиксации может быть предварительно заполнено, а поля метаданных можно добавлять или удалять без необходимости повторного ввода всего сообщения о фиксации.

Суть в том, что разработчикам, вероятно, потребуется тщательно готовить свои сообщения о коммитах для MFC, которые не являются тривиальными.

[[vendor-import-git]]
=== Импорт вендоров с Git

В этом разделе подробно описывается процедура импорта вендора с использованием Git.

==== Соглашение о наименовании веток

Все ветки и теги вендоров начинаются с `vendor/`. Эти ветки и теги видны по умолчанию.

[NOTE]
====
Эта глава следует соглашению, что `freebsd` — это имя источника для официального репозитория Git FreeBSD. Если вы используете другое соглашение, замените `freebsd` на используемое вами имя в приведённых ниже примерах.
====

Мы рассмотрим пример обновления mtree NetBSD, который находится в нашем дереве. Ветка вендора для него — `vendor/NetBSD/mtree`.

==== Обновление старого импорта от вендора

Деревья вендоров обычно содержат лишь подмножество стороннего программного обеспечения, подходящего для FreeBSD. Эти деревья, как правило, очень малы по сравнению с деревом FreeBSD. Таким образом, рабочие деревья Git довольно компактны и быстры, что делает их предпочтительным методом использования. Убедитесь, что выбранный вами каталог ( `../mtree` ) в настоящее время не существует.

[source, shell]
....
% git worktree add ../mtree vendor/NetBSD/mtree
....

==== Обновление исходных кодов в ветке вендора

Подготовьте полное, чистое дерево исходных кодов вендора. Импортируйте всё, но делайте слияние только тому, что необходимо.

Этот пример предполагает, что исходный код NetBSD получен из их зеркала на GitHub в каталоге `~/git/NetBSD`. Учтите, что «вышестоящий репозиторий» мог добавить или удалить файлы, поэтому мы хотим убедиться, что удаления также распространяются. Пакет package:net/rsync[] обычно установлен, поэтому я буду использовать его.

[source, shell]
....
% cd ../mtree
% rsync -va --del --exclude=".git" ~/git/NetBSD/usr.sbin/mtree/ .
% git add -A
% git status
...
% git diff --staged
...
% git commit -m "Vendor import of NetBSD's mtree at 2020-12-11"
[vendor/NetBSD/mtree 8e7aa25fcf1] Vendor import of NetBSD's mtree at 2020-12-11
 7 files changed, 114 insertions(+), 82 deletions(-)
% git tag -a vendor/NetBSD/mtree/20201211
....

Крайне важно убедиться, что импортируемый исходный код получен из надежного источника. Многие проекты с открытым исходным кодом используют криптографические подписи для подписывания изменений кода, тегов git и/или tar-архивов с исходным кодом. Всегда проверяйте эти подписи и используйте механизмы изоляции, такие как клетки, chroot, в сочетании с выделенной непривилегированной учетной записью пользователя, отличной от той, которую вы используете регулярно (подробнее см. в разделе «Обновление дерева исходного кода FreeBSD» ниже), пока вы не будете уверены, что импортируемый исходный код выглядит безопасным. Отслеживание разработки в вышестоящем репозитории и периодический просмотр изменений кода в нем могут значительно помочь в повышении качества кода и принести пользу всем участникам. Также рекомендуется изучать результаты git diff перед импортом их в область вендора.

Всегда выполняйте команды `git diff` и `git status` и внимательно изучайте результаты. В случае сомнений полезно выполнить `git annotate` на ветке вендора или в вышестоящем git-репозитории, чтобы увидеть, кто и почему внес изменение.

В примере выше мы использовали `-m` для иллюстрации, но вам следует составить корректное сообщение в редакторе (используя шаблон сообщения о фиксации).

Также важно создать аннотированный тег с помощью `git tag -a`, иначе отправка будет отклонена. Только аннотированные теги разрешены для отправки. Аннотированный тег даёт вам возможность ввести сообщение коммита. Укажите версию, которую вы импортируете, вместе с любыми важными новыми функциями или исправлениями в этой версии.

==== Обновление копии FreeBSD

На этом этапе вы можете отправить импорт в `vendor` в наш репозиторий.

[source, shell]
....
% git push --follow-tags freebsd vendor/NetBSD/mtree
....

`--follow-tags` указывает `git push` также отправлять теги, связанные с локально зафиксированной ревизией.

==== Обновление дерева исходных кодов FreeBSD

Теперь вам нужно обновить mtree в FreeBSD. Исходные коды находятся в `contrib/mtree`, так как это программное обеспечение из внешних источников.

Время от времени нам может потребоваться вносить изменения в предоставленный (contrib) код, чтобы лучше соответствовать потребностям FreeBSD. По возможности, пожалуйста, старайтесь передавать локальные изменения обратно в вышестоящие проекты — это помогает им лучше поддерживать FreeBSD, а также экономит ваше время при разрешении конфликтов в будущем при импорте обновлений.

[source, shell]
....
% cd ../src
% git subtree merge -P contrib/mtree vendor/NetBSD/mtree
....

Это создаст коммит слияния поддерева `contrib/mtree` с локальной веткой `vendor/NetBSD/mtree`. Изучите разницу (diff) между результатом слияния и содержимым вышестоящей ветки. Если слияние сократило наши локальные изменения до более тривиальных различий, таких как изменения пустых строк или отступов, попробуйте исправить локальные изменения, чтобы уменьшить разницу с вышестоящей версией, или попытайтесь внести оставшиеся изменения обратно в вышестоящий проект. Если возникли конфликты, вам потребуется устранить их перед коммитом. Включите подробности об объединяемых изменениях в сообщение коммита слияния.

Некоторое открытое программное обеспечение включает скрипт `configure`, который генерирует файлы, используемые для определения процесса сборки кода; обычно эти сгенерированные файлы, такие как `config.h`, должны обновляться как часть процесса импорта. При выполнении этого всегда помните, что эти скрипты являются исполняемым кодом, работающим под учётными данными текущего пользователя. Этот процесс всегда должен запускаться в изолированной среде, в идеале внутри клетки, не имеющей сетевого доступа, и с непривилегированной учётной записью; или, как минимум, с выделенной учётной записью, отличной от той, которую вы обычно используете для повседневных задач или для отправки изменений в репозиторий исходного кода FreeBSD. Это минимизирует риск столкновения с ошибками, которые могут привести к потере данных или, в худших случаях, к выполнению злонамеренно внедрённого кода. Использование изолированной клетки также предотвращает обнаружение скриптами configure локально установленных пакетов программного обеспечения, что может привести к неожиданным результатам.

При тестировании ваших изменений запускайте их сначала в chroot или в клетке, или даже внутри виртуальной машины, особенно для модификаций ядра или библиотек. Этот подход помогает предотвратить неблагоприятное взаимодействие с вашей рабочей средой. Это может быть особенно полезно для изменений в библиотеках, которые используют многие компоненты базовой системы среди прочего.

==== Перебазирование ваших изменений относительно последней версии исходного дерева FreeBSD

Поскольку текущая политика рекомендует избегать слияний (merge), то, если вышестоящая ветка FreeBSD `main` продвинулась вперёд до того, как у вас появится возможность отправить изменения, вам придётся переделывать слияние.

Обычный `git rebase` или `git pull --rebase` не умеет перемещать коммит слияния **как коммит слияния**, поэтому вместо этого вам придётся воссоздать коммит.

Следующие шаги следует выполнить, чтобы легко воссоздать коммит слияния, как если бы `git rebase --merge-commits` сработал правильно:

* Перейдите в корень репозитория
* Создайте побочную ветвь `XXX` с **содержимым** дерева со слиянием.
* Обновите эту побочную ветку `XXX` для слияния и актуализации с основной веткой FreeBSD `main`.
** В худшем случае вам всё равно придётся разрешать конфликты слияния, если они были, но это должно быть крайне редко.
** Разрешите конфликты и, если необходимо, объедините (collapse) несколько коммитов в один (без конфликтов объединение не требуется)
* извлеките (checkout) ветку `main`
* создайте ветку `YYY` (позволяет проще откатиться, если что-то пойдет не так)
* Повторите слияние поддерева
* Вместо разрешения конфликтов от слияния поддерева, извлеките (checkout) содержимое XXX поверх него.
** Завершающая `.` важна, как и нахождение на верхнем уровне репозитория.
** Вместо переключения веток на XXX, он накладывает содержимое XXX поверх репозитория
* Сделайте коммит полученному результату с предыдущим сообщением коммита (пример предполагает, что в ветке XXX была только одна операция слияния).
* Убедитесь, что ветки одинаковые.
* Сделайте любые необходимые проверки, включая привлечение других людей для проверки, если вы считаете, что это необходимо.
* Запишите (push) этот коммит. Если вы «снова проиграли в гонке», просто повторите эти шаги (см. рецепт ниже)
* Удалите ветки после того, как коммит попадёт в вышестоящий репозиторий. Они одноразовые.

Команды, которые можно использовать, следуя приведённому выше примеру с mtree, будут выглядеть следующим образом (символ `#` начинает комментарий, помогающий связать команды с описаниями выше):

[source, shell]
....
% cd ../src			# CD to top of tree
% git checkout -b XXX		# create new throw-away XXX branch for merge
% git fetch freebsd		# Get changes from upstream from upstream
% git merge freebsd/main	# Merge the changes and resolve conflicts
% git checkout -b YYY freebsd/main # Create new throw-away YYY branch for redo
% git subtree merge -P contrib/mtree vendor/NetBSD/mtree # Redo subtree merge
% git checkout XXX .		# XXX branch has the conflict resolution
% git commit -c XXX~1		# -c reuses the commit message from commit before rebase
% git diff XXX YYY		# Should be empty
% git show YYY			# Should only have changes you want, and be a merge commit from vendor branch
....

Примечание: если что-то пойдет не так с коммитом, вы можете сбросить ветку `YYY`, повторно выполнив команду checkout, которая создала её, с флагом -B, чтобы начать заново:
[source, shell]
....
% git checkout -B YYY freebsd/main # Создать новую временную ветку YYY, если начать заново будет проще
....

==== Отправка (push) изменений

Когда вы считаете, что у вас есть набор изменений, и они хорошие, вы можете отправить их в форк на GitHub или GitLab для просмотра и рецензирования другими. Одна из хороших особенностей Git заключается в том, что он позволяет публиковать черновые версии вашей работы для проверки другими. Хотя Phabricator хорош для проверки содержания, публикация обновленной ветки вендора и коммитов слияния позволяет другим проверить детали, которые в конечном итоге появятся в репозитории.

После проверки, когда вы уверены, что это хорошее изменение, вы можете отправить (push) его в репозиторий FreeBSD:

[source, shell]
....
% git push freebsd YYY:main	# put the commit on upstream's 'main' branch
% git branch -D XXX		# Throw away the throw-a-way branches.
% git branch -D YYY
....

Примечание: Я использовал `XXX` и `YYY`, чтобы было очевидно, что это ужасные имена, и они не должны покидать вашу машину. Если вы используете такие имена для другой работы, вам нужно будет выбрать другие имена или рискнуть потерять другую работу. В этих именах нет ничего волшебного. В вышестоящий репозиторий вам не разрешат их отправить, но, тем не менее, обратите внимание на точные команды выше. Некоторые команды используют синтаксис, который лишь незначительно отличается от типичного использования, и это различие в поведении критически важно для работы данного рецепта.

==== Как переделать вещи, если это необходимо

Если вы попытались выполнить отправку из предыдущего раздела и она завершилась неудачей, то вам следует выполнить следующие действия для «повторного выполнения» операций. Эта последовательность сохраняет коммит с сообщением о коммите всегда на позиции XXX~1 для упрощения коммита.

[source, shell]
....
% git checkout -B XXX YYY	# recreate that throw-away-branch XXX and switch to it
% git merge freebsd/main	# Merge the changes and resolve conflicts
% git checkout -B YYY freebsd/main # Recreate new throw-away YYY branch for redo
% git subtree merge -P contrib/mtree vendor/NetBSD/mtree # Redo subtree merge
% git checkout XXX .		# XXX branch has the conflict resolution
% git commit -c XXX~1		# -c reuses the commit message from commit before rebase
....

Затем проверьте, как описано выше, и отправьте (push), как описано выше, когда будет готово.

=== Создание новой ветки вендора

Существует несколько способов создания новой ветки вендора. Рекомендуемый способ — создать новый репозиторий и затем сделать его слияние с FreeBSD. Например, производится импорт `glorbnitz` версии 3.1415 в дерево FreeBSD. Для простоты мы не будем обрезать этот релиз. Это простая пользовательская команда, которая переводит устройство nitz в различные магические состояния glorb, и она достаточно мала, так что обрезка не сэкономит много.

==== Создайте репозиторий

[source, shell]
....
% cd /some/where
% mkdir glorbnitz
% cd glorbnitz
% git init
% git checkout -b vendor/glorbnitz
....

На этом этапе у вас есть новый репозиторий, в котором все новые коммиты будут направляться в ветку `vendor/glorbnitz`.

Опытные пользователи Git также могут сделать это непосредственно в своей копии FreeBSD, используя `git checkout --orphan vendor/glorbnitz`, если им так удобнее.

==== Скопируйте себе исходники

Поскольку это новая импортированная копия, вы можете просто скопировать файлы исходного кода командой cp, либо использовать tar или даже rsync, как показано выше. И мы добавим всё, предполагая отсутствие файлов с точкой в начале имени.

[source, shell]
....
% cp -r ~/glorbnitz/* . 
% git add *
....

На этом этапе у вас должна быть чистая копия glorbnitz, готовая к коммиту.

[source, shell]
....
% git commit -m "Import GlorbNitz frobnosticator revision 3.1415"
....

Как и выше, я использовал `-m` для простоты, но вам, вероятно, следует создать сообщение коммита, которое объясняет, что такое Glorb и почему для его получения используется Nitz. Не все это знают, поэтому для вашего реального коммита вам следует руководствоваться разделом crossref:committers-guide[commit-log-message,сообщение коммита], а не имитировать краткий стиль, использованный здесь.

==== Теперь импортируйте его в наш репозиторий

Теперь необходимо импортировать ветку в наш репозиторий.

[source, shell]
....
% cd /path/to/freebsd/repo/src
% git remote add glorbnitz /some/where/glorbnitz
% git fetch glorbnitz vendor/glorbnitz
....

Обратите внимание, что ветка vendor/glorbnitz находится в репозитории. На этом этапе `/some/where/glorbnitz` можно удалить, если хотите. Это было лишь промежуточным шагом для достижения цели.
// perhaps the real treasure was the friends it made along the way...

==== Сделайте тег и отправьте (push)

Дальнейшие шаги во многом аналогичны процессу обновления ветки вендора, за исключением самого шага обновления ветки вендора.

[source, shell]
....
% git worktree add ../glorbnitz vendor/glorbnitz
% cd ../glorbnitz
% git tag --annotate vendor/glorbnitz/3.1415
# Убедитесь, что коммит хороший, с помощью "git show"
% git push --follow-tags freebsd vendor/glorbnitz
....

Под «хорошим» мы подразумеваем:

. Все необходимые файлы присутствуют
. Ни один из неправильных файлов не присутствует
. Ветка вендора указывает на что-то разумное
. Тег выглядит хорошо и имеет аннотацию
. Сообщение коммита для тега содержит краткую сводку о нововведениях с момента предыдущего тега

==== Время наконец сделать слияние этого в базовое дерево

[source, shell]
....
% cd ../src
% git subtree add -P contrib/glorbnitz vendor/glorbnitz
# Убедитесь, что коммит хороший, с помощью "git show"
% git commit --amend   # one last sanity check on commit message
% git push freebsd
....

Здесь «хороший» означает:

. Все правильные файлы и ни одного неправильного были объединены слиянием в contrib/glorbnitz.
. В дереве нет других изменений.
. Сообщения коммитов должны выглядеть crossref:committers-guide[commit-log-message,хорошо]. Они должны содержать сводку изменений с момента последнего слияния с основной веткой FreeBSD `main` и любые предостережения.
. UPDATING должен быть обновлен, если есть что-то важное, например, заметные пользователям изменения, важные аспекты обновления и т.д.

[NOTE]
====
Это еще не подключило `glorbnitz` к сборке. Способ сделать это зависит от конкретного импортируемого программного обеспечения и выходит за рамки данного руководства.
====

===== Сохраняя актуальность

Итак, время идёт. Пришло время обновить дерево до последних изменений из вышестоящего репозитория. При переходе на ветку `main` (при checkout) убедитесь, что у вас нет незакоммиченных изменений. Намного проще закоммитить их в отдельную ветку (или использовать `git stash`) перед выполнением следующих действий.

Если вы привыкли к `git pull`, мы настоятельно рекомендуем использовать опцию `--ff-only` и дополнительно установить её в качестве опции по умолчанию. В качестве альтернативы, `git pull --rebase` полезен, если у вас есть изменения, проиндексированные (stage) в ветке `main`.

[source, shell]
....
% git config --global pull.ff only
....

Возможно, вам потребуется опустить --global, если вы хотите, чтобы эта настройка применялась только к этому репозиторию.

[source, shell]
....
% cd freebsd-src
% git checkout main
% git pull (--ff-only|--rebase)
....

Существует распространённая ловушка: команда `git pull` попытается выполнить слияние, что иногда создаёт коммит слияния, которого ранее не существовало. Восстановление после этого может быть затруднительно.

Рекомендуется также использовать расширенную форму.

[source, shell]
....
% cd freebsd-src
% git checkout main
% git fetch freebsd
% git merge --ff-only freebsd/main
....

Эти команды сбрасывают ваше дерево к ветке `main`, а затем обновляют его из исходного источника, откуда дерево было первоначально получено (pull). Важно переключиться на `main` перед выполнением этого, чтобы обеспечить продвижение вперёд. Теперь пришло время продвинуть изменения вперёд:

[source, shell]
....
% git rebase -i main working
....

Это вызовет интерактивный экран для изменения настроек по умолчанию. Пока просто выйдите из редактора. Всё должно примениться автоматически. Если нет, то вам потребуется разрешить различия. https://docs.github.com/en/free-pro-team@latest/github/using-git/resolving-merge-conflicts-after-a-git-rebase[Документация GitHub] может помочь вам в этом процессе.

[[git-push-upstream]]
===== Время отправить (push) изменения вверх (upstream)

Сначала убедитесь, что URL для отправки (push) правильно настроен для вышестоящего репозитория.

[source, shell]
....
% git remote set-url --push freebsd ssh://git@gitrepo.freebsd.org/src.git
....

Затем убедитесь, что имя пользователя и адрес электронной почты настроены правильно. Требуется, чтобы они точно соответствовали записи passwd в кластере FreeBSD.

Используйте

[source, shell]
....
freefall% gen-gitconfig.sh
....

на freefall.freebsd.org (при условии, что /usr/local/bin находится в PATH), чтобы получить готовый шаблон конфигурации, который можно использовать напрямую.

Следующая команда делает слияние ветки `working` в основную ветку `main` вышестоящего репозитория. Важно, чтобы вы подготовили свои изменения именно так, как хотите видеть их в исходном репозитории FreeBSD, перед выполнением этой операции. Данный синтаксис отправляет (push) ветку `working` в `main`, перемещая ветку `main` вперед. Вы сможете сделать это только в том случае, если результатом будет линейное изменение для `main` (т.е. без слияний).

[source, shell]
....
% git push freebsd working:main
....

Если ваша отправка (push) отклонена из-за проигрыша в гонке коммитов, перебазируйте вашу ветку перед повторной попыткой:

[source, shell]
....
% git checkout working
% git fetch freebsd
% git rebase freebsd/main
% git push freebsd working:main
....

[[git-push-upstream-alt]]
===== Время отправить (push) изменения вверх (альтернативный вариант)

Некоторым удобнее делать слияние своих изменений в локальную ветку `main` перед отправкой в удалённый репозиторий. Кроме того, `git arc stage` перемещает изменения из ветки в локальную `main`, когда требуется выполнить только часть изменений из ветки. Инструкции схожи с предыдущим разделом:
[source, shell]
....
% git checkout main
% git merge --ff-only `working`
% git push freebsd
....

Если вы проиграли гонку, попробуйте снова с
[source, shell]
....
% git pull --rebase 
% git push freebsd
....
Эти команды получат (fetch) последние изменения из `freebsd/main`, а затем перебазируют (rebase) локальные изменения `main` поверх них, что и требуется, когда вы проиграли гонку коммитов. Примечание: коммиты слияния ветки вендоров не будет работать с этой техникой.

===== Поиск ревизии Subversion

Вам нужно убедиться, что вы получили (fetch) примечания (подробности смотрите в разделе crossref:committers-guide[git-mini-daily-use, Ежедневное использование]). Как только вы это сделаете, примечания будут отображаться в команде git log следующим образом:

[source, shell]
....
% git log
....

Если у вас есть конкретная версия, вы можете использовать эту конструкцию:

[source, shell]
....
% git log --grep revision=XXXX
....

чтобы найти конкретную ревизию. Шестнадцатеричное число после 'commit' — это хэш, который можно использовать для ссылки на этот коммит.

[[git-faq]]
=== Часто задаваемые вопросы о Git

В этом разделе представлены конкретные ответы на вопросы, которые часто возникают у пользователей и разработчиков.

[NOTE]
====
Мы используем общепринятое соглашение, согласно которому источником для репозитория FreeBSD является 'freebsd', а не стандартный 'origin', чтобы позволить людям использовать его для собственной разработки и минимизировать случайные отправки (push) в неправильный репозиторий.
====

==== Пользователи

===== Как отслеживать -current и -stable, имея только одну копию репозитория?

**Q:** Although disk space is not a huge issue, it's more efficient to use only one copy of the repository. With SVN mirroring, I could checkout multiple trees from the same repository. How do I do this with Git?

**A:** You can use Git worktrees. There's a number of ways to do this, but the simplest way is to use a clone to track -current, and a worktree to track stable releases. While using a 'bare repository' has been put forward as a way to cope, it's more complicated and will not be documented here.

Сначала необходимо клонировать репозиторий FreeBSD, здесь показано клонирование в `freebsd-current` для избежания путаницы. `$URL` — это любой зеркальный сервер, который работает для вас наилучшим образом:

[source, shell]
....
% git clone -o freebsd --config remote.freebsd.fetch='+refs/notes/*:refs/notes/*' $URL freebsd-current
....

после того, как он будет клонирован, вы можете просто создать рабочее дерево из него:

[source, shell]
....
% cd freebsd-current
% git worktree add ../freebsd-stable-12 stable/12
....

это извлечёт `stable/12` в каталог с именем `freebsd-stable-12`, который находится на одном уровне с каталогом `freebsd-current`. После создания он обновляется очень похожим образом, как вы могли бы ожидать:

[source, shell]
....
% cd freebsd-current
% git checkout main
% git pull --ff-only
# changes from upstream now local and current tree updated
% cd ../freebsd-stable-12
% git merge --ff-only freebsd/stable/12
# now your stable/12 is up to date too
....

Я рекомендую использовать `--ff-only`, так как это безопаснее и позволяет избежать случайного попадания в 'кошмар слияния', когда в вашем дереве появляются дополнительные изменения, вынуждающие выполнять сложное слияние вместо простого.

Вот https://adventurist.me/posts/00296[хорошая статья], в которой рассматривается этот вопрос более подробно.

==== Разработчики

===== Ой! Я закоммитил в `main` вместо другой ветки.

**Q:** From time to time, I goof up and mistakenly commit to the `main` branch. What do I do?

**A:** First, don't panic.

Во-вторых, не отправляйте (push) изменения. На самом деле, можно исправить почти всё, если изменения не были отправлены. Все ответы в этом разделе предполагают, что отправки не произошло.

Следующий ответ предполагает, что вы закоммитили в `main` и хотите создать ветку с названием `issue`:

[source, shell]
....
% git checkout -b issue              # Create the 'issue' branch
% git checkout -B main freebsd/main  # Reset main to upstream
% git checkout issue                 # Back to where you were
....

===== Ой! Я закоммитил что-то не в ту ветку!

**Q:** I was working on feature on the `wilma` branch, but accidentally committed a change relevant to the `fred` branch in 'wilma'. What do I do?

**A:** The answer is similar to the previous one, but with cherry picking. This assumes there's only one commit on wilma, but will generalize to more complicated situations. It also assumes that it's the last commit on wilma (hence using wilma in the `git cherry-pick` command), but that too can be generalized.

[source, shell]
....
# We're on branch wilma
% git checkout fred		# move to fred branch
% git cherry-pick wilma		# copy the misplaced commit
% git checkout wilma		# go back to wilma branch
% git reset --hard HEAD^	# move what wilma refers to back 1 commit
....

Если это не последний коммит, вы можете выборочно применить (cherry-pick) это одно изменение из wilma к fred, затем использовать `git rebase -i`, чтобы удалить изменение из wilma.

[source, shell]
....
# Мы находимся на ветке wilma
% git checkout fred			# перейти на ветку fred
% git cherry-pick HASH_OF_CHANGE	# скопировать ошибочно размещённый коммит
% git rebase -i main wilma		# удалить скопированное изменение
....

**Q:** But what if I want to commit a few changes to `main`, but keep the rest in `wilma` for some reason?

**A:** The same technique above also works if you are wanting to 'land' parts of the branch you are working on into `main` before the rest of the branch is ready (say you noticed an unrelated typo, or fixed an incidental bug). You can cherry pick those changes into `main`, then push to the parent repository. Once you've done that, cleanup couldn't be simpler: just `git rebase -i`. Git will notice you've done this and skip the common changes automatically (even if you had to change the commit message or tweak the commit slightly). There's no need to switch back to wilma to adjust it: just rebase!

**Q:** I want to split off some changes from branch `wilma` into branch `fred`

**A:** The more general answer would be the same as the previous. You'd checkout/create the `fred` branch, cherry pick the changes you want from `wilma` one at a time, then rebase `wilma` to remove those changes you cherry picked. `git rebase -i main wilma` will toss you into an editor, and remove the `pick` lines that correspond to the commits you copied to `fred`. If all goes well, and there are no conflicts, you're done. If not, you'll need to resolve the conflicts as you go.

Другой способ сделать это — выгрузить `wilma`, а затем создать ветку `fred`, указывающую на ту же точку в дереве. Затем вы можете выполнить `git rebase -i` для обеих этих веток, выбирая изменения, которые вы хотите видеть в `fred` или `wilma`, оставляя строки с `pick` и удаляя остальные в редакторе. Некоторые предпочитают создать тег/ветку с названием `pre-split` перед началом, на случай если что-то пойдет не так при разделении. Вы можете отменить это следующей последовательностью:

[source, shell]
....
% git checkout pre-split	# Go back
% git branch -D fred		# delete the fred branch
% git checkout -B wilma		# reset the wilma branch
% git branch -d pre-split	# Pretend it didn't happen
....

Последний шаг необязателен. Если вы собираетесь повторить попытку разделения, его можно пропустить.

**Q:** But I did things as I read along and didn't see your advice at the end to create a branch, and now `fred` and `wilma` are all screwed up. How do I find what `wilma` was before I started. I don't know how many times I moved things around.

**A:** All is not lost. You can figure out it, so long as it hasn't been too long, or too many commits (hundreds).

Итак, я создал ветку wilma и закоммитил в неё пару изменений, затем решил разделить её на fred и wilma. Ничего странного при этом не произошло, но предположим, что произошло. Способ посмотреть, что вы сделали, — это использовать `git reflog`:

[source, shell]
....
% git reflog
6ff9c25 (HEAD -> wilma) HEAD@{0}: rebase -i (finish): returning to refs/heads/wilma
6ff9c25 (HEAD -> wilma) HEAD@{1}: rebase -i (start): checkout main
869cbd3 HEAD@{2}: rebase -i (start): checkout wilma
a6a5094 (fred) HEAD@{3}: rebase -i (finish): returning to refs/heads/fred
a6a5094 (fred) HEAD@{4}: rebase -i (pick): Encourage contributions
1ccd109 (freebsd/main, main) HEAD@{5}: rebase -i (start): checkout main
869cbd3 HEAD@{6}: rebase -i (start): checkout fred
869cbd3 HEAD@{7}: checkout: moving from wilma to fred
869cbd3 HEAD@{8}: commit: Encourage contributions
...
%
....

Здесь мы видим изменения, которые я внес. Вы можете использовать это, чтобы понять, где что-то пошло не так. Я лишь укажу на несколько моментов. Первый из них — HEAD@{X} является 'коммитоподобной' сущностью, поэтому вы можете использовать это в качестве аргумента команды. Хотя если эта команда вносит что-либо в репозиторий, номера X изменяются. Вы также можете использовать хэш (первый столбец).

Далее, 'Encourage contributions' был последним коммитом, который я сделал в `wilma` перед тем, как решил разделить всё. Вы также можете видеть, что тот же хэш присутствует, когда я создал ветку `fred` для этого. Я начал с перебазирования `fred`, и вы видите 'начало', каждый шаг и 'завершение' этого процесса. Хотя нам это здесь не нужно, вы можете точно понять, что произошло. К счастью, чтобы исправить это, вы можете выполнить шаги из предыдущего ответа, но с хэшом `869cbd3` вместо `pre-split`. Хотя это кажется немного многословным, это легко запомнить, поскольку вы делаете одно действие за раз. Вы также можете последовательно применить команды одну за другой:

[source, shell]
....
% git checkout -B wilma 869cbd3
% git branch -D fred
....

и вы готовы попробовать снова. Команда `checkout -B` с хэшем объединяет извлечение (checkout) и создание ветки для него. Использование `-B` вместо `-b` принудительно перемещает уже существующую ветку. В любом случае это работает, что и прекрасно (и ужасно) в Git. Одна из причин, по которой я склонен использовать `git checkout -B xxxx хэш` вместо извлечения (checkout) хэша, а затем создания / перемещения ветки, — это чисто чтобы избежать слегка тревожного сообщения об отделённом HEAD:

[source, shell]
....
% git checkout 869cbd3
M	faq.md
Note: checking out '869cbd3'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 869cbd3 Encourage contributions
% git checkout -B wilma
....

это производит тот же эффект, но мне приходится читать гораздо больше, а отрубленные головы (прим перев.: detached HEAD — отрубленная голова) — не тот образ, который мне нравится созерцать.

===== Ой! Я выполнил `git pull`, и это создало коммит слияния, что мне делать?

**Q:** I was on autopilot and did a `git pull` for my development tree and that created a merge commit on `main`. How do I recover?

**A:** This can happen when you invoke the pull with your development branch checked out.

Многие разработчики используют `git pull --rebase`, чтобы избежать этой ситуации.

Сразу после получения и слияния (pull) у вас в рабочую копию будет извлечен новый коммит слияния. Git поддерживает синтаксис `HEAD^#` для определения родителей коммита слияния:

[source, shell]
....
git log --oneline HEAD^1   # Look at the first parent's commits
git log --oneline HEAD^2   # Look at the second parent's commits
....

Из этих журналов вы можете легко определить, какой коммит является вашей разработкой. Затем вы просто сбрасываете свою ветку к соответствующему `HEAD^#`:

[source, shell]
....
git reset --hard HEAD^1
....

Кроме того, команда `git pull --rebase` на этом этапе перебазирует ваши изменения из ветки 'main' на последнюю версию 'freebsd/main'.

**Q:** But I also need to fix my `main` branch. How do I do that?

**A:** Git keeps track of the remote repository branches in a `freebsd/` namespace. To fix your `main` branch, just make it point to the remote's `main`:

[source, shell]
....
git branch -f main freebsd/main
....

Ветви в Git не имеют ничего магического: они всего лишь метки на графе, которые автоматически перемещаются вперед при создании коммитов. Так что вышеописанное работает, потому что вы просто перемещаете метку. Из-за этого нет никаких метаданных о ветке, которые нужно было бы сохранять.

===== Смешивание и сопоставление веток

**Q:** So I have two branches `worker` and `async` that I'd like to combine into one branch called `feature` while maintaining the commits in both.

**A:** This is a job for cherry pick.

[source, shell]
....
% git checkout worker
% git checkout -b feature	# create a new branch
% git cherry-pick main..async	# bring in the changes
....

Теперь у вас есть новая ветка под названием `feature`. Эта ветка объединяет коммиты из обеих веток. Вы можете далее работать с ней с помощью `git rebase`.

**Q:** I have a branch called `driver` and I'd like to break it up into `kernel` and `userland` so I can evolve them separately and commit each branch as it becomes ready.

**A:** This takes a little bit of prep work, but `git rebase` will do the heavy lifting here.

[source, shell]
....
% git checkout driver		# Checkout the driver
% git checkout -b kernel	# Create kernel branch
% git checkout -b userland	# Create userland branch
....

Теперь у вас есть две идентичные ветки. Значит, пришло время разделить коммиты. Мы предположим, что сначала все коммиты в ветке `driver` попадут либо в ветку `kernel`, либо в ветку `userland`, но не в обе одновременно.

[source, shell]
....
% git rebase -i main kernel
....

и просто включите изменения, которые вы хотите (строкой 'p' или 'pick'), и удалите коммиты, которые не нужны (это звучит пугающе, но в худшем случае вы всегда можете всё отбросить и начать заново с ветки `driver`, если вы только её не переместили).

[source, shell]
....
% git rebase -i main userland
....

и сделайте то же самое, что вы сделали с веткой `kernel `.

**Q:** Oh great! I followed the above and forgot a commit in the `kernel` branch. How do I recover?

**A:** You can use the `driver` branch to find the hash of the commit is missing and cherry pick it.

[source, shell]
....
% git checkout kernel
% git log driver
% git cherry-pick $HASH
....

**Q:** OK. I have the same situation as the above, but my commits are all mixed up. I need parts of one commit to go to one branch and the rest to go to the other. In fact, I have several. Your rebase method to select sounds tricky.

**A:** In this situation, you'd be better off to curate the original branch to separate out the commits, and then use the above method to split the branch.

Итак, предположим, что есть всего один коммит с чистым деревом. Вы можете использовать либо `git rebase` со строкой `edit`, либо это с коммитом на острие. В любом случае шаги одинаковы. Первое, что нам нужно сделать, — это откатиться на один коммит назад, оставив изменения незакоммиченными в дереве:

[source, shell]
....
% git reset HEAD^
....

Примечание: НЕ, повторяю, НЕ добавляйте здесь `--hard`, так как это также удалит изменения из вашего дерева.

Теперь, если вам повезёт, изменения, которые нужно разделить, полностью укладываются по границам файлов. В этом случае вы можете просто выполнить обычный `git add` для файлов в каждой группе, а затем сделать `git commit`. Примечание: при этом вы потеряете сообщение коммита при выполнении сброса, поэтому если оно вам по какой-то причине нужно, следует сохранить копию (хотя `git log $HASH` может его восстановить).

Если вам не повезло, вам придётся разделять файлы. Для этого существует ещё один инструмент, который можно применять по одному файлу за раз.

[source, shell]
....
git add -i foo/bar.c
....

будет последовательно проходить через различия, предлагая вам включить или исключить каждый фрагмент. После завершения, выполните `git commit`, и оставшиеся изменения окажутся в вашем дереве. Вы также можете запускать эту команду несколько раз, даже для нескольких файлов (хотя я считаю удобнее работать с одним файлом за раз и использовать `git rebase -i` для объединения связанных коммитов).

===== Присоединение к организации FreeBSD на GitHub.

**Q:** How do I join the FreeBSD GitHub organization?

**A:** Please see https://wiki.freebsd.org/GitHub#Joining_the_Organisation[our GitHub Wiki Info] page for details. Briefly, all FreeBSD committers may join. Those who are not committers who request joining will be considered on a case by case basis.

==== Клонирование и зеркалирование

**Q:** I'd like to mirror the entire Git repository, how do I do that?

**A:** If all you want to do is mirror, then

[source, shell]
....
% git clone --mirror $URL
....

сработает. Однако, у этого есть два недостатка, если вы хотите использовать это для чего-то кроме зеркала, которое вы будете переклонировать.

Во-первых, это 'голый репозиторий', который содержит базу данных репозитория, но не имеет извлеченного рабочего дерева. Это отлично подходит для зеркалирования, но ужасно для повседневной работы. Существует несколько способов обойти это с помощью `git worktree`:

[source, shell]
....
% git clone --mirror https://git.freebsd.org/ports.git ports.git
% cd ports.git
% git worktree add ../ports main
% git worktree add ../quarterly branches/2020Q4
% cd ../ports
....

Но если вы не используете свой зеркальный репозиторий для дальнейшего локального клонирования, то это неподходящий выбор.

Второй недостаток заключается в том, что Git обычно перезаписывает ссылки из вышестоящего репозитория (названия веток, теги и т.д.) , чтобы ваши локальные ссылки могли изменяться независимо от вышестоящего репозитория. Это означает, что вы потеряете изменения, если будете коммитить в свой репозиторий куда-либо, кроме веток приватных проектов.

**Q:** So what can I do instead?

**A:** Well, you can stuff all of the upstream repository's refs into a private namespace in your local repository. Git clones everything via a 'refspec' and the default refspec is:

[source, shell]
....
        fetch = +refs/heads/*:refs/remotes/freebsd/*
....

что говорит просто получить (fetch) ссылки веток.

Однако в репозитории FreeBSD есть и ряд других элементов. Чтобы увидеть их, вы можете добавить явные спецификации ссылок для каждого пространства имен ссылок или получить всё. Чтобы настроить ваш репозиторий для этого:

[source, shell]
....
git config --add remote.freebsd.fetch '+refs/*:refs/freebsd/*'
....

что поместит всё из вышестоящего репозитория в пространство имён `refs/freebsd/` вашего локального репозитория. Обратите внимание, что это также захватывает все несконвертированные ветки вендоров, а количество связанных с ними ссылок довольно велико.

Вам потребуется ссылаться на эти ссылки с их полными именами, поскольку они не входят в обычные пространства имён Git.

[source, shell]
....
git log refs/freebsd/vendor/zlib/1.2.10
....

будет просматривать журнал ветки вендора для zlib, начиная с версии 1.2.10.

=== Сотрудничество с другими

Одним из ключевых моментов качественной разработки программного обеспечения в таком крупном проекте, как FreeBSD, является возможность сотрудничать с другими участниками до отправки своих изменений в дерево исходного кода. Репозитории Git проекта FreeBSD пока не позволяют отправлять пользовательские ветки в репозиторий, поэтому если вы хотите поделиться своими изменениями с другими, вам необходимо использовать другой механизм, например, репозиторий, размещённый в GitLab или GitHub, для обмена изменениями в ветке, созданной пользователем.

Следующие инструкции показывают, как создать пользовательскую ветку на основе ветки FreeBSD `main` и отправить её в GitHub.

Прежде чем начать, убедитесь, что ваш локальный репозиторий Git актуален и имеет правильно настроенные источники, как показано в разделе crossref:committers-guide[keeping_current,выше].

[source, shell]
```` % git remote -v freebsd https://git.freebsd.org/src.git (fetch) freebsd ssh://git@gitrepo.freebsd.org/src.git (push) ````

Первым шагом является создание форка https://github.com/freebsd/freebsd-src[FreeBSD] на GitHub, следуя этим https://docs.github.com/en/github/getting-started-with-github/fork-a-repo[инструкциям]. Назначением форка должен быть ваш собственный, личный аккаунт на GitHub (в моём случае gvnn3).

Теперь добавьте удаленный репозиторий в вашей локальной системе, который указывает на ваш форк:
[source, shell]
....
% git remote add github git@github.com:gvnn3/freebsd-src.git
% git remote -v
github	git@github.com:gvnn3/freebsd-src.git (fetch)
github	git@github.com:gvnn3/freebsd-src.git (push)
freebsd	https://git.freebsd.org/src.git (fetch)
freebsd	ssh://git@gitrepo.freebsd.org/src.git (push)
....
В этом репозитории вы можете создать ветку crossref:committers-guide[keeping_a_local_branch,как показано выше].

[source, shell]
....
% git checkout -b gnn-pr2001-fix
....

Вносите любые изменения в своей ветке. Собирайте, тестируйте, и как только будете готовы к совместной работе с другими, настанет время отправить свои изменения в ветку, размещённую в GitHub. Прежде чем отправить изменения, вам нужно будет установить соответствующую вышестоящую ветку (upstream), о чём Git сообщит при первой попытке отправки в ваш удалённый репозиторий +github+:

[source, shell]
....
% git push github
fatal: The current branch gnn-pr2001-fix has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream github gnn-pr2001-fix
....

Если установить параметры отправки (push) так, как советует +git+, то это позволяет ему успешно выполниться:

[source, shell]
....
% git push --set-upstream github gnn-feature
Enumerating objects: 20486, done.
Counting objects: 100% (20486/20486), done.
Delta compression using up to 8 threads
Compressing objects: 100% (12202/12202), done.
Writing objects: 100% (20180/20180), 56.25 MiB | 13.15 MiB/s, done.
Total 20180 (delta 11316), reused 12972 (delta 7770), pack-reused 0
remote: Resolving deltas: 100% (11316/11316), completed with 247 local objects.
remote:
remote: Create a pull request for 'gnn-feature' on GitHub by visiting:
remote:      https://github.com/gvnn3/freebsd-src/pull/new/gnn-feature
remote:
To github.com:gvnn3/freebsd-src.git
 * [new branch]                gnn-feature -> gnn-feature
Branch 'gnn-feature' set up to track remote branch 'gnn-feature' from 'github'.
....

Последующие изменения в той же ветке будут по умолчанию отправляться корректно:

[source, shell]
....
% git push
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 8 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 314 bytes | 1024 bytes/s, done.
Total 3 (delta 1), reused 1 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:gvnn3/freebsd-src.git
   9e5243d7b659..cf6aeb8d7dda  gnn-feature -> gnn-feature
....

На этом этапе ваша работа находится в вашей ветке на +GitHub+, и вы можете поделиться ссылкой с другими участниками.

[[github-pull-land]]
=== Обработка запросов на принятие изменений (pull request) на github
В этом разделе описано, как интегрировать запрос на принятие изменений (pull request) из GitHub, отправленный на зеркала FreeBSD в Git на GitHub. Хотя на данный момент это не официальный способ отправки исправлений, иногда таким образом приходят хорошие правки, и проще всего просто перенести их в дерево коммиттера и оттуда отправить (push) в дерево FreeBSD. Аналогичные шаги можно использовать для получать и сливать (pull) ветки из других репозиториев и их использовать их. При коммите запросов на принятие изменений от других следует проявлять особую осторожность, чтобы проверить все изменения и убедиться, что они в точности соответствуют заявленным.

Прежде чем начать, убедитесь, что локальный репозиторий Git актуален и имеет правильно настроенные источники, как показано в разделе crossref:committers-guide[keeping_current,выше]. Кроме того, убедитесь, что у вас есть следующие источники:
[source, shell]
....
% git remote -v
freebsd https://git.freebsd.org/src.git (fetch)
freebsd ssh://git@gitrepo.freebsd.org/src.git (push)
github https://github.com/freebsd/freebsd-src (fetch)
github https://github.com/freebsd/freebsd-src (fetch)
....
Часто запросы на принятие изменений просты: это запросы, содержащие всего один коммит. В этом случае можно использовать упрощённый подход, хотя подход из предыдущего раздела также будет работать. Здесь создаётся ветка, изменения выборочно применяются, сообщение коммита корректируется и проверяется на адекватность перед отправкой. В этом примере используется ветка `staging`, но она может иметь любое имя. Эта техника работает для любого количества коммитов в запросе на принятие изменений, особенно когда изменения чисто применяются к дереву FreeBSD. Однако, когда коммитов несколько, особенно когда требуются незначительные корректировки, `git rebase -i` работает лучше, чем `git cherry-pick`. Вкратце, эти команды создают ветку; выборочно применяют изменения из запроса на принятие изменений; тестируют их; корректируют сообщения коммитов; и выполняют слияние перемоткой (fast-forward) обратно в `main`. Номер PR ниже обозначен как `$PR`. При корректировке сообщения добавьте `Pull Request: https://github.com/freebsd-src/pull/$PR`. Все запросы на принятие изменений, зафиксированные в репозитории FreeBSD, должны быть проверены как минимум одним человеком. Это не обязательно должен быть тот, кто их фиксирует, но в этом случае тот, кто фиксирует, должен доверять компетентности других рецензентов в проверке коммита. Коммиттеры, которые проводят рецензирование кода у запросов на принятие изменений перед их отправкой в репозиторий, должны добавить строку `Reviewed by:` к коммиту, потому что в этом случае это не подразумевается. Добавьте всех, кто просматривает и одобряет коммит на github, также в `Reviewed by:`. Как всегда, следует позаботиться о том, чтобы изменение делало то, что предполагается, и чтобы в нём не было вредоносного кода.
[NOTE]
======
Кроме того, пожалуйста, убедитесь, что имя автора запроса на принятие изменений не является анонимным. Веб-интерфейс редактирования Github генерирует имена вида:
[source, shell]
....
Author:     github-user <38923459+github-user@users.noreply.github.com>
....
Автору следует отправить вежливую просьбу предоставить более подходящее имя и/или адрес электронной почты. Следует проявлять особую осторожность, чтобы не допустить ошибок стиля или внедрения вредоносного кода.
======

[source, shell]
....
% git fetch github pull/$PR/head:staging
% git rebase -i main staging	# to move the staging branch forward, adjust commit message here
<do testing here, as needed>
% git checkout main
% git pull --ff-only		# to get the latest if time has passed
% git checkout main
% git merge --ff-only staging
<test again if needed>
% git push freebsd --push-option=confirm-author
....

[.procedure]
====
Для сложных запросов на принятие изменений с несколькими коммитами, содержащими конфликты, следуйте приведённой ниже схеме.

. извлеките запрос на принятие изменений `git checkout github/pull/XXX`
. создайте ветку для перебазирования `git checkout -b staging`
. перебазируйте ветку `staging` на последнюю версию `main` с помощью `git rebase -i main staging`
. разрешите конфликты и проведите все необходимые тестирования
. перемотайте (fast-forward) ветку `staging` в `main`, как описано выше
. сделайте финальную проверку изменений, чтобы убедиться, что всё в порядке
. отправьте в репозиторий Git FreeBSD.

Это также будет работать при внесении веток, разработанных в другом месте, в локальное дерево для коммита.
====
После завершения работы с запросом на принятие изменений (pull request), закройте его с помощью веб-интерфейса GitHub. Стоит отметить, что если ваш источник `github` использует `https://`, единственным шагом, для которого потребуется учетная запись GitHub, будет закрытие запроса на принятие изменений.

[[vcs-history]]
== История системы контроля версий

Проект перешёл на crossref:committers-guide[git-primer,git].

Репозиторий исходных кодов FreeBSD перешёл с CVS на Subversion 31 мая 2008 года. Первый настоящий коммит SVN — __r179447__. Репозиторий исходных кодов перешёл с Subversion на Git 23 декабря 2020 года. Последний настоящий коммит svn — __r368820__. Хеш первого настоящего коммита git — __5ef5f51d2bef80b0ede9b10ad5b0e9440b60518c__.

Репозиторий `doc/www` FreeBSD перешёл с CVS на Subversion 19 мая 2012 года. Первый настоящий коммит SVN — __r38821__. Репозиторий документации перешёл с Subversion на Git 8 декабря 2020 года. Последний коммит SVN — __r54737__. Первый настоящий хэш коммита git — __3be01a475855e7511ad755b2defd2e0da5d58bbe__.

Репозиторий `ports` FreeBSD перешел с CVS на Subversion 14 июля 2012 года. Первый настоящий коммит SVN — __r300894__. Репозиторий ports перешел с Subversion на Git 6 апреля 2021 года. Последний коммит SVN — __r569609__. Первый настоящий хэш коммита git — __ed8d3eda309dd863fb66e04bccaa513eee255cbf__.

[[conventions]]
== Настройка, соглашения и традиции

В качестве нового разработчика необходимо выполнить ряд действий. Первый набор шагов относится исключительно к коммиттерам. Эти шаги должны быть выполнены наставником для тех, кто не является коммиттером.

[[conventions-committers]]
=== Для новых коммиттеров

Те, кому предоставлены права на коммит в репозитории FreeBSD, должны выполнить следующие шаги.

* Получите одобрение наставника перед внесением каждого из этих изменений!
* Все коммиты в [.filename]#src# сначала попадают в FreeBSD-CURRENT, прежде чем быть слитыми в FreeBSD-STABLE. Ветка FreeBSD-STABLE должна сохранять совместимость ABI и API с предыдущими версиями этой ветки. Не делайте слияние изменений, нарушающих эту совместимость.

[[commit-steps]]
[.procedure]
====
*Steps for New Committers*

. Добавить автора
+
[.filename]#doc/shared/authors.adoc# - Добавить информацию об авторе. Последующие шаги зависят от этой информации, и пропуск этого шага приведёт к сбою сборки [.filename]#doc/#. Это относительно простая задача, но она остаётся хорошим первым испытанием навыков работы с системой контроля версий.
. Обновить список разработчиков и участников
+
[.filename]#doc/shared/contrib-committers.adoc# - Добавьте запись, которая затем появится в разделе "Разработчики" extref:{contributors}[Списка контрибьюторов, staff-committers]. Записи сортируются по фамилии.
+
[.filename]#doc/shared/contrib-additional.adoc# - _Удалить_ запись. Записи отсортированы по имени.
. Добавление статьи в Новости
+
[.filename]#doc/website/data/en/news/news.toml# - Добавьте запись. Найдите другие записи, объявляющие о новых коммиттерах, и следуйте формату. Используйте дату из письма об утверждении коммиттерских прав.
. Добавить PGP-ключ
+
`{des}` написал сценарий оболочки ([.filename]#doc/documentation/tools/addkey.sh#) для упрощения этого процесса. Для получения дополнительной информации обратитесь к файлу https://cgit.freebsd.org/doc/plain/documentation/static/pgpkeys/README[README].
+
Используйте [.filename]#doc/documentation/tools/checkkey.sh# для проверки, что ключи соответствуют как минимум минимальным стандартам лучших практик.
+
После добавления и проверки ключа добавьте оба обновленных файла в систему контроля версий и затем зафиксируйте (commit) их. Записи в этом файле отсортированы по фамилии.
+
[NOTE]
======
Очень важно иметь актуальный PGP/GnuPG ключ в репозитории. Ключ может потребоваться для подтверждения личности коммиттера. Например, `{admins}` используют его для восстановления учетной записи. Полный набор ключей пользователей `FreeBSD.org` доступен для скачивания по ссылке link:https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt[https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt].
======
. Обновление информации о наставнике и подопечном
+
[.filename]#src/share/misc/committers-<repository>.dot# - Добавить запись в раздел текущих коммиттеров, где _repository_ - это `doc`, `ports` или `src`, в зависимости от предоставленных прав коммита.
+
Добавьте запись для каждого дополнительного отношения наставник/подопечный в нижнем разделе.
. Сгенерировать пароль Kerberos
+
См. crossref:committers-guide[kerberos-ldap, Kerberos и LDAP веб-пароль для кластера FreeBSD] для генерации или настройки учётной записи Kerberos для использования с другими сервисами FreeBSD, такими как link:https://bugs.freebsd.org/bugzilla/[база данных отслеживания ошибок] (вы получаете учётную запись для отслеживания ошибок как часть этого шага).
. Необязательно: Включить учётную запись Вики
+
Учётная запись link:https://wiki.freebsd.org[FreeBSD Wiki] — учётная запись на вики позволяет делиться проектами и идеями. Те, у кого ещё нет учётной записи, могут следовать инструкциям на странице link:https://wiki.freebsd.org/Wiki/About[Wiki/About], чтобы её получить. Свяжитесь с mailto:wiki-admin@FreeBSD.org[wiki-admin@FreeBSD.org], если вам нужна помощь с вашей учётной записью на Вики.
. Необязательно: Обновить информацию в Вики
+
Информация в вики — получив доступ к вики, некоторые добавляют записи на страницы https://wiki.freebsd.org/HowWeGotHere[Как мы сюда попали], https://wiki.freebsd.org/IRC/Nicknames[IRC-псевдонимы], https://wiki.freebsd.org/Community/Dogs[Собаки FreeBSD] и/или https://wiki.freebsd.org/Community/Cats[Кошки FreeBSD].
. Необязательно: Обновить порты с личной информацией
+
[.filename]#ports/astro/xearth/files/freebsd.committers.markers# и [.filename]#src/usr.bin/calendar/calendars/calendar.freebsd# — Некоторые люди добавляют в эти файлы записи о себе, чтобы указать своё местоположение или дату своего дня рождения.
. Необязательно: Предотвращение повторных рассылок
+
Подписчики {dev-commits-doc-all}, {dev-commits-ports-all} или {dev-commits-src-all}, возможно, захотят отписаться, чтобы избежать получения дубликатов сообщений о коммитах и ответов на них.
====

[[conventions-everyone]]
=== Для всех

[[conventions-everyone-steps]]
[.procedure]
====
. Представьтесь другим разработчикам, иначе никто не будет иметь представления, кто вы и над чем работаете. Представление не должно быть исчерпывающей биографией — просто напишите абзац или два о том, кто вы, чем планируете заниматься как разработчик в FreeBSD, и кто будет вашим наставником. Отправьте это по электронной почте на {developers-name}, и вы начнёте свой путь!
. Войдите на `freefall.FreeBSD.org` и создайте файл [.filename]#/var/forward/пользователь# (где _пользователь_ — это ваше имя пользователя), содержащий адрес электронной почты, на который должны перенаправляться письма, адресованные на _вашеимяпользователя_@FreeBSD.org. Это включает все сообщения о коммитах, а также любую другую почту, адресованную {committers-name} и {developers-name}. Очень большие почтовые ящики, которые заняли постоянное место на `freefall`, могут быть усечены без предупреждения, если потребуется освободить место, поэтому перенаправляйте или сохраняйте их в другом месте.
+
[NOTE]
======
Если ваша система электронной почты использует SPF со строгими правилами, вам следует исключить `mx2.FreeBSD.org` из проверок SPF.
======
+
Из-за высокой нагрузки, которую обработка СПАМа создает на центральных почтовых серверах, обрабатывающих почтовые рассылки, фронтенд-сервер выполняет базовые проверки и может отбрасывать некоторые сообщения на их основе. В настоящее время единственной активной проверкой является наличие корректной DNS-информации для подключающегося хоста, но это может измениться. Некоторые пользователи связывают эти проверки с ложным отбрасыванием легитимной почты. Для отключения данных проверок для вашей почты создайте файл с именем [.filename]#~/.spam_lover# на `freefall.FreeBSD.org`.
+
[NOTE]
======
Те, кто являются разработчиками, но не коммиттерами, не будут подписаны на рассылки коммиттеров или разработчиков. Подписки определяются правами доступа.
======
====

[[smtp-setup]]
==== Настройка доступа SMTP

Для тех, кто желает отправлять электронные письма через инфраструктуру FreeBSD.org, следуйте приведенным ниже инструкциям:

[.procedure]
====
. Направьте ваш почтовый клиент на `smtp.FreeBSD.org:587`.
. Включить STARTTLS.
. Убедитесь, что ваш адрес `From:` установлен как `_вашеимяпользователя_@FreeBSD.org`.
. Для аутентификации можно использовать ваше имя пользователя и пароль FreeBSD Kerberos (см. crossref:committers-guide[kerberos-ldap, Kerberos и LDAP веб-пароль для кластера FreeBSD]). Предпочтительнее использовать принципал `_вашеимяпользователя_/mail`, так как он действителен только для аутентификации к почтовым ресурсам.
+
[NOTE]
======
При вводе имени пользователя не включайте `@FreeBSD.org`.
======
+
.Дополнительные заметки
[NOTE]
======
* Будет принимать почту только от `_вашеимяпользователя_@FreeBSD.org`. Если вы аутентифицированы как один пользователь, вам не разрешено отправлять почту от другого.
* Будет добавлен заголовок сообщения с именем пользователя SASL: (`Authenticated sender: _имя_пользователя_`).
* На хосте действуют различные ограничения по скорости для сокращения попыток взлома перебором паролей.
======
====

[[smtp-setup-local-mta]]
===== Использование локального MTA для пересылки электронной почты в SMTP-сервис FreeBSD.org

Также возможно использовать локальный MTA для пересылки локально отправленных писем на SMTP-серверы FreeBSD.org.

[[smtp-setup-local-postfix]]
.Использование Postfix
[example]
====

Чтобы сообщить локальному экземпляру Postfix, что любое письмо от `_вашеимяпользователя_@FreeBSD.org` должно быть перенаправлено на серверы FreeBSD.org, добавьте это в ваш [.filename]#main.cf#:

[.programlisting]
....
sender_dependent_relayhost_maps = hash:/usr/local/etc/postfix/relayhost_maps
smtp_sasl_auth_enable = yes
smtp_sasl_security_options = noanonymous
smtp_sasl_password_maps = hash:/usr/local/etc/postfix/sasl_passwd
smtp_use_tls = yes
....

Создайте файл [.filename]#/usr/local/etc/postfix/relayhost_maps# со следующим содержимым:

[.programlisting]
....
вашеимяпользователя@FreeBSD.org [smtp.freebsd.org]:587
....

Создайте [.filename]#/usr/local/etc/postfix/sasl_passwd# со следующим содержимым:

[.programlisting]
....
[smtp.freebsd.org]:587          вашеимяпользователя:вашпароль
....

Если почтовый сервер используется другими людьми, вы можете захотеть предотвратить отправку ими писем с вашего адреса. Для достижения этой цели добавьте это в ваш [.filename]#main.cf#:

[.programlisting]
....
smtpd_sender_login_maps = hash:/usr/local/etc/postfix/sender_login_maps
smtpd_sender_restrictions = reject_known_sender_login_mismatch
....

Создайте файл [.filename]#/usr/local/etc/postfix/sender_login_maps# со следующим содержимым:

[.programlisting]
....
вашеимяпользователя@FreeBSD.org вашеимялокальногопользователя
....

Где _вашеимялокальногопользователя_ — это имя пользователя SASL, используемое для подключения к локальному экземпляру Postfix.
====

[[smtp-setup-local-opensmtpd]]
.Использование OpenSMTPD
[example]
====

Чтобы указать локальному экземпляру OpenSMTPD, что все письма от `_вашеимяпользователя_@FreeBSD.org` должны быть перенаправлены на серверы FreeBSD.org, добавьте это в ваш [.filename]#smtpd.conf#:

[.programlisting]
....
action "freebsd" relay host smtp+tls://freebsd@smtp.freebsd.org:587 auth <secrets>
match from any auth вашеимялокальногопользователя mail-from "_вашеимяпользователя_@freebsd.org" for any action "freebsd"
....

Где _вашеимялокальногопользователя_ — это имя пользователя SASL, используемое для подключения к локальному экземпляру OpenSMTPD.

Создайте файл [.filename]#/usr/local/etc/mail/secrets# со следующим содержимым:

[.programlisting]
....
freebsd	вашеимяпользователя:вашпароль
....

====
[[smtp-setup-local-exim]]
.Использование Exim
[example]
====

Чтобы направить локальный экземпляр Exim для пересылки всей почты от
`_example_@FreeBSD.org` на серверы FreeBSD.org, добавьте это в [.filename]#конфигурацию# Exim:

[.programlisting]
....
Routers section: (at the top of the list):
freebsd_send:
   driver = manualroute
   domains = !+local_domains
   transport = freebsd_smtp
   route_data = ${lookup {${lc:$sender_address}} lsearch {/usr/local/etc/exim/freebsd_send}}

Transport Section:
freebsd_smtp:
        driver = smtp
  tls_certificate=<local certificate>
  tls_privatekey=<local certificate private key>
  tls_require_ciphers = EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:EECDH+aRSA+SHA384:EECDH+aRSA+SHA256:EECDH+AESGCM:EECDH:EDH+AESGCM:EDH+aRSA:HIGH:!MEDIUM:!LOW:!aNULL:!eNULL:!LOW:!RC4:!MD5:!EXP:!PSK:!SRP:!DSS
  dkim_domain = <local DKIM domain>
  dkim_selector = <local DKIM selector>
  dkim_private_key= <local DKIM private key>
  dnssec_request_domains = *
  hosts_require_auth = smtp.freebsd.org

Authenticators:
freebsd_plain:
  driver = plaintext
  public_name = PLAIN
  client_send = ^example/mail^examplePassword
  client_condition = ${if eq{$host}{smtp.freebsd.org}}
....

Создайте файл [.filename]#/usr/local/etc/exim/freebsd_send# со следующим содержимым:

[.programlisting]
....
example@freebsd.org:smtp.freebsd.org::587
....

====

[[mentors]]
=== Наставники

Все новые разработчики получают наставника на первые несколько месяцев. Наставник отвечает за обучение подопечного правилам и соглашениям проекта и направляет его первые шаги в сообществе разработчиков. Наставник также несёт личную ответственность за действия подопечного в течение этого начального периода.

Для коммиттеров: не коммитьте ничего без предварительного одобрения ментора. Задокументируйте это одобрение строкой `Approved by:` в сообщении коммита.

Когда наставник решает, что подопечный освоил основы и готов к самостоятельной фиксации изменений, наставник объявляет об этом, выполняя коммит в [.filename]#mentors#. Этот файл находится в сиротской ветке [.filename]#admin# каждого репозитория. Подробная информация о том, как получить доступ к этим веткам, доступна в crossref:committers-guide[admin-branch, ветке "admin"].

[[pre-commit-review]]
== Предварительная проверка перед коммитом

Рецензирование кода — один из способов повышения качества программного обеспечения. Следующие рекомендации применимы к коммитам в ветку `main` (-CURRENT) репозитория `src`. Другие ветки, а также деревья `ports` и `docs` имеют собственные политики проверки и рецензирования, но данные рекомендации в целом применимы к коммитам, требующим рецензии:

* Все нетривиальные изменения должны быть проверены перед их фиксацией в репозитории.
* Рецензирование может проводиться по электронной почте, в Bugzilla, в Phabricator или с помощью другого механизма. По возможности рецензирование должно быть публичным.
* Разработчик, ответственный за изменение кода, также обязан вносить все необходимые изменения, связанные с проверкой.
* Рецензирование кода может быть итеративным процессом, который продолжается до тех пор, пока патч не будет готов к коммиту. В частности, после отправки патча на рецензирование, он должен получить явное подтверждение "выглядит хорошо" перед коммитом. Оно должно быть явным, и это может принимать любую форму, которая имеет смысл для метода резензирования.
* Тайм-ауты не являются заменой проверке.

Иногда проверка кода занимает больше времени, чем хотелось бы, особенно для большого по объему функционала. Принятые способы ускорить проверку ваших патчей:

* Проверяйте патчи других людей. Если вы помогаете, все будут более охотно делать то же самое для вас; доброжелательность — наша валюта.
* Пингуйте патч. Если он срочный, укажите причины, почему для вас важно, чтобы этот патч был принят, и пингуйте каждые пару дней. Если он не срочный, общепринятая вежливая частота пинга — одна неделя. Помните, что вы просите у других профессиональных разработчиков их ценное время.
* Обратитесь за помощью в списки рассылки, IRC и т.д. Другие могут либо помочь вам напрямую, либо предложить рецензента.
* Разделите ваш патч на несколько меньших патчей, которые основываются друг на друге. Чем меньше ваш патч, тем выше вероятность, что кто-то бегло его просмотрит.
+
При внесении крупных изменений полезно держать это в уме с самого начала работы, поскольку разбиение крупных изменений на более мелкие часто бывает затруднительно постфактум.

Разработчикам следует участвовать в проверках кода как в роли авторов, так и в роли рецензентов. Если кто-то любезно проверил ваш код, вы должны ответить тем же для кого-то другого. Обратите внимание, что хотя любой может проверить и дать обратную связь по патчу, только соответствующий эксперт по теме может одобрить изменение. Обычно это коммиттер, который регулярно работает с рассматриваемым кодом.

В некоторых случаях может не оказаться эксперта по предметной области. В таких случаях достаточно проверки опытным разработчиком в сочетании с соответствующим тестированием.

[[commit-log-message]]
== Журнал сообщений о коммитах

В этом разделе содержатся некоторые предложения и традиции по форматированию журналов коммитов.

=== Почему важны сообщения коммитов?

При фиксации изменения в Git, Subversion или другой системе контроля версий (СКВ) вам предлагается написать текст с описанием коммита — сообщение о коммите. Насколько важно это сообщение о коммите? Стоит ли прилагать значительные усилия для его написания? Имеет ли значение, если вы просто напишете `исправлена ошибка`?

У большинства проектов более одного разработчика, и они длятся в течение некоторого времени. Сообщения коммитов — это очень важный способ общения с другими разработчиками, как в настоящем, так и в будущем.

В FreeBSD сотни активных разработчиков и сотни тысяч коммитов, охватывающих десятилетия истории. За это время сообщество разработчиков осознало, насколько ценны хорошие сообщения к коммитам; иногда эти уроки давались тяжело.

Сообщения коммитов служат как минимум трем целям:

* Сотрудничество с другими
+
Коммиты FreeBSD генерируют письма для различных списков рассылки. Они включают сообщение коммита вместе с копией самого патча. Сообщения коммитов также просматриваются с помощью команд, таких как `git log`. Это служит для информирования других разработчиков об изменениях, которые происходят; другой разработчик может захотеть протестировать изменение, может быть заинтересован в теме и захочет просмотреть более подробно, или может иметь свои собственные проекты, которые выиграют от взаимодействия.

* Обеспечение возможности обнаружения изменений
+
В большом проекте с долгой историей может быть сложно найти интересующие изменения при расследовании проблемы или изменения в поведении. Подробные, детальные сообщения о коммитах позволяют искать изменения, которые могут быть релевантны. Например, `git log --since 1year --grep 'USB timeout'`.

* Предоставление исторической документации
+
Сообщения о фиксации служат для документирования изменений для будущих разработчиков, возможно, спустя годы или десятилетия. Этот будущий разработчик может оказаться даже вами, первоначальным автором. Изменение, которое кажется очевидным сегодня, может оказаться совсем не таким в будущем.

Команда `git blame` аннотирует каждую строку исходного файла информацией о изменении (хэш и тема коммита), которое её добавило.

Теперь, когда важность хорошего сообщения о коммите в FreeBSD несомненна, вот его элементы:

=== Начните со строки темы

Сообщения о коммите должны начинаться с однострочной темы, кратко описывающей изменение. Сама по себе тема должна позволять читателю быстро определить, представляет ли изменение интерес.

=== Сохраняйте заголовки краткими

Строка темы должна быть максимально короткой, но при этом сохранять необходимую информацию. Это повышает эффективность просмотра журнала Git и позволяет команде `git log --oneline` отображать короткий хэш и тему на одной 80-символьной строке. Хорошим эмпирическим правилом является удержание длины ниже 67 символов, а по возможности — около 50 или меньше.

=== Добавьте к строке темы префикс с указанием компонента, если это применимо

Если изменение относится к определённому компоненту, строка темы может быть предварена именем этого компонента и двоеточием (:). По возможности используйте тот же префикс, который применялся в предыдущих коммитах к тем же файлам.

✓ `foo: Add -k option to keep temporary data`

Включите префикс в лимит 67 символов, чтобы `git log --oneline` избегал переноса.

=== Напишите первую букву темы с заглавной буквы

Первая буква темы должна быть заглавной. Префикс, если он есть, с заглавной буквы не пишется, если это не требуется (например, `USB:` пишется с заглавной буквы).

=== Не заканчивайте строку темы знаками препинания

Не ставьте точку или другие знаки препинания в конце. В этом отношении строка темы подобна заголовку в газете.

=== Разделите тему и тело письма пустой строкой

Отделите тело от темы пустой строкой.

Некоторые тривиальные коммиты не требуют тела и содержат только заголовок.

✓ `ls: Fix typo in usage text`

=== Ограничьте сообщения до 72 колонок

`git log` и `git format-patch` делают отступ в сообщении коммита на четыре пробела. Перенос строк на 72-й колонке обеспечивает соответствующий отступ по правому краю. Ограничение сообщений 72 символами также удерживает сообщение коммита в форматированных патчах ниже рекомендованного RFC 2822 ограничения длины строки электронной почты в 78 символов. Это ограничение хорошо работает с различными инструментами, которые могут отображать сообщения коммитов; перенос строк может быть непоследовательным при большей длине строки.

=== Используйте настоящее время, повелительное наклонение

Это способствует краткости тем и обеспечивает единообразие, включая автоматически генерируемые сообщения коммитов (например, создаваемые `git revert`). Это важно при чтении списка тем коммитов. Думайте о теме как о завершении фразы «при применении это изменение позволит...(when applied, this change will ...)».

✓ `foo: Implement the -k (keep) option` +
✗ `foo: Implemented the -k option` +
✗ `This change implements the -k option in foo` +
✗ `-k option added`

=== Сосредоточьтесь на том, что и почему, а не на том, как

Объясните, чего достигает изменение и почему оно делается, а не как.

Не предполагайте, что читатель знаком с проблемой. Объясните предысторию и мотивацию изменения. Включите данные тестирования производительности, если они у вас есть.

Если в изменениях есть ограничения или неполные аспекты, опишите их в сообщении коммита.

=== Подумайте, можно ли части сообщения коммита оформить как комментарии в коде

Иногда при написании сообщения коммита вы можете обнаружить, что пишете одно-два предложения, объясняющих какой-то сложный или запутанный аспект изменения. В таких случаях стоит подумать, будет ли полезно иметь это объяснение в виде комментария в самом коде.

=== Напишите сообщения коммитов для себя в будущем

При написании сообщения коммита для изменения у вас есть весь контекст в голове — что вызвало изменение, альтернативные подходы, которые рассматривались и были отклонены, ограничения изменения и так далее. Представьте, что вы возвращаетесь к изменению через год или два, и напишите сообщение коммита таким образом, чтобы оно предоставило этот необходимый контекст.

=== Сообщения о коммитах должны быть самодостаточными

Вы можете включать ссылки на сообщения в почтовых рассылках, сайты с результатами тестирования производительности или ссылки на проверки кода. Однако, сообщение о коммите должно содержать всю соответствующую информацию на случай, если эти ссылки станут недоступны в будущем.

Аналогично, коммит может ссылаться на предыдущий коммит, например, в случае исправления ошибки или отката. Помимо идентификатора коммита (ревизии или хеша), включите строку темы из упомянутого коммита (или другую подходящую краткую ссылку). С каждой миграцией системы контроля версий (от CVS к Subversion и затем к Git) идентификаторы ревизий из предыдущих систем могут становиться трудными для отслеживания.

=== Укажите необходимые метаданные в нижней части

Помимо включения информативного сообщения с каждым коммитом, может потребоваться некоторая дополнительная информация.

Эта информация состоит из одной или нескольких строк, содержащих ключевое слово или фразу, двоеточие, табуляции для форматирования и затем дополнительную информацию.

Для ключевых слов, где допустимы множественные значения (например, `PR:` со списком PR через запятую), разрешается использовать одно и то же ключевое слово несколько раз, чтобы избежать неоднозначности или улучшить читаемость.

Ключевые слова или фразы:

[.informaltable]
[cols="20%,80%", frame="none"]
|===

|`PR:`
|Номер отчета о проблеме (если есть), на который влияет данный коммит (обычно путем закрытия). Можно указать несколько номеров PR в одной строке, разделяя их запятыми или пробелами.

|`Reported by:`
|Имя и адрес электронной почты лица, сообщившего о проблеме; для разработчиков — только имя пользователя в кластере FreeBSD.
Обычно используется, когда нет PR, например, если проблема была сообщена в
почтовой рассылке.

|`Submitted by:` +
(deprecated)
|Это устарело в git; отправляемые патчи должны указывать автора с помощью `git commit --author` с указанием полного имени и действительного email.

|`Reviewed by:`
a| 
Имя и адрес электронной почты человека или людей, которые проверили изменение; для разработчиков достаточно указать имя пользователя в кластере FreeBSD. Если патч был отправлен в список рассылки для проверки и получил положительный отзыв, то укажите только название списка. Если рецензент не является участником проекта, укажите имя, электронную почту и, если это порт, внешнюю роль, например, сопровождающего:

Проверено разработчиком:
[source,shell]
....
Reviewed by: username
....

Проверено сопровождающим портов, не являющимся разработчиком:
[source,shell]
....
Reviewed by: Full Name <valid@email> (maintainer)
....

|`Tested by:`
|Имя и адрес электронной почты человека или людей, которые проверили изменение; для разработчиков — просто имя пользователя в кластере FreeBSD.

|`Discussed with:`
|Имя и адрес электронной почты человека или людей, которые внесли вклад в исправление, предоставив содержательную обратную связь; для разработчиков — просто имя пользователя в кластере FreeBSD.
Обычно используется для упоминания тех, кто не проводил явного рецензирования, тестирования или одобрения изменения, но тем не менее участвовал в обсуждении, связанном с изменением, что привело к улучшениям и лучшему пониманию его влияния на проект FreeBSD.

|`Approved by:`
a| 

Имя и адрес электронной почты лица или лиц, утвердивших изменение; для разработчиков — просто имя пользователя в кластере FreeBSD.

Есть несколько случаев, когда утверждение является обычной практикой:

* когда новый коммиттер находится под наставничеством
* коммиты в область дерева, указанную в файле LOCKS (src)
* во время цикла выпуска
* коммиты в репозиторий, где у вас нет права на коммит (например, коммиттер src делает коммит в docs)
* коммиты в порт, поддерживаемый кем-то другим

Во время наставничества получите одобрение наставника перед коммитом. Укажите имя пользователя наставника в этом поле и отметьте, что он является наставником:

[source,shell]
....
Approved by: имя-пользователя-наставника (mentor)
....

Если коммиты были утверждены командой, укажите название команды, за которым в скобках следует имя пользователя утверждающего. Например:

[source,shell]
....
Approved by: re (имя-пользователя)
....

|`Obtained from:`
|Название проекта (если есть), из которого был получен код. Не используйте эту строку для указания имени отдельного человека.

|`Fixes:`
|Короткий хэш Git и заголовок коммита, который исправлен этим изменением, как возвращается командой `git log -n 1 --pretty=format:'%h ("%s")' GIT-COMMIT-HASH`.
Мы включаем заголовок коммита, чтобы можно было найти указанный коммит даже в случае, если будущая миграция системы контроля версий сделает ссылки по хэшу недействительными.

|`MFC after:`
|Чтобы получить напоминание по электронной почте о запланированном MFC через определенное время, укажите количество дней, недель или месяцев, после которых планируется выполнить MFC.

|`MFC to:`
|Если коммиту должно быть сделано слияние в подмножество стабильных веток, укажите названия веток.

|`MFH:`
|Если коммиту должено быть сделано слияние в квартальную ветку портов, укажите квартальную ветку. Например, `2021Q2`.

|`Relnotes:`
|Если изменение является кандидатом для включения в примечания к выпуску следующей версии из ветки, установите значение `yes`.

|`Security:`
|Если изменение связано с уязвимостью или угрозой безопасности, укажите одну или несколько ссылок либо описание проблемы. По возможности включите URL VuXML или идентификатор CVE.

|`Event:`
|Описание события, в рамках которого был выполнен этот коммит. Если это повторяющееся событие, добавьте год или даже месяц. Например, это может быть `FooBSDcon 2019`. Идея этой строки — отдать должное конференциям, встречам и другим подобным мероприятиям, а также показать, что их проведение полезно. Пожалуйста, не используйте строку `Sponsored by:` для этого, так как она предназначена для организаций, спонсирующих определённые функции, или разработчиков, работающих над ними.

|`Sponsored by:`
|Организации, спонсировавшие это изменение (если есть). Разделяйте несколько организаций запятыми. Если только часть работы была спонсирована или разные суммы спонсорской поддержки были предоставлены разным авторам, укажите соответствующую информацию в скобках после каждого имени спонсора. Например, `Example.com (alice, code refactoring), Wormulon (bob), Momcorp (cindy)` показывает, что Alice была спонсирована Example.com для рефакторинга кода, в то время как Wormulon спонсировал работу Bob, а Momcorp спонсировал работу Cindy. Другие авторы либо не были спонсированы, либо решили не указывать спонсорство.

|`Pull Request:`
|Это изменение было отправлено как запрос на принятие изменений (pull request) или запрос на слияние (merge request) в один из публичных Git-репозиториев FreeBSD только для чтения.
Оно должно включать полный URL запроса на включение изменений, так как они часто выполняют роль рецензий кода.
Например: `https://github.com/freebsd/freebsd-src/pull/745`

|`Co-authored-by:`
|Имя и адрес электронной почты дополнительного автора коммита.
GitHub содержит подробное описание трейлера Co-authored-by по адресу https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors.

|`Signed-off-by:`
|ID подтверждает соответствие требованиям https://developercertificate.org/

|`Differential Revision:`
|Полный URL обзора в Phabricator. Эта строка __должна быть последней строкой__. Например: `https://reviews.freebsd.org/D1708`.

|===

.Журнал изменений для коммита на основе PR
[example]
====

Коммит основан на патче из PR, предоставленного Джоном Смитом. Поле "PR" в сообщении коммита заполнено.

[.programlisting]
....
...

PR:		12345
....

Участник устанавливает автора патча с помощью `git commit --author "John Smith <John.Smith@example.com>"`.

====

.Журнал изменений для коммита, требующего проверки
[example]
====

Вносятся изменения в систему виртуальной памяти. После отправки патчей в соответствующий список рассылки (в данном случае, `freebsd-arch`) и утверждения изменений.

[.programlisting]
....
...

Reviewed by:	-arch
....

====

.Журнал изменений для коммита, требующего одобрения
[example]
====

Закоммитить порт после согласования с указанным MAINTAINER, который дал добро на коммит.

[.programlisting]
....
...

Approved by:	abc (maintainer)
....

Где _abc_ — имя учётной записи лица, одобрившего коммит.
====

.Журнал изменений для коммита, вносящего код из OpenBSD
[example]
====

Коммит некоторого кода на основе работы, выполненной в проекте OpenBSD.

[.programlisting]
....
...

Obtained from:	OpenBSD
....

====

.Журнал коммитов для правки в FreeBSD-CURRENT с запланированным коммитом в FreeBSD-STABLE в последующее время.
[example]
====

Коммит некоторого кода, которому будет сделано слияние из ветки FreeBSD-CURRENT в ветку FreeBSD-STABLE через две недели.

[.programlisting]
....
...

MFC after:	2 weeks
....

Где _2_ — количество дней, недель или месяцев, после которых запланировано MFC. Вариант _weeks_ может быть — `day`, `days`, `week`, `weeks`, `month`, `months`.
====

Часто необходимо комбинировать их.

Рассмотрим ситуацию, когда пользователь отправил PR с кодом из проекта NetBSD. Разработчик, просматривая PR, видит, что это не та часть дерева, с которой он обычно работает, поэтому он отправляет изменение на рецензирование в список рассылки `arch`. Поскольку изменение сложное, разработчик решает отложить MFC на месяц, чтобы обеспечить достаточное тестирование.

Дополнительная информация, которую нужно включить в коммит, будет выглядеть примерно так

.Пример объединённого журнала коммитов
[example]
====

[.programlisting]
....
PR:		54321
Reviewed by:	-arch
Obtained from:	NetBSD
MFC after:	1 month
Relnotes:	yes
....

====

[[pref-license]]
== Предпочтительная лицензия для новых файлов

Полная политика лицензирования проекта FreeBSD доступна по ссылке link:https://www.FreeBSD.org/internal/software-license/[https://www.FreeBSD.org/internal/software-license]. Остальная часть этого раздела предназначена для того, чтобы помочь вам начать работу. Как правило, если сомневаетесь — спрашивайте. Дать совет гораздо проще, чем исправлять дерево исходного кода.

Проект FreeBSD предлагает и использует следующий текст в качестве предпочтительной схемы лицензирования:

[.programlisting]
....
/*
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) [year] [your name]
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * [id for your version control system, if any]
 */
....

Проект FreeBSD настоятельно не рекомендует использовать так называемую «рекламную оговорку» в новом коде. Из-за большого числа участников проекта FreeBSD соблюдение этой оговорки стало затруднительным для многих коммерческих вендоров. Если ваш код в дереве содержит рекламную оговорку, пожалуйста, рассмотрите возможность её удаления. Более того, пожалуйста, рассмотрите возможность использования вышеуказанной лицензии для вашего кода.

Проект FreeBSD не приветствует полностью новые лицензии и вариации стандартных лицензий. Новые лицензии требуют одобрения {core-email} для размещения в репозитории `src`. Чем больше различных лицензий используется в дереве, тем больше проблем это создаёт для тех, кто желает использовать этот код, обычно из-за непредвиденных последствий плохо сформулированной лицензии.

Политика проекта требует, чтобы код под некоторыми не-BSD лицензиями размещался только в определённых разделах репозитория, а в некоторых случаях компиляция должна быть условной или даже отключена по умолчанию. Например, ядро GENERIC должно компилироваться только под лицензиями, идентичными или существенно схожими с лицензией BSD. Программное обеспечение под лицензиями GPL, APSL, CDDL и т.п. не должно компилироваться в GENERIC.

Разработчикам следует помнить, что в открытом исходном коде правильное понимание «открытости» так же важно, как и правильное понимание «исходного кода», поскольку неправильное обращение с интеллектуальной собственностью имеет серьёзные последствия. Любые вопросы или опасения следует немедленно доводить до сведения основной команды.

[[tracking.license.grants]]
== Отслеживание лицензий, предоставленных проекту FreeBSD

Различное программное обеспечение или данные существуют в репозиториях, где проект FreeBSD получил специальную лицензию для их использования. Примером могут служить шрифты Terminus для использования с man:vt[4]. Здесь автор Димитар Жеков разрешил нам использовать шрифт "Terminus BSD Console" под лицензией BSD с двумя пунктами, а не под обычной Open Font License, которую он обычно применяет.

Очевидно, разумно вести учет всех подобных разрешений лицензий. С этой целью {core-email} решил сохранять их архив. Каждый раз, когда проекту FreeBSD предоставляется специальная лицензия, мы требуем уведомлять {core-email}. Разработчики, участвующие в организации такого разрешения, пожалуйста, присылайте детали на {core-email}, включая:

* Контактные данные лиц или организаций, предоставляющих специальную лицензию.
* Какие файлы, каталоги и т.д. в репозиториях охватываются предоставлением лицензии, включая номера ревизий, в которые был добавлен любой материал с особыми условиями лицензирования.
* Дата вступления лицензии в силу. Если не согласовано иное, это будет дата выдачи лицензии авторами соответствующего программного обеспечения.
* Текст лицензии.
* Примечание о любых ограничениях, исключениях или особых условиях, которые применяются конкретно к использованию лицензионных материалов в FreeBSD.
* Любая другая соответствующая информация.

Как только {core-email} убедится, что собраны все необходимые данные и они корректны, секретарь отправит подтверждение о получении, подписанное PGP, включая детали лицензии. Это подтверждение будет постоянно архивироваться и служить нашим постоянным свидетельством о предоставлении лицензии.

Архив лицензий должен содержать только сведения о предоставленных лицензиях; это не место для обсуждений вопросов лицензирования или других тем. Доступ к данным в архиве лицензий будет предоставляться по запросу в {core-email}.

[[spdx.tags]]
== Теги SPDX в дереве

Проект использует теги https://spdx.dev[SPDX] в нашей исходной базе. На данный момент эти теги выделены отступами, чтобы автоматизированные средства могли программно извлекать лицензионные условия. Все теги _SPDX-License-Identifier_ в дереве следует считать информативными. Все файлы в дереве исходных кодов FreeBSD с этими тегами также содержат копию лицензии, регулирующей использование данного файла. Если возникает противоречие, руководствоваться следует дословным текстом лицензии. Проект старается следовать https://spdx.github.io/spdx-spec/v2.2.2/[Спецификации SPDX, версия 2.2]. Инструкцию, как помечать исходные файлы, и допустимые алгебраические выражения можно найти в https://spdx.github.io/spdx-spec/v2.2.2/SPDX-license-expressions/[Приложении D] и https://spdx.github.io/spdx-spec/v2.2.2/using-SPDX-short-identifiers-in-source-files/[Приложении E]. Проект берет идентификаторы из списка допустимых https://spdx.org/licenses/[кратких лицензионных идентификаторов] SPDX. Проект использует только тег _SPDX-License-Identifier_.

По состоянию на март 2021 года примерно 25 000 из 90 000 файлов в дереве были помечены.
[[developer.relations]]
== Отношения с разработчиками

При работе непосредственно с вашим собственным кодом или с кодом, который уже хорошо зарекомендовал себя как ваша зона ответственности, вероятно, нет особой необходимости согласовывать действия с другими коммиттерами перед внесением изменений. Это же относится и к исправлению ошибок в явно заброшенных частях системы (к сожалению, такие области существуют). При изменении частей системы, которые поддерживаются (формально или неформально), рассмотрите возможность запроса рецензирования, как это делал бы разработчик до получения прав коммиттера. Для портов свяжитесь с сопровождающим, указанным в переменной `MAINTAINER` в файле [.filename]#Makefile#.

Чтобы определить, поддерживается ли определённая часть дерева, проверьте файл MAINTAINERS в корне дерева. Если там никого не указано, просмотрите историю изменений, чтобы увидеть, кто вносил изменения в прошлом. Чтобы вывести список имён и адресов электронной почты всех авторов коммитов для заданного файла за последние 2 года, а также количество коммитов каждого автора, отсортированных по убыванию количества коммитов, используйте:

[source, shell]
----
% git -C /path/to/repo shortlog -sne --since="2 years" -- relative/path/to/file
----

Если запросы остаются без ответа или коммиттер иным образом демонстрирует отсутствие интереса к затронутой области, можно смело выполнять коммит.

[IMPORTANT]
====
Избегайте отправки личных писем сопровождающим. Других людей может заинтересовать не только итоговый результат, но и обсуждение.
====

Если есть какие-либо сомнения относительно коммита по любой причине, необходимо провести его рецензирование перед выполнением. Лучше получить критику сразу, чем когда он станет частью репозитория. Если коммит вызывает споры, возможно, стоит рассмотреть возможность отката изменений до разрешения вопроса. Помните, что с системой контроля версий мы всегда можем вернуть всё обратно.

Не оспаривайте намерения других. Если они видят иное решение проблемы или даже иную проблему, скорее всего, это не потому, что они глупы, имеют сомнительное происхождение или пытаются разрушить чужой труд, личный имидж или FreeBSD, а просто потому, что у них иной взгляд на мир. Разное — это хорошо.

Честно выражайте несогласие. Обосновывайте свою позицию по её достоинствам, будьте честны относительно возможных недостатков и будьте открыты для понимания их решения или даже их видения проблемы.

Примите исправление. Все мы не безгрешны. Когда вы совершили ошибку, извинитесь и продолжайте жить дальше. Не корите себя и уж тем более не вините других за свою ошибку. Не тратьте время на смущение или взаимные обвинения — просто исправьте проблему и двигайтесь дальше.

Попросите о помощи. Ищите (и предоставляйте) рецензии коллег. Одно из преимуществ открытого программного обеспечения заключается в большом количестве проверяющих; но это не работает, если никто не проверяет код.

[[if-in-doubt]]
== Если сомневаетесь...

Если вы в чем-то не уверены, будь то технический вопрос или соглашение по проекту, обязательно спросите. Если вы промолчите, вы никогда не продвинетесь вперед.

Если вопрос связан с технической проблемой, задайте его в публичных списках рассылки. Удержитесь от соблазна написать лично тому, кто знает ответ. Так каждый сможет извлечь пользу из вопроса и ответа.

Для административных вопросов и вопросов, связанных с конкретным проектом, обращайтесь в следующем порядке:

* Ваш наставник или бывший наставник.
* Опытный коммиттер — по IRC, электронной почте и т.д.
* Любая команда с ролью ("hat"), так как в ней вам могут дать окончательный ответ.
* Если всё ещё не уверены, спросите на {developers-name}.

Когда ваш вопрос будет решён, если никто не указал вам на документацию, содержащую ответ на ваш вопрос, задокументируйте его, так как у других возникнет тот же вопрос.

[[bugzilla]]
== Bugzilla

Проект FreeBSD использует Bugzilla для отслеживания ошибок и запросов на изменения. Если вы исправили проблему или реализовали предложение из базы данных PR, обязательно закройте PR. Также будет вежливо, если вы найдёте время закрыть другие PR, связанные с вашими коммитами.

Коммиттеры с учётными записями Bugzilla не на ``FreeBSD.org`` могут объединить старую учётную запись с учётной записью `FreeBSD.org`, выполнив следующие шаги:

[.procedure]
====
. Войдите, используя старую учетную запись.
. Открыть новую ошибку. Выбрать `Services` в качестве продукта и `Bug Tracker` в качестве компонента. В описании ошибки перечислите аккаунты, которые нужно объединить.
. Войдите, используя учетную запись `FreeBSD.org`, и оставьте комментарий к только что созданной ошибке, чтобы подтвердить владение. Дополнительные сведения о том, как сгенерировать или установить пароль для вашей учетной записи `FreeBSD.org`, см. в crossref:committers-guide[kerberos-ldap, Kerberos и LDAP веб-пароль для кластера FreeBSD].
. Если необходимо объединить более двух учетных записей, оставьте комментарии от каждой из них.
====

Вы можете узнать больше о Bugzilla на:

* extref:{pr-guidelines}[Рекомендации по работе с сообщениями о проблемах FreeBSD]
* link:https://www.FreeBSD.org/support/[https://www.FreeBSD.org/support]

[[phabricator]]
== Phabricator

Проект FreeBSD использует https://reviews.freebsd.org[Phabricator] для запросов на рецензирование кода. Подробности можно найти на https://wiki.freebsd.org/Phabricator[странице Phabricator в вики].

Пожалуйста, используйте команду `git arc`, предоставляемую `devel/freebsd-git-devtools` (установите порт или пакет, затем введите `git help arc` для получения документации), для создания и обновления рецензий в Phabricator. Это упростит другим процесс проверки и тестирования ваших патчей.

Коммиттеры с учётными записями Phabricator не на ``FreeBSD.org`` могут переименовать старую учётную запись в ``FreeBSD.org``, выполнив следующие шаги:

[.procedure]
====
. Измените адрес электронной почты вашей учетной записи Phabricator на ваш `FreeBSD.org` email.
. Открыть новую ошибку в нашем трекере ошибок, используя вашу учетную запись `FreeBSD.org`, см. crossref:committers-guide[bugzilla, Bugzilla] для получения дополнительной информации. Выберите `Services` в качестве продукта и `Code Review` в качестве компонента. В описании ошибки запросите переименование вашей учетной записи Phabricator и укажите ссылку на вашего пользователя Phabricator. Например, `https://reviews.freebsd.org/p/bob_example.com/`
====

[IMPORTANT]
====
Учетные записи Phabricator не могут быть объединены, пожалуйста, не создавайте новую учетную запись.
====

[[people]]
== Кто есть кто

Помимо хранителей репозиториев, есть и другие участники проекта FreeBSD и команды, с которыми вам, скорее всего, предстоит познакомиться в роли коммиттера. Кратко и далеко не исчерпывающе, вот они:

`{doceng}`::
doceng — это группа, ответственная за инфраструктуру сборки документации, утверждение новых коммиттеров документации и обеспечение актуальности веб-сайта FreeBSD и документации на FTP-сайте в соответствии с деревом Subversion. Она не является органом по разрешению конфликтов. Подавляющее большинство обсуждений, связанных с документацией, происходит в рассылке {freebsd-doc}. Подробнее о команде doceng можно узнать в её https://www.FreeBSD.org/internal/doceng/[уставе]. Коммиттеры, заинтересованные в работе над документацией, должны ознакомиться с руководством extref:{fdp-primer}[Проект документации FreeBSD: введение для новых участников].

`{re-members}`::
Вот члены команды `{re}`. Эта команда отвечает за установку сроков выпуска и контроль процесса выпуска. Во время заморозки кода, инженеры выпуска обладают окончательным правом принятия решений по всем изменениям в системе для ветки, ожидающей статуса выпуска. Если у вас есть что-то, что вы хотите влить (merge) из FreeBSD-CURRENT в FreeBSD-STABLE (какими бы ни были их значения в любой момент времени), именно с этими людьми нужно обсудить этот вопрос.

`{so}`::
`{so-name}` — это link:https://www.FreeBSD.org/security/[ответственный за безопасность FreeBSD], который курирует работу `{security-officer}`.

{committers-name}::
{dev-src-all}, {dev-ports-all} and {dev-doc-all} are the mailing lists that the version control system uses to send commit messages to. _Never_ send email directly to these lists. Only send replies to this list when they are short and are directly related to a commit.

{developers-name}::
All committers are subscribed to -developers. This list was created to be a forum for the committers "community" issues. Examples are Core voting, announcements, etc.
+
`{developers-name}` предназначен исключительно для использования коммиттерами FreeBSD. Для разработки FreeBSD коммиттеры должны иметь возможность открыто обсуждать вопросы, которые будут решены до их публичного объявления. Откровенные обсуждения работы в процессе не подходят для открытой публикации и могут навредить FreeBSD.
+
Все коммиттеры FreeBSD обязаны не публиковать и не пересылать сообщения из {developers-name} за пределы списка рассылки без разрешения всех авторов. Нарушители будут удалены из {developers-name}, что приведёт к приостановке привилегий на коммит. Повторные или вопиющие нарушения могут привести к постоянному лишению привилегий на коммит.
+
Этот список _не_ предназначен для обзора кода или каких-либо технических обсуждений. На самом деле, использование его в таком качестве вредит проекту FreeBSD, так как создаёт впечатление закрытого списка, где общие решения, затрагивающие всех пользователей FreeBSD, принимаются без "открытости". И последнее, но не менее важное: __никогда, ни при каких обстоятельствах, не отправляйте письмо на {developers-name} с копией (CC:/BCC:) на другой список FreeBSD__. Никогда не отправляйте письмо на другой список рассылки FreeBSD с копией (CC:/BCC:) на {developers-name}. Это может значительно снизить пользу от данного списка.
[[ssh.guide]]
== Руководство по быстрому началу работы с SSH

[.procedure]
====
. Если вы не хотите каждый раз вводить пароль при использовании man:ssh[1] и используете ключи для аутентификации, man:ssh-agent[1] создан для вашего удобства. Если вы хотите использовать man:ssh-agent[1], убедитесь, что запускаете его перед запуском других приложений. Например, пользователи X обычно делают это в [.filename]#.xsession# или [.filename]#.xinitrc#. Подробности см. в man:ssh-agent[1].
. Сгенерируйте пару ключей с помощью man:ssh-keygen[1]. Пара ключей окажется в вашем каталоге [.filename]#$HOME/.ssh/#.
+
[IMPORTANT]
======
Поддерживаются только ключи ECDSA, Ed25519 или RSA.
======
. Отправьте ваш открытый ключ ([.filename]#$HOME/.ssh/id_ecdsa.pub#, [.filename]#$HOME/.ssh/id_ed25519.pub# или [.filename]#$HOME/.ssh/id_rsa.pub#) человеку, который настраивает вас как коммиттера, чтобы его можно было добавить в [.filename]#yourlogin# в [.filename]#/etc/ssh-keys/# на `freefall`.
====

Теперь man:ssh-add[1] можно использовать для аутентификации один раз за сеанс. Он запрашивает парольную фразу для закрытого ключа и затем сохраняет её в агенте аутентификации (man:ssh-agent[1]). Используйте `ssh-add -d` для удаления ключей, сохранённых в агенте.

Проверка с помощью простой удалённой команды: `ssh freefall.FreeBSD.org ls /usr`.

Для получения дополнительной информации см. package:security/openssh-portable[], man:ssh[1], man:ssh-add[1], man:ssh-agent[1], man:ssh-keygen[1] и man:scp[1].

Для информации о добавлении, изменении или удалении ключей man:ssh[1], см. https://wiki.freebsd.org/clusteradm/ssh-keys[эту статью].

[[coverity]]
== Доступность Coverity(R) для коммиттеров FreeBSD

Все разработчики FreeBSD могут получить доступ к результатам анализа Coverity для всего программного обеспечения проекта FreeBSD. Все, кто заинтересован в доступе к результатам автоматического анализа Coverity, могут зарегистрироваться на http://scan.coverity.com/[Coverity Scan].

В вики FreeBSD есть мини-руководство для разработчиков, которые заинтересованы в работе с отчетами анализа Coverity(R): https://wiki.freebsd.org/CoverityPrevent[https://wiki.freebsd.org/CoverityPrevent]. Обратите внимание, что это мини-руководство доступно только разработчикам FreeBSD, поэтому если вы не можете открыть эту страницу, вам нужно будет попросить добавить вас в соответствующий список доступа к вики.

Наконец, все разработчики FreeBSD, которые собираются использовать Coverity(R), всегда могут запросить дополнительные детали и информацию об использовании, задав любые вопросы в списке рассылки разработчиков FreeBSD.

[[rules]]
== Большой список правил коммиттеров FreeBSD

Все участники проекта FreeBSD должны соблюдать _Кодекс поведения_, доступный по ссылке link:https://www.FreeBSD.org/internal/code-of-conduct/[https://www.FreeBSD.org/internal/code-of-conduct]. Как коммиттеры, вы представляете публичное лицо проекта, и ваше поведение оказывает существенное влияние на его общественное восприятие. Это руководство расширяет разделы _Кодекса поведения_, относящиеся к коммиттерам.

. Уважайте других коммиттеров.
. Уважайте других участников.
. Обсудите любые значительные изменения _перед_ коммитом.
. Уважайте существующих сопровождающих (если они указаны в поле `MAINTAINER` в файле [.filename]#Makefile# или в файле [.filename]#MAINTAINER# в корневом каталоге).
. Любое оспариваемое изменение должно быть отменено до разрешения спора, если этого потребует сопровождающий. Изменения, связанные с безопасностью, могут перекрыть пожелания сопровождающего по усмотрению Ответственного за безопасность.
. Изменения попадают в FreeBSD-CURRENT до FreeBSD-STABLE, если только это явно не разрешено инженером выпуска или если они не применимы к FreeBSD-CURRENT. Любое нетривиальное или не срочное изменение, которое применимо, также должно оставаться в FreeBSD-CURRENT как минимум 3 дня перед слиянием, чтобы его можно было достаточно протестировать. Инженер выпуска имеет те же полномочия в отношении ветки FreeBSD-STABLE, что и сопровождающий, согласно правилу №5.
. Не устраивайте публичные разборки с другими разработчиками; это выглядит плохо.
. Соблюдайте все периоды заморозки кода и своевременно читайте рассылки `committers` и `developers`, чтобы знать, когда действует заморозка кода.
. Если сомневаетесь в каком-либо действии — сначала спросите!
. Проверьте свои изменения перед их применением.
. Не вносите изменения в предоставленное программное обеспечение без _явного_ одобрения соответствующих сопровождающих.

Как уже отмечалось, нарушение некоторых из этих правил может стать основанием для временного лишения прав на коммиты или, при повторных нарушениях, для их постоянного отзыва. Отдельные члены Основной Команды (Core Team) имеют право временно приостановить права на коммиты до тех пор, пока основная команда в полном составе не рассмотрит вопрос. В случае «чрезвычайной ситуации» (например, если коммиттер наносит ущерб репозиторию), временное лишение прав может также быть осуществлено хранителями репозитория. Только Основная Команда 2/3 большинства голосов имеет право приостановить права на коммиты сроком более чем на неделю или отозвать их полностью. Это правило существует не для того, чтобы сделать основную команду сборищем жестоких диктаторов, которые могут избавляться от коммиттеров так же легко, как от пустых банок из-под газировки, а чтобы дать проекту своего рода предохранительный клапан. Если кто-то выходит из-под контроля, важно иметь возможность немедленно принять меры, а не быть парализованными дискуссией. Во всех случаях коммиттер, чьи права приостановлены или отозваны, имеет право на «слушание» в основной команде, где определяется общая продолжительность приостановки. Коммиттер, чьи права приостановлены, также может запросить пересмотр решения через 30 дней и каждые 30 дней после этого (если общий срок приостановки не менее 30 дней). Коммиттер, чьи права были полностью отозваны, может запросить пересмотр по истечении 6 месяцев. Эта политика пересмотра _строго неформальна_, и во всех случаях основная команда оставляет за собой право как удовлетворить, так и проигнорировать запрос на пересмотр, если считает первоначальное решение правильным.

Во всех остальных аспектах работы проекта основная команда является подмножеством коммиттеров и связана __теми же правилами__. Тот факт, что кто-то входит в основную команду, не означает, что им позволено выходить за рамки обозначенных здесь границ; «особые полномочия» основной команды активируются только при действиях в качестве группы, а не индивидуально. Как отдельные лица, члены основной команды — это прежде всего коммиттеры, и только во вторую очередь — основная команда.

=== Подробности

[[respect]]
. Уважайте других коммиттеров.
+
Это означает, что вы должны относиться к другим коммиттерам как к коллегам-разработчикам, каковыми они и являются. Несмотря на наши периодические попытки доказать обратное, коммиттером не становятся по глупости, и ничто не раздражает больше, чем когда коллеги относятся к вам именно так. Независимо от того, испытываем ли мы всегда уважение друг к другу или нет (у всех бывают плохие дни), мы должны _относиться_ к другим коммиттерам с уважением всегда — как на публичных форумах, так и в личной переписке.
+
Способность долгосрочного сотрудничества — это самое ценное достояние проекта, гораздо более важное, чем любые изменения в коде, и превращение споров о коде в проблемы, влияющие на нашу способность гармонично работать вместе, ни при каких обстоятельствах не стоит того.
+
Для соблюдения этого правила не отправляйте электронные письма, когда вы злитесь или ведёте себя таким образом, который может показаться другим излишне конфронтационным. Сначала успокойтесь, затем подумайте, как наиболее эффективно донести свою точку зрения, чтобы убедить других в своей правоте, а не просто выпустить пар для кратковременного облегчения за счёт долгосрочного конфликта. Иначе это обернётся не только крайне нерациональной тратой сил, но и тем, что повторяющиеся проявления публичной агрессии, мешающие нашей совместной работе, будут строго пресекаться руководством проекта и могут привести к приостановке или лишению ваших прав на коммит. Руководство проекта будет учитывать как публичные, так и приватные сообщения, представленные на его рассмотрение. Оно не будет требовать раскрытия приватной переписки, но примет её во внимание, если участники, вовлечённые в жалобу, предоставят её добровольно.
+
Всё это никогда не является вариантом, который руководство проекта хоть сколько-нибудь радует, но единство важнее. Никакое количество кода или полезных советов не стоит того, чтобы этим пожертвовать.
. Уважайте других участников.
+
Вы не всегда были коммиттером. Когда-то вы были контрибьютором. Помните об этом всегда. Вспомните, каково это — пытаться получить помощь и внимание. Не забывайте, что ваша работа в качестве контрибьютора была для вас очень важна. Вспомните, каково это. Не отговаривайте, не принижайте и не унижайте контрибьюторов. Относитесь к ним с уважением. Они — наши будущие коммиттеры. Они так же важны для проекта, как и коммиттеры. Их вклад так же важен и значим, как и ваш. В конце концов, вы сами сделали множество вкладов, прежде чем стали коммиттером. Всегда помните об этом.
+
Учитывайте моменты, поднятые в разделе crossref:committers-guide[respect,Уважайте других коммиттеров], и применяйте их также к контрибьюторам.
. Обсудите любые значительные изменения _перед_ коммитом.
+
Репозиторий — это не место, где изменения первоначально отправляются на проверку корректности или обсуждаются, сначала это происходит в почтовых рассылках или с помощью сервиса Phabricator. Коммит произойдет только после того, как будет достигнуто некое подобие консенсуса. Это не означает, что требуется разрешение для исправления каждой очевидной синтаксической ошибки или опечатки на странице руководства, просто полезно развить чутьё, когда предлагаемое изменение не столь очевидно и требует предварительного обсуждения. Люди действительно не против масштабных изменений, если результат явно лучше того, что было раньше, им просто не нравится, когда эти изменения становятся _неожиданностью_. Самый лучший способ убедиться, что всё идёт по правильному пути, — это провести рецензирование кода одним или несколькими другими коммиттерами.
+
Если сомневаетесь, запросите рецензию!
. Уважайте существующих сопровождающих, если они указаны.
+
Многие части FreeBSD не "являются чьей-то собственностью" в том смысле, что конкретный человек вскочит и начнёт кричать, если вы внесёте изменения в "его" область, но всё же лучше сначала проверить. Одно из используемых соглашений — добавление строки `maintainer` в [.filename]#Makefile# для любого пакета или поддерева, за которые активно отвечает один или несколько людей; см. extref:{developers-handbook}policies[Рекомендации и политики дерева исходного кода, policies] для документации по этому поводу. Если у участков кода есть несколько сопровождающих, изменения в затронутых областях, внесённые одним сопровождающим, должны быть проверены хотя бы одним другим сопровождающим. В случаях, когда "сопровождение" чего-либо неясно, посмотрите логи репозитория для соответствующих файлов и проверьте, работал ли кто-то недавно или преимущественно в этой области.
. Любое оспариваемое изменение должно быть отменено до разрешения спора, если этого потребует сопровождающий. Изменения, связанные с безопасностью, могут перекрыть пожелания сопровождающего по усмотрению Ответственного за безопасность.
+
Это может быть трудно принять во время конфликтов (когда каждая сторона убеждена, что она права, конечно), но система контроля версий делает ненужным продолжение споров, когда гораздо проще просто отменить спорное изменение, успокоить всех и затем попытаться выяснить, как лучше поступить. Если окажется, что изменение всё-таки было правильным, его можно легко вернуть. Если же нет, то пользователям не придётся мириться с ошибочным изменением в дереве, пока все активно обсуждают его достоинства. Люди _очень_ редко требуют отмены изменений в репозитории, поскольку обсуждение обычно выявляет плохие или спорные изменения ещё до коммита, но в таких редких случаях отмена должна производиться без споров, чтобы можно было сразу перейти к выяснению, было ли изменение ошибочным или нет.
. Изменения вносятся в FreeBSD-CURRENT до FreeBSD-STABLE, если это не разрешено специально инженером выпуска или если они не применимы к FreeBSD-CURRENT. Любое нетривиальное или несрочное изменение, которое применимо, также должно оставаться в FreeBSD-CURRENT как минимум 3 дня перед слиянием, чтобы его можно было достаточно протестировать. Инженер выпуска имеет те же полномочия в отношении ветки FreeBSD-STABLE, как указано в правиле №5.
+
Это ещё один вопрос, о котором не стоит спорить, поскольку инженер выпуска несёт окончательную ответственность (и получает по шапке), если изменение окажется неудачным. Пожалуйста, уважайте это и оказывайте инженеру выпуска полное сотрудничество, когда дело касается ветки FreeBSD-STABLE. Управление FreeBSD-STABLE может часто казаться излишне консервативным для случайного наблюдателя, но также стоит помнить, что консерватизм — это отличительная черта FreeBSD-STABLE, и там действуют другие правила, чем в FreeBSD-CURRENT. Также нет смысла в том, чтобы FreeBSD-CURRENT был испытательным полигоном, если изменения немедленно переносятся в FreeBSD-STABLE. Изменения должны быть протестированы разработчиками FreeBSD-CURRENT, поэтому дайте некоторое время перед слиянием, если только исправление в FreeBSD-STABLE не является критическим, срочным или настолько очевидным, что дальнейшее тестирование не требуется (исправления опечаток в руководствах, очевидные исправления ошибок/опечаток и т.д.). Другими словами, руководствуйтесь здравым смыслом.
+
Изменения в ветках безопасности (например, `releng/9.3`) должны быть одобрены членом группы — `{security-officer}` или, в некоторых случаях, членом группы — `{re}`.
. Не устраивайте публичные разборки с другими разработчиками; это выглядит плохо.
+
Этот проект поддерживает публичный имидж, который очень важен для всех нас, особенно если мы хотим продолжать привлекать новых участников. Бывают случаи, когда, несмотря на все усилия сохранять самообладание, люди теряют терпение и обмениваются резкими словами. Лучшее, что можно сделать в таких ситуациях, — минимизировать последствия, пока все не остынут. Не выносите гневные слова на публику и не пересылайте личную переписку или другие частные сообщения в публичные списки рассылки, почтовые алиасы, каналы мгновенных сообщений или социальные сети. То, что люди говорят один на один, часто менее приукрашено, чем их публичные высказывания, и такие сообщения не имеют места в публичном пространстве — они только усугубляют и без того сложную ситуацию. Если человек, отправляющий гневное сообщение, хотя бы проявил такт и отправил его лично, проявите такт и вы — оставьте это в тайне. Если вы чувствуете, что другой разработчик относится к вам несправедливо, и это причиняет вам страдания, обратитесь к Основной команде (Core team), а не выносите это на публику. Основная команда постарается выступить в роли миротворцев и вернуть ситуацию в разумное русло. Если спор касается изменений в кодовой базе и участники не могут прийти к согласию, основная команда может назначить третью сторону, устраивающую всех, для разрешения спора. Все вовлечённые стороны должны согласиться с решением, принятым этой третьей стороной.
. Соблюдайте все периоды заморозки кода и своевременно читайте рассылки `committers` и `developers`, чтобы знать, когда действует заморозка кода.
+
Внесение неподтверждённых изменений во время заморозки кода — это серьёзная ошибка, и от коммиттеров ожидается, что они будут в курсе происходящего, прежде чем, вернувшись после долгого отсутствия, закоммитить 10 мегабайт накопленных изменений. Те, кто злоупотребляет этим на регулярной основе, будут лишены прав на коммиты до возвращения из Лагеря весёлого перевоспитания FreeBSD, который мы проводим в Гренландии.
. Если сомневаетесь в каком-либо действии — сначала спросите!
+
Многие ошибки совершаются из-за того, что кто-то торопится и просто предполагает, что знает правильный способ что-то сделать. Если вы не делали этого раньше, велика вероятность, что вы на самом деле не знаете, как у нас принято делать, и вам действительно нужно сначала спросить, иначе вы рискуете полностью опозориться на публике. Нет ничего постыдного в вопросе «как, черт возьми, это сделать?» Мы уже знаем, что вы умный человек; иначе вы не были бы коммиттером.
. Проверьте свои изменения перед их применением.
+
Если ваши изменения касаются ядра, убедитесь, что вы по-прежнему можете компилировать как GENERIC, так и LINT. Если ваши изменения касаются других частей системы, убедитесь, что вы по-прежнему можете компилировать пользовательское пространство с помощью `make buildworld`. Если ваши изменения относятся к ветке, убедитесь, что тестирование проводится на машине, которая работает с этим кодом. Если ваше изменение может нарушить работу другой архитектуры, обязательно протестируйте его на всех поддерживаемых архитектурах. Пожалуйста, убедитесь, что ваше изменение работает для crossref:committers-guide[compilers,поддерживаемых инструментов сборки]. Пожалуйста, обратитесь к https://www.FreeBSD.org/internal/[Внутренней странице FreeBSD] для получения списка доступных ресурсов. По мере добавления других архитектур в список поддерживаемых платформ FreeBSD будут предоставлены соответствующие общие ресурсы для тестирования.
. Не вносите изменения в предоставленное программное обеспечение без _явного_ одобрения соответствующих сопровождающих.
+
Предоставленное программное обеспечение — это всё, что находится в деревьях каталогов [.filename]#src/contrib#, [.filename]#src/crypto# или [.filename]#src/sys/contrib#.
+
Упомянутые выше деревья предназначены для предоставленного программного обеспечения, обычно импортируемого в ветку вендора. Фиксация изменений там может вызвать ненужные проблемы при импорте более новых версий программного обеспечения. В общем случае рекомендуется отправлять исправления напрямую вендору. Исправления могут быть сначала зафиксированы в FreeBSD с разрешения сопровождающего.
+
Причины изменения стороннего программного обеспечения варьируются от желания строго контролировать тесно связанную зависимость до отсутствия переносимости в каноническом репозитории с их кодом. Независимо от причины, усилия по минимизации нагрузки на поддержку форка полезны для других сопровождающих. Избегайте внесения тривиальных или косметических изменений в файлы, так как это усложняет каждое последующее слияние: такие патчи необходимо вручную перепроверять при каждом импорте.
+
Если конкретное программное обеспечение не имеет сопровождающего, вам предлагается взять на себя ответственность за него. Если вы не уверены в текущем сопровождении, напишите на {freebsd-arch} и уточните.

=== Политика поддержки нескольких архитектур

В попытке упростить поддержку переносимости FreeBSD на платформы, которые мы поддерживаем, ядро системы разработало следующее предписание:

[.blockquote]
Основные проектные работы (включая значительные изменения API и ABI) должны подтвердить свою работоспособность как минимум на одной платформе Уровня 1 перед тем, как они могут быть включены в дерево исходного кода.

Разработчики также должны учитывать нашу политику уровней поддержки аппаратных архитектур в долгосрочной перспективе. Эти правила предназначены для предоставления рекомендаций в процессе разработки и отличаются от требований к функциям и архитектурам, указанным в этом разделе. Правила уровней поддержки функций для архитектур на момент выпуска более строгие, чем правила для изменений в процессе разработки.

[[compilers]]
=== Политика по использованию нескольких компиляторов

Базовая система FreeBSD собирается как с Clang, так и с GCC. Проект делает это тщательно и контролируемо, чтобы максимизировать преимущества от этой дополнительной работы, сводя эту работу к минимуму. Поддержка обоих компиляторов повышает гибкость для наших пользователей. У этих компиляторов разные сильные и слабые стороны, и их совместная поддержка позволяет пользователям выбирать наиболее подходящий для их задач. Clang и GCC поддерживают схожие диалекты C и C++, что требует относительно небольшого количества условного кода. Проект получает улучшенное покрытие кода и повышает его качество, используя возможности обоих компиляторов. Поддержка этого диапазона позволяет проекту собираться в большем количестве пользовательских окружений и задействовать больше CI-окружений, увеличивая удобство для пользователей и предоставляя им больше инструментов для тестирования. Тщательно ограничивая диапазон поддерживаемых версий современными версиями этих компиляторов, проект избегает чрезмерного увеличения матрицы тестирования. Устаревшие и малоизвестные компиляторы, а также старые диалекты языков, имеют крайне ограниченную поддержку, позволяющую собирать пользовательские программы, но без ограничений на сборку базовой системы с их помощью. Точный баланс продолжает развиваться, чтобы гарантировать, что преимущества дополнительной работы остаются выше накладываемых ею затрат. Раньше проект поддерживал очень старые компиляторы Intel или старые версии GCC, но мы заменили поддержку этих устаревших компиляторов на тщательно выбранный диапазон современных компиляторов. В этом разделе описано, где мы используем разные компиляторы и какие ожидания с этим связаны.

Базовая система FreeBSD включает в себя компилятор Clang, входящий в дерево исходного кода. Поскольку он является частью дерева, этот компилятор обладает наибольшей поддержкой. Все изменения должны компилироваться с ним перед коммитом. Полное тестирование, соответствующее изменениям, должно проводиться с этим компилятором.

Базовая система FreeBSD также поддерживает различные версии Clang и GCC в качестве компиляторов, не входящих в дерево исходного кода. Для крупных или рискованных изменений коммиттеры должны выполнить тестовую сборку с поддерживаемой версией GCC. Компиляторы, не входящие в дерево исходного кода, доступны в виде пакетов. Компиляторы GCC доступны в виде пакетов `${TARGET_ARCH}-gcc${VERSION}`, например package:devel/freebsd-gcc14@aarch64[aarch64-gcc14]. Компиляторы Clang доступны в виде пакетов `llvm${VERSION}`, например package:devel/llvm18[llvm18]. Проект запускает автоматизированные задачи CI для сборки всего с использованием этих компиляторов. Ожидается, что коммиттеры исправят задачи, которые они сломали своими изменениями. Коммиттеры могут тестировать сборки пользовательского пространства или отдельных ядер, установив переменную `CROSS_TOOLCHAIN` в имя пакета, например `CROSS_TOOLCHAIN=aarch64-gcc14` или `CROSS_TOOLCHAIN=llvm18`. Для сборки universe или tinderbox, `USE_GCC_TOOLCHAINS=gcc${VERSION}` собирает все архитектуры с использованием соответствующих пакетов компиляторов GCC. Для сборки universe или tinderbox с использованием Clang, не входящего в дерево исходного кода, передайте `CROSS_TOOLCHAIN=llvm${VERSION}`. Обратите внимание, что хотя все архитектуры в базовой системе могут быть скомпилированы с помощью Clang, только несколько архитектур могут быть полностью собраны с помощью GCC.

Проект FreeBSD также имеет несколько CI-пайплайнов на GitHub. Для запросов на принятие изменений (pull request) на GitHub и некоторых веток, отправленных в форки на GitHub, выполняется ряд задач кросс-компиляции. Они тестируют сборку FreeBSD с использованием версий Clang, которые отстают от встроенного компилятора на одну или несколько основных версий.

Проект FreeBSD также обновляет компиляторы. И Clang, и GCC быстро развиваются. Некоторые изменения, такие как удаление устаревших объявлений и определений функций в стиле K&R, будут внесены в дерево до появления нового компилятора. Коммиттерам следует учитывать это и быть готовыми к проверке проблем в своём коде или изменениях с этими новыми компиляторами. Кроме того, сразу после появления новой версии компилятора в дереве, может потребоваться компиляция с использованием старой версии, если есть подозрение на необнаруженную регрессию.

В дополнение к компилятору, LLD от LLVM и binutils от GNU используются компилятором косвенно. Коммиттеры должны учитывать различия в синтаксисе ассемблера и особенностях компоновщиков, а также обеспечивать работоспособность обоих вариантов. Эти компоненты будут тестироваться в рамках CI-задач FreeBSD для Clang или GCC.

Проект FreeBSD предоставляет заголовочные файлы и библиотеки, которые позволяют использовать другие компиляторы для сборки программного обеспечения, не входящего в базовую систему. Эти заголовочные файлы поддерживают создание среды, соответствующей стандартам, включая более ранние диалекты ANSI-C, начиная с C89, а также другие специфичные случаи, выявленные нашей обширной коллекцией портов. Эта поддержка ограничивает отказ от старых стандартов в таких местах, как заголовочные файлы, но не мешает обновлению базовой системы до более новых диалектов. Также она не требует, чтобы базовая система целиком компилировалась с использованием этих старых стандартов. Нарушение этой поддержки приведёт к сбоям в сборке пакетов из коллекции портов, поэтому по возможности этого следует избегать, а при обнаружении проблем — оперативно их исправлять.

Система сборки FreeBSD в настоящее время поддерживает эти различные среды. По мере добавления новых предупреждений в компиляторы проект старается их исправлять. Однако иногда эти предупреждения требуют значительной переработки, поэтому они подавляются каким-либо образом с использованием переменных make, которые вычисляют правильное значение в зависимости от версии компилятора. Разработчики должны учитывать это и обеспечивать правильную условную обработку любых флагов, специфичных для компилятора.

==== Текущие версии компиляторов
Версии поддерживаемых компиляторов для конкретной ветки, такой как `main` или `stable/X`, со временем меняются. Авторитетным источником информации о поддерживаемых версиях компиляторов являются автоматизированные задачи CI, тестируемые в кросс-сборках GitHub Actions и Jenkins.

Для ветки `main` встроенным компилятором в настоящее время является Clang 19. В настоящее время GCC 12, 13 и 14 тестируются для amd64 через задания CI в Jenkins. Clang 14 и 18 тестируются для aarch64 и arm64 в кросс-сборках GitHub.

=== Другие предложения

При внесении изменений в документацию перед коммитом проверяйте орфографию. Для всех XML-документов убедитесь в корректности директив форматирования, выполнив `make lint` и package:textproc/igor[].

Для страниц руководства запустите package:sysutils/manck[] и package:textproc/igor[] на странице руководства, чтобы проверить, что все перекрестные ссылки и ссылки на файлы корректны, а также что страница руководства имеет все необходимые `MLINKS`.

Не смешивайте исправления стиля с новой функциональностью. Исправление стиля — это любое изменение, которое не меняет функциональность кода. Смешивание изменений затрудняет понимание изменений функциональности при запросе различий между версиями, что может скрыть новые ошибки. Не включайте изменения пробелов вместе с изменениями содержимого в коммитах для [.filename]#doc/#. Лишний шум в различиях значительно усложняет работу переводчиков. Вместо этого вносите исправления стиля или пробелов в отдельных коммитах, явно обозначенных как таковые в сообщении коммита.

=== Устаревающие функции

Когда необходимо удалить функциональность из программного обеспечения в базовой системе, по возможности следуйте этим рекомендациям:

. Упоминание о том, что опция, утилита или интерфейс устарели, содержится в руководстве и, возможно, в примечаниях к выпуску. Использование устаревшей функции вызывает предупреждение.
. Опция, утилита или интерфейс сохраняются до следующего мажорного (точка-ноль) релиза.
. Опция, утилита или интерфейс удалены и больше не документируются. Они считаются устаревшими. Также обычно рекомендуется указать их удаление в примечаниях к выпуску.

=== Конфиденциальность и приватность

. Большая часть работы над FreeBSD выполняется публично.
+
FreeBSD — это _открытый_ проект. Это означает, что не только любой может использовать исходный код, но и большая часть процесса разработки открыта для публичного изучения.
. Некоторые конфиденциальные вопросы должны оставаться в тайне или быть под запретом на разглашение.
+
К сожалению, полной прозрачности быть не может. Как разработчик FreeBSD, вы будете иметь определенную степень привилегированного доступа к информации. Следовательно, от вас ожидается соблюдение определенных требований конфиденциальности. Иногда необходимость конфиденциальности исходит от внешних сотрудников или имеет конкретный временной лимит. Однако в большинстве случаев это вопрос неразглашения частных переписок.
. Ответственный за безопасность обладает исключительным правом публикации уведомлений о безопасности.
+
Где есть проблемы безопасности, затрагивающие множество различных операционных систем, FreeBSD часто зависит от раннего доступа, чтобы иметь возможность подготовить уведомления для согласованного выпуска. Если разработчики FreeBSD не могут быть доверены в вопросах поддержания безопасности, такой ранний доступ предоставлен не будет. Ответственный за безопасность контролирует доступ к информации об уязвимостях до их публикации и определяет время выпуска всех уведомлений. Он может запросить помощь при условии конфиденциальности у любого разработчика с соответствующими знаниями для подготовки исправлений безопасности.
. Коммуникации с Основной командой (Core Team) сохраняются в конфиденциальности столько времени, сколько необходимо.
+
Коммуникации с Основной командой изначально будут рассматриваться как конфиденциальные. Однако в конечном итоге большая часть деятельности Основной команды будет обобщена в ежемесячных или квартальных отчетах ядра. Будет уделено внимание тому, чтобы избежать разглашения каких-либо чувствительных деталей. Записи по некоторым особо чувствительным темам могут вообще не попадать в отчеты и будут храниться только в частных архивах Основной команды.
. Соглашения о неразглашении могут потребоваться для доступа к определенной коммерчески чувствительной информации.
+
Доступ к определенным коммерчески чувствительным данным может быть предоставлен только при подписании Соглашения о неразглашении. Перед заключением каких-либо юридически обязывающих соглашений необходимо проконсультироваться с юридическим отделом Фонда FreeBSD.
. Приватные сообщения не должны становиться публичными без разрешения.
+
Помимо указанных выше конкретных требований, существует общее правило не публиковать личную переписку между разработчиками без согласия всех вовлеченных сторон. Перед пересылкой сообщения в публичную рассылку, размещением на форуме или веб-сайте, доступном не только для исходных корреспондентов, необходимо запросить разрешение.
. Общение в каналах, предназначенных только для проекта или с ограниченным доступом, должно оставаться конфиденциальным.
+
Аналогично личным сообщениям, некоторые внутренние каналы связи, включая почтовые рассылки только для коммиттеров FreeBSD и IRC-каналы с ограниченным доступом, считаются частной перепиской. Для публикации материалов из этих источников требуется разрешение.
. Основная команда может одобрить публикацию.
+
В случаях, когда получение разрешения непрактично из-за количества корреспондентов или когда разрешение на публикацию необоснованно отклоняется, Основная команда может одобрить раскрытие таких частных вопросов, которые заслуживают более широкой публикации.

[[archs]]
== Поддержка множественных архитектур

FreeBSD — это высокопортативная операционная система, предназначенная для работы на множестве различных типов аппаратных архитектур. Поддержание четкого разделения между машинно-зависимым (MD) и машинно-независимым (MI) кодом, а также минимизация MD-кода являются важной частью нашей стратегии по сохранению гибкости в отношении текущих тенденций в аппаратном обеспечении. Каждая новая аппаратная архитектура, поддерживаемая FreeBSD, существенно увеличивает затраты на поддержку кода, инструментальных средств и инжиниринг выпусков. Это также значительно повышает стоимость эффективного тестирования изменений в ядре. Таким образом, существует серьезная мотивация для разграничения уровней поддержки различных архитектур, оставаясь при этом сильными в нескольких ключевых архитектурах, которые рассматриваются как «целевая аудитория» FreeBSD.

=== Заявление об общих намерениях

Проект FreeBSD ориентирован на "коммерческие готовые рабочие станции, серверы и высокопроизводительные встраиваемые системы производственного уровня". Сохраняя фокус на узком наборе архитектур, актуальных для этих сред, проект FreeBSD способен поддерживать высокий уровень качества, стабильности и производительности, а также минимизировать нагрузку на различные команды поддержки проекта, такие как команда портов, команда документации, офицер безопасности и команды разработки релизов. Разнообразие в поддержке оборудования расширяет возможности потребителей FreeBSD, предлагая новые функции и варианты использования, однако эти преимущества всегда должны тщательно оцениваться с учётом реальных затрат на поддержку дополнительных платформ.

Проект FreeBSD разделяет целевые платформы на четыре уровня. Каждый уровень включает список гарантий, на которые могут рассчитывать пользователи, а также обязательства проекта и разработчиков по выполнению этих гарантий. Эти списки определяют минимальные гарантии для каждого уровня. Проект и разработчики могут предоставлять дополнительные уровни поддержки, превышающие минимальные гарантии для данного уровня, но такая дополнительная поддержка не гарантируется. Каждая целевая платформа назначается на определённый уровень для каждой стабильной ветви. В результате, целевая платформа может быть назначена на разные уровни в параллельных стабильных ветках.

=== Целевые платформы

Поддержка аппаратной платформы состоит из двух компонентов: поддержки ядра и пользовательских двоичных интерфейсов приложений (ABI). Поддержка платформы на уровне ядра включает в себя всё необходимое для запуска ядра FreeBSD на аппаратной платформе, например, зависящее от машины управление виртуальной памятью и драйверы устройств. Пользовательский ABI определяет интерфейс для взаимодействия пользовательских процессов с ядром FreeBSD и базовыми системными библиотеками. Пользовательский ABI включает интерфейсы системных вызовов, расположение и семантику публичных структур данных, а также расположение и семантику аргументов, передаваемых подпрограммам. Некоторые компоненты ABI могут быть определены спецификациями, такими как расположение объектов исключений C++ или соглашения о вызовах для функций C.

Ядро FreeBSD также использует ABI (иногда называемый Kernel Binary Interface (KBI)), который включает семантику и расположение публичных структур данных, а также расположение и семантику аргументов публичных функций внутри самого ядра.

Ядро FreeBSD может поддерживать несколько пользовательских ABI. Например, ядро FreeBSD amd64 поддерживает пользовательские ABI FreeBSD amd64 и i386, а также пользовательские ABI Linux x86_64 и i386. Ядро FreeBSD должно поддерживать "родной" ABI в качестве ABI по умолчанию. "Родной" ABI, как правило, разделяет определённые свойства с ABI ядра, такие как соглашение о вызовах в C, размеры базовых типов и т.д.

Уровни определены как для ядер, так и для пользовательских ABI. В общем случае ядро платформы и ABI FreeBSD назначаются на один и тот же уровень.

==== Уровень 1: Полностью поддерживаемые архитектуры

Уровень 1 включает наиболее зрелые платформы FreeBSD. Они поддерживаются офицером безопасности, инженерами выпуска и командой управления портами. Ожидается, что архитектуры Уровня 1 соответствуют производственному качеству во всех аспектах операционной системы FreeBSD, включая среды установки и разработки.

Проект FreeBSD предоставляет следующие гарантии пользователям платформ Уровня 1:

* Официальные образы релизов FreeBSD будут предоставлены командой разработки релизов.
* Двоичные обновления и исправления исходного кода для Security Advisories и Errata Notices будут предоставляться для поддерживаемых выпусков.
* Исходные патчи для бюллетеней безопасности будут предоставлены для поддерживаемых веток.
* Двоичные обновления и исправления исходного кода для кросс-платформенных выпусков Security Advisories обычно предоставляются во время объявления.
* Изменения в пользовательских ABI, как правило, включают прослойки совместимости (shim) для обеспечения корректной работы бинарных файлов, скомпилированных для любой стабильной ветки, где платформа относится к Уровню 1. Эти прослойки могут быть отключены в стандартной установке. Если прослойки совместимости не предоставляются для изменения ABI, их отсутствие будет явно указано в примечаниях к выпуску.
* Изменения в определённых частях ABI ядра будут включать прослойки совместимости для обеспечения корректной работы модулей ядра, скомпилированных для самой старой поддерживаемой версии в ветке. Обратите внимание, что не все части ABI ядра защищены.
* Официальные бинарные пакеты для стороннего программного обеспечения будут предоставлены командой портов. Для встраиваемых архитектур эти пакеты могут быть кросс-собранными на архитектуре другого типа.
* Наиболее подходящие порты должны либо собираться, либо иметь соответствующие фильтры, чтобы предотвратить сборку неподходящих.
* Новые функции, которые не являются специфичными для платформы, будут полностью работоспособны на всех архитектурах Уровня 1.
* Функции и прослойки совместимости, используемые программами, скомпилированными для старых стабильных веток, могут быть удалены в новых основных версиях. Такие изменения будут четко документированы в примечаниях к выпуску.
* Уровень 1 платформ должен быть полностью документирован. Основные операции будут описаны в Руководстве FreeBSD.
* Уровень 1 платформ будет включен в дерево исходных кодов.
* Платформы Уровня 1 должны быть самодостаточными, используя либо встроенный инструментарий, либо внешний инструментарий. Если требуется внешний инструментарий, будут предоставлены официальные бинарные пакеты для него.

Для обеспечения зрелости платформ Уровня 1 проект FreeBSD будет поддерживать следующие ресурсы для разработки:

* Сборка и автоматизация тестирования поддерживаются либо в кластере FreeBSD.org, либо в другом месте, легко доступном для всех разработчиков. Для встраиваемых платформ можно использовать эмулятор, доступный в кластере FreeBSD.org, вместо реального оборудования.
* Включение в цели `make universe` и `make tinderbox`.
* Выделенное оборудование в одном из кластеров FreeBSD для сборки пакетов (нативно или через qemu-user).

Совокупно, разработчики должны обеспечить следующее для поддержания статуса платформы Уровня 1:

* Изменения в дереве исходного кода не должны заведомо нарушать сборку платформы Уровня 1.
* Уровень 1 архитектур должен обладать зрелой, здоровой экосистемой пользователей и активных разработчиков.
* Разработчики должны иметь возможность собирать пакеты на широко доступных, невстраиваемых системах Уровня 1. Это может означать как нативные сборки, если невстраиваемые системы широко доступны для рассматриваемой платформы, так и кросс-сборки, выполняемые на другой архитектуре Уровня 1.
* Изменения не должны нарушать ABI пользовательского пространства. Если изменение ABI необходимо, совместимость ABI для существующих бинарных файлов должна обеспечиваться с помощью версионирования символов или увеличения версий разделяемых библиотек.
* Изменения, которым сделано слияние в стабильные ветки, не должны нарушать защищенные части ABI ядра. Если требуется изменение ABI ядра, изменение должно быть модифицировано для сохранения функциональности существующих модулей ядра.

==== Уровень 2: Развивающиеся и нишевые архитектуры

Уровень 2 включает в себя функциональные, но менее развитые платформы FreeBSD. Они не поддерживаются офицером безопасности, инженерами выпуска и командой управления портами.

Платформы Уровня 2 могут быть кандидатами в платформы Уровня 1, которые всё ещё находятся в активной разработке. Архитектуры, достигшие конца жизненного цикла, также могут быть переведены из статуса Уровня 1 на Уровень 2 по мере сокращения доступности ресурсов для поддержания системы в состоянии производственного качества. Хорошо поддерживаемые нишевые архитектуры также могут относиться к Уровню 2.

Проект FreeBSD предоставляет следующие гарантии пользователям платформ Уровня 2:

* Инфраструктура портов должна включать базовую поддержку архитектур Уровня 2, достаточную для сборки портов и пакетов. Это включает поддержку базовых пакетов, таких как ports-mgmt/pkg, но нет гарантии, что произвольные порты будут собираемыми или работоспособными.
* Новые функции, которые не являются специфичными для платформы, должны быть реализуемы на всех архитектурах уровня Уровень 2, если они не реализованы.
* Уровень 2 платформ будет включен в дерево исходных кодов.
* Платформы Уровня 2 должны быть самодостаточными, используя либо встроенный инструментарий, либо внешний инструментарий. Если требуется внешний инструментарий, будут предоставлены официальные бинарные пакеты для него.
* Уровень 2 платформ должен обеспечивать функциональные ядра и пользовательские среды, даже если официальный дистрибутив не предоставляется.

Для поддержания зрелости платформ Уровня 2 проект FreeBSD будет поддерживать следующие ресурсы для разработки:

* Включение в цели `make universe` и `make tinderbox`.

Совместно разработчики должны обеспечить следующее для поддержания статуса платформы Уровня 2:

* Изменения в дереве исходного кода не должны заведомо нарушать сборку платформы Уровня 2.
* Уровень 2 архитектур должен иметь активную экосистему пользователей и разработчиков.
* Хотя изменения, нарушающие ABI пользовательского пространства, допустимы, не следует делать это без веской причины. Значительные изменения ABI пользовательского пространства должны ограничиваться основными версиями.
* Новые функции, которые еще не реализованы в архитектурах Уровня 2, должны предоставлять возможность их отключения на этих архитектурах.

==== Уровень 3: Экспериментальные архитектуры

Уровень 3 включает платформы с частичной поддержкой FreeBSD. Они _не_ поддерживаются офицером безопасности, инженерами выпуска релизов и командой управления портами.

Уровень 3 включает архитектуры на ранних стадиях разработки, предназначенные для неосновных аппаратных платформ или считающиеся устаревшими системами, которые вряд ли получат широкое применение в будущем. Первоначальная поддержка платформ Уровня 3 может находиться в отдельном репозитории, а не в основном репозитории исходного кода.

Проект FreeBSD не предоставляет никаких гарантий пользователям платформ Уровня 3 и не обязуется выделять ресурсы для поддержки разработки. Платформы Уровня 3 могут не всегда собираться, и ни одно ABI ядра или пользовательского пространства не считается стабильным.

==== Неподдерживаемые архитектуры

Другие платформы не поддерживаются проектом в какой-либо форме. Ранее проект описывал их как системы Уровня 4.

После перехода платформы в статус неподдерживаемой, вся поддержка платформы удаляется из исходного кода, портов и документации. Обратите внимание, что поддержка в портах должна сохраняться до тех пор, пока платформа поддерживается в ветке, поддерживаемой портами.

=== Политика изменения уровня архитектуры

Системы могут быть перемещены с одного уровня на другой только с одобрения Основной команды FreeBSD, которая принимает это решение совместно с Security Officer, Release Engineering и командами управления портами. Для перевода платформы на более высокий уровень все недостающие гарантии поддержки должны быть выполнены до завершения повышения.

[[ports]]
== Специфичные FAQ по портам

[[ports-qa-adding]]
=== Добавление нового порта

[[ports-qa-add-new]]
==== Как добавить новый порт?

Добавление порта в дерево относительно просто. Как только порт готов к добавлению, как описано далее crossref:committers-guide[ports-qa-add-new-extra,здесь], необходимо добавить запись каталога порта в [.filename]#Makefile# соответствующей категории. В этом [.filename]#Makefile# порты перечислены в алфавитном порядке и добавлены в переменную `SUBDIR`, например:

[.programlisting]
....
	SUBDIR += newport
....

После того как порт и Makefile его категории готовы, новый порт можно закоммитить:
[source, shell]
....
% git add category/Makefile category/newport
% git commit
% git push
....
[TIP]
====
Не забудьте crossref:committers-guide[port-commit-message-formats,настроить git-хуки для дерева портов, как описано здесь]; специальный хук был разработан для проверки [.filename]#Makefile# каждой категории.
====

[[ports-qa-add-new-extra]]
==== Есть ли что-то еще, что мне нужно знать при добавлении нового порта?

Проверьте порт, желательно убедиться, что он компилируется и собирается в пакеты правильно.

В главе extref:{porters-handbook}testing[Руководства портировщика по тестированию] содержатся более подробные инструкции. См. разделы extref:{porters-handbook}testing[Portclippy / Portfmt, testing-portclippy] и extref:{porters-handbook}testing[poudriere, testing-poudriere].

Вам не обязательно устранять все предупреждения, но убедитесь, что исправили простые.

Если порт поступил от отправителя, который ранее не участвовал в Проекте, добавьте имя этого человека в раздел extref:{contributors}[Дополнительные участники, contrib-additional] списка участников FreeBSD.

Закройте PR, если порт был отправлен как PR. Чтобы закрыть PR, измените состояние на `Issue Resolved` и установите решение как `Fixed`.

[NOTE]
====
Если по какой-то причине использование extref:{porters-handbook}testing[poudriere, testing-poudriere] для тестирования нового порта невозможно, минимальный набор тестирования включает следующую последовательность:

[source, shell]
....
# make install
# make package
# make deinstall
# pkg add package you built above
# make deinstall
# make reinstall
# make package
....

Обратите внимание, что poudriere является эталоном для сборки пакетов. Если порт не собирается в poudriere, он будет удалён.
====

[[ports-qa-removing]]
=== Удаление существующего порта

[[ports-qa-remove-one]]
==== Как удалить существующий порт?

Сначала прочитайте раздел о копиях репозиториев. Перед удалением порта необходимо убедиться, что от него не зависят другие порты.

* Убедитесь, что нет зависимостей от порта в коллекции портов:
** Имя пакета порта (PKGNAME) появляется ровно в одной строке в последнем файле INDEX.
** Ни один другой порт не содержит ссылок на каталог порта или PKGNAME в своих Makefiles
+
[TIP]
====
При использовании Git рассмотрите возможность использования man:git-grep[1], так как он значительно быстрее, чем `grep -r`.
====
+
* Затем удалите порт:
+
[.procedure]
====
* Удалите файлы и каталог порта с помощью `git rm`.
* Удалите указание `SUBDIR` для порта в [.filename]#Makefile# родительского каталога.
* Добавьте запись в [.filename]#ports/MOVED#.
* Удалите порт из [.filename]#ports/LEGAL#, если он там присутствует.
====

Альтернативно, вы можете использовать скрипт rmport из [.filename]#ports/Tools/scripts#. Этот скрипт был написан {vd}. При отправке вопросов об этом скрипте в {freebsd-ports}, пожалуйста, также копируйте {crees}, текущего сопровождающего.

[[ports-qa-move-port]]
=== Как переместить порт в новое место?

[.procedure]
====
. Выполните тщательную проверку коллекции портов на наличие зависимостей от старого расположения или имени порта и обновите их. Запуск `grep` по файлу [.filename]#INDEX# недостаточен, поскольку некоторые порты имеют зависимости, включённые через параметры компиляции. Рекомендуется выполнить полный поиск с помощью man:git-grep[1] по коллекции портов.
. Удалите запись `SUBDIR` из Makefile старой категории и добавьте запись `SUBDIR` в Makefile новой категории.
. Добавьте запись в [.filename]#ports/MOVED#.
. Поищите записи в xml-файлах внутри [.filename]#ports/security/vuxml# и скорректируйте их соответствующим образом. В частности, проверьте предыдущие пакеты с новым именем, версия которых может включать новый порт.
. Переместите порт с помощью `git mv`.
. Зафиксируйте изменения.
====

[[ports-qa-copy-port]]
=== Как скопировать порт в новое место?

[.procedure]
====
. Скопируйте порт с помощью `cp -R old-cat/old-port new-cat/new-port`.
. Добавьте новый порт в файл [.filename]#new-cat/Makefile#.
. Измените содержимое в [.filename]#new-cat/new-port#.
. Зафиксируйте изменения.
====

[[ports-qa-freeze]]
=== Заморозка портов

[[ports-qa-freeze-what]]
==== Что такое «заморозка портов»?

«Заморозка портов» (ports freeze) — это ограниченное состояние, в которое дерево портов переводилось перед выпуском релиза. Оно использовалось для обеспечения более высокого качества пакетов, поставляемых с релизом. Обычно это длилось несколько недель. В течение этого времени исправлялись проблемы со сборкой, а также строились пакеты для релиза. Эта практика больше не применяется, так как пакеты для релизов теперь собираются из текущей стабильной квартальной ветки.

Для получения дополнительной информации о том, как делать слияние коммитов в квартальную ветку, см. crossref:committers-guide[ports-qa-misc-request-mfh, Какова процедура получения разрешения на слияние коммита с квартальной веткой?].

[[ports-qa-quarterly]]
=== Квартальные ветки

[[ports-qa-misc-request-mfh]]
==== Какова процедура получения разрешения на слияние коммита с квартальной веткой?

По состоянию на 30 ноября 2020 года явное одобрение для внесения изменений в квартальную ветку не требуется.

[[ports-qa-misc-commit-mfh]]
==== Какова процедура слияния коммитов в квартальную ветку?

Слияние коммитов в квартальную ветку (процесс, который мы по историческим причинам называем MFH) очень похоже на MFC коммитов в репозитории src, поэтому в основном:
[source, shell]
....
% git checkout 2021Q2
% git cherry-pick -x $HASH
(verify everything is OK, for example by doing a build test)
% git push
....

где `$HASH` — это хэш коммита, который вы хотите скопировать в квартальную ветку. Параметр `-x` гарантирует, что хэш `$HASH` из ветки `main` будет включён в новое сообщение коммита в квартальной ветке.

[[ports-qa-new-category]]
=== Создание новой категории

[[ports-qa-new-category-how]]
==== Какова процедура создания новой категории?

Пожалуйста, ознакомьтесь с extref:{porters-handbook}makefiles/[Предложение новой категории, proposing-categories] в Руководстве портера. После выполнения этой процедуры и назначения PR в группе — {portmgr}, решение об одобрении принимается ими. Если решение положительное, их обязанностью является:

[.procedure]
====
. Выполните все необходимые перемещения. (Это применимо только к физическим категориям.)
. Обновите определение `VALID_CATEGORIES` в файле [.filename]#ports/Mk/bsd.port.mk#.
. Назначить PR обратно на вас.
====

[[ports-qa-new-category-physical]]
==== Что мне нужно сделать для создания новой физической категории?

[.procedure]
====
. Обновите [.filename]#Makefile# каждого перемещенного порта. Пока не подключайте новую категорию к сборке.
+
Для этого вам потребуется:
+
[.procedure]
======
. Измените `CATEGORIES` порта (это была цель упражнения, помните?). Новая категория указана первой. Это поможет убедиться, что PKGORIGIN указан правильно.
. Выполните команду `make describe`. Поскольку команда `make index` верхнего уровня, которую вы запустите через несколько шагов, является итерацией `make describe` для всей иерархии портов, обнаружение ошибок на этом этапе сэкономит время, избавив от необходимости перезапускать этот шаг позже.
. Если вы хотите быть действительно тщательным, сейчас может быть подходящее время запустить man:portlint[1].
======
+
. Проверьте, что значения ``PKGORIGIN`` указаны верно. Система портов использует запись `CATEGORIES` каждого порта для создания его `PKGORIGIN`, который служит для связи установленных пакетов с директорией порта, из которого они были собраны. Если эта запись неверна, такие распространённые инструменты для работы с портами, как man:pkg-version[8] и man:portupgrade[1], не будут работать.
+
Для этого используйте инструмент [.filename]#chkorigin.sh#: `env PORTSDIR=/path/to/ports sh -e /path/to/ports/Tools/scripts/chkorigin.sh`. Это проверит каждый порт в дереве портов, даже те, которые не связаны со сборкой, поэтому вы можете запустить его сразу после операции перемещения. Подсказка: не забудьте проверить ``PKGORIGIN`` для всех подчинённых портов (slave ports) тех портов, которые вы только что переместили!
. На вашей локальной системе протестируйте предлагаемые изменения: сначала закомментируйте записи SUBDIR в файлах [.filename]##Makefile## старых категорий портов; затем включите сборку новой категории в [.filename]#ports/Makefile#. Запустите `make checksubdirs` в затронутых каталогах категорий, чтобы проверить записи SUBDIR. Затем в каталоге [.filename]#ports/# выполните `make index`. Это может занять более 40 минут даже на современных системах; однако это необходимый шаг для предотвращения проблем у других пользователей.
. После этого можно зафиксировать обновлённый файл [.filename]#ports/Makefile#, чтобы подключить новую категорию к сборке, а также сделать коммит изменениям в файле [.filename]#Makefile# для старой категории или категорий.
. Добавьте соответствующие записи в [.filename]#ports/MOVED#.
. Обновите документацию, изменив:
** extref:{porters-handbook}makefiles/[список категорий, porting-categories] в Руководстве портера
+
. Только после того, как все вышеперечисленное будет выполнено и больше никто не сообщает о проблемах с новыми портами, старые порты следует удалить из их прежних мест в репозитории.
====

==== Что мне нужно сделать для создания новой виртуальной категории?

Это намного проще, чем физическая категория. Требуется всего несколько изменений:

* extref:{porters-handbook}makefiles/[список категорий, porting-categories] в Руководстве портера

[[ports-qa-misc-questions]]
=== Разные вопросы

[[ports-qa-misc-blanket-approval]]
==== Существуют ли изменения, которые можно зафиксировать без запроса одобрения у сопровождающего?

Общее одобрение для большинства портов применяется к следующим типам исправлений:

* Большинство изменений инфраструктуры порта (то есть модернизация без изменения функциональности). Например, это включает переход на новые макросы `USES`, включение подробных сборок и переход на новые синтаксисы системы портов.
* Тривиальные и _проверенные_ исправления для сборки и выполнения.
* Документация или изменения метаданных для портов, такие как [.filename]#pkg-descr# или `COMMENT`.

[IMPORTANT]
====
Исключениями являются любые компоненты, поддерживаемые {portmgr} или {security-officer}. Несанкционированные коммиты в порты, которые поддерживаются этими группами, недопустимы.
====

[[ports-qa-misc-correctly-building]]
==== Как узнать, мой порт собирается правильно или нет?

Пакеты собираются несколько раз в неделю. Если сборка порта завершается неудачно, сопровождающий получит письмо от `pkg-fallout@FreeBSD.org`.

Отчеты по всем сборкам пакетов (официальные, экспериментальные и без регрессии) агрегируются на link:pkg-status.FreeBSD.org[pkg-status.FreeBSD.org].

[[ports-qa-misc-INDEX]]
==== Я добавил новый порт. Нужно ли добавлять его в [.filename]#INDEX#?

Нет. Файл может быть создан выполнением команды `make index`, или можно загрузить предварительно сгенерированную версию с помощью `make fetchindex`.

[[ports-qa-misc-no-touch]]
==== Есть ли другие файлы, которые мне нельзя изменять?

Любой файл непосредственно в [.filename]#ports/# или любой файл в подкаталоге, название которого начинается с заглавной буквы ([.filename]#Mk/#, [.filename]#Tools/# и т.д.). В частности, {portmgr} очень ревностно относится к [.filename]#ports/Mk/bsd.port*.mk#, поэтому не вносите изменения в эти файлы, если не хотите навлечь на себя их гнев.

[[ports-qa-misc-updated-distfile]]
==== Как правильно обновить контрольную сумму для distfile порта, если файл изменился без изменения версии?

Когда контрольная сумма файла дистрибутива обновляется из-за того, что автор обновил файл без изменения ревизии порта, сообщение коммита включает сводку соответствующих различий между оригинальным и новым файлом дистрибутива, чтобы убедиться, что файл дистрибутива не был повреждён или злонамеренно изменён. Если текущая версия порта находится в дереве портов уже некоторое время, копия старого файла дистрибутива обычно доступна на FTP-серверах; в противном случае следует связаться с автором или сопровождающим, чтобы выяснить, почему файл дистрибутива изменился.

[[ports-exp-run]]
==== Как можно запросить экспериментальную тестовую сборку дерева портов (exp-run)?

Перед коммитом изменений, оказывающих значительное влияние на порты, необходимо выполнить тестовый прогон (exp-run). Исправление может относиться как к дереву портов, так и к базовой системе.

Полные сборки пакетов будут выполнены с патчами, предоставленными отправителем, и отправитель обязан исправить обнаруженные проблемы _(падения сборки и т.п.)_ перед коммитом.

[.procedure]
====
. Перейдите по ссылке link:https://bugs.freebsd.org/submit[Страница создания новой PR в Bugzilla].
. Выберите продукт, к которому относится ваш патч.
. Заполните отчёт об ошибке как обычно. Не забудьте приложить исправление.
. Если вверху написано «Показать дополнительные поля (Show Advanced Fields)», нажмите на это. Теперь будет написано «Скрыть дополнительные поля (Hide Advanced Fields)». Станут доступны многие новые поля. Если уже написано «Скрыть дополнительные поля», ничего делать не нужно.
. В разделе «Flags» установите флаг «exp-run» в значение `?`. Для всех остальных полей при наведении курсора на любое поле отображаются дополнительные сведения.
. Отправьте. Дождитесь завершения сборки.
. {portmgr} ответит с информацией возможных падениях.
. В зависимости от последствий:
** Если последствий нет, процедура останавливается здесь, и изменение может быть закоммичено, ожидая любых других необходимых утверждений.
... Если возникнут проблемы, их _необходимо_ исправить, либо напрямую в дереве портов, либо добавив изменения в предоставленный патч.
... После этого вернитесь к шагу 6, указав, что проблема устранена, и дождитесь повторного запуска exp-run. Повторяйте, пока остаются неисправные порты.
====

[[non-committers]]
== Проблемы, характерные для разработчиков, не являющихся коммиттерами

Несколько людей, имеющих доступ к машинам FreeBSD, не обладают правами на коммиты. Почти все положения этого документа применимы и к таким разработчикам (за исключением аспектов, специфичных для коммитов и связанного с ними членства в рассылках). В частности, мы рекомендуем ознакомиться со следующим:

* crossref:committers-guide[admin,Административные детали]
* crossref:committers-guide[conventions-everyone, Для всех]
+
[NOTE]
====
Попросите вашего наставника добавить вас в список "Дополнительные участники" ([.filename]#doc/shared/contrib-additional.adoc#), если вас там еще нет.
====
* crossref:committers-guide[developer.relations, Отношения с разработчиками]
* crossref:committers-guide[ssh.guide, Руководство по быстрому началу работы с SSH]
* crossref:committers-guide[rules, Большой список правил коммиттеров FreeBSD]

[[google-analytics]]
== Информация о Google Analytics

По состоянию на 12 декабря 2012 года на сайте проекта FreeBSD был включен Google Analytics для сбора анонимной статистики использования сайта.

[NOTE]
====
По состоянию на 3 марта 2022 года Google Analytics был удалён из проекта FreeBSD.
====

[[misc]]
== Разные вопросы

=== Как получить доступ к people.FreeBSD.org для размещения личной или проектной информации?

`people.FreeBSD.org` — это то же самое, что и `freefall.FreeBSD.org`. Просто создайте каталог [.filename]#public_html#. Всё, что вы поместите в этот каталог, будет автоматически доступно по адресу https://people.FreeBSD.org/[https://people.FreeBSD.org/].

=== Где хранятся архивы списков рассылки?

Списки рассылки архивируются в [.filename]#/local/mail# на `freefall.FreeBSD.org`.

=== Я хочу стать наставником нового коммиттера. Какой процесс мне нужно пройти?

См. документ https://www.freebsd.org/internal/new-account/[Процедура создания новой учётной записи] на внутренних страницах.

[[benefits]]
== Преимущества и привилегии для коммиттеров FreeBSD

[[benefits-recognition]]
=== Признание

Признание в качестве квалифицированного инженера-программиста — это самая долговечная ценность. Кроме того, возможность работать с одними из лучших специалистов, о встрече с которыми мечтает любой инженер, — это отличный бонус!

[[benefits-freebsdmall]]
=== FreeBSD Mall

Коммиттеры FreeBSD могут бесплатно получить набор из 4 CD или DVD на конференциях через http://www.freebsdmall.com[FreeBSD Mall, Inc.].

[[benefits-gandi]]
=== `Gandi.net`

https://gandi.net[Gandi] предоставляет услуги хостинга веб-сайтов, облачных вычислений, регистрации доменов и сертификатов X.509.

Gandi предоставляет скидку E-rate всем разработчикам FreeBSD. Чтобы упростить процесс получения скидки, сначала создайте учетную запись Gandi, заполните платежные данные и выберите валюту. Затем отправьте письмо по адресу mailto:non-profit@gandi.net[non-profit@gandi.net] с вашего адреса `@freebsd.org`, указав ваш идентификатор Gandi.

[[benefits-rsync]]
=== `rsync.net`

https://rsync.net[rsync.net] предоставляет облачное хранилище для резервного копирования вне офиса, оптимизированное для пользователей UNIX. Их сервис полностью работает на FreeBSD и ZFS.

rsync.net предоставляет бесплатный аккаунт на 500 ГБ навсегда разработчикам FreeBSD. Просто зарегистрируйтесь по адресу https://www.rsync.net/freebsd.html[https://www.rsync.net/freebsd.html], используя ваш адрес `@freebsd.org`, чтобы получить этот бесплатный аккаунт.
