---
description: 'Эта глава рассказывает о некоторых способах использования последовательной передачи данных в FreeBSD'
next: books/handbook/ppp-and-slip
params:
  path: /books/handbook/serialcomms/
part: 'Часть IV. Сетевое взаимодействие'
prev: books/handbook/partiv
showBookMenu: true
tags: ["serial", "communications", "terminal", "modem", "console"]
title: 'Глава 29. Последовательная передача данных'
weight: 34
---

[[serialcomms]]
= Последовательная передача данных
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 29
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/serialcomms/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[serial-synopsis]]
== Обзор

UNIX(R) всегда поддерживал последовательную передачу данных, так как самые первые UNIX(R)-машины использовали последовательные линии для ввода и вывода информации. Многое изменилось со времен, когда стандартный терминал состоял из последовательного принтера со скоростью печати 10 символов в секунду и клавиатуры. В этой главе рассматриваются некоторые способы использования последовательной передачи данных в FreeBSD.

Прочитав эту главу, вы будете знать:

* Как подключить терминалы к системе FreeBSD.
* Как использовать модем для дозвона до удалённых хостов.
* Как разрешить удаленным пользователям входить в систему FreeBSD с помощью модема.
* Как загрузить систему FreeBSD с последовательной консоли.

Прежде чем читать эту главу, вы должны:

* Знать, как crossref:kernelconfig[kernelconfig,настроить и установить собственное ядро].
* Понять crossref:basics[basics, права и процессы в FreeBSD].
* Иметь доступ к техническому руководству по последовательному оборудованию, которое будет использоваться с FreeBSD.

[[serial]]
== Терминология и оборудование для последовательной передачи данных

При связи по последовательному порту часто используются следующие термины:

bps::
Биты в секунду (бит/с) — это скорость передачи данных.

DTE::
Оборудование передачи данных (Data Terminal Equipment — DTE) — это одна из двух конечных точек в последовательной связи. Примером может служить компьютер.

DCE::
Оборудование передачи данных (Data Communication Equipment — DCE) — это другая конечная точка в последовательной связи. Обычно это модем или последовательный терминал.

RS-232::
Оригинальный стандарт, определяющий аппаратную последовательную связь. Впоследствии был переименован в TIA-232.

При упоминании скорости передачи данных в этом разделе не используется термин _бод_. Бод обозначает количество изменений электрического состояния за единицу времени, тогда как бит/с (bps) является корректным термином.

Для подключения последовательного терминала к системе FreeBSD необходим последовательный порт на компьютере и соответствующий кабель для соединения с последовательным устройством. Пользователям, уже знакомым с последовательным оборудованием и кабелями, можно смело пропустить этот раздел.

[[term-cables-null]]
=== Последовательные кабели и порты

Существует несколько различных типов последовательных кабелей. Два наиболее распространённых типа — это нуль-модемные кабели и стандартные кабели RS-232. В документации к оборудованию должен быть указан тип необходимого кабеля.

Эти два типа кабелей отличаются тем, как провода подключены к разъему. Каждый провод представляет собой сигнал, с определенными сигналами, перечисленными в crossref:serialcomms[serialcomms-signal-names,Имена сигналов RS-232C]. Стандартный последовательный кабель передает все сигналы RS-232C напрямую. Например, контакт "Передаваемые данные" на одном конце кабеля соединен с контактом "Передаваемые данные" на другом конце. Такой тип кабеля используется для подключения модема к системе FreeBSD, а также подходит для некоторых терминалов.

Нулевой модемный кабель меняет местами контакт "Передаваемые данные" одного конца с контактом "Принимаемые данные" другого конца. Разъём может быть либо DB-25, либо DB-9.

Нуль-модемный кабель можно изготовить, используя соединения контактов, приведенные в crossref:serialcomms[nullmodem-db25, DB-25 — DB-25 Null-Modem Cable], crossref:serialcomms[nullmodem-db9, DB-9 — DB-9 Null-Modem Cable] и crossref:serialcomms[nullmodem-db9-25, DB-9 — DB-25 Null-Modem Cable, DB-9 — DB-25 Null-Modem Cable]. Хотя стандарт требует прямого соединения контакта 1 с контактом 1 («Protective Ground»), эту линию часто не используют. Некоторые терминалы работают только с контактами 2, 3 и 7, тогда как другим требуются иные конфигурации. В случае сомнений обратитесь к документации оборудования.

[[serialcomms-signal-names]]
.Имена сигналов RS-232C
[cols="1,1", frame="none", options="header"]
|===
<| Аббревиатуры
<| Имена

|RD
|Received Data

|TD
|Transmitted Data

|DTR
|Готовность терминального оборудования (Data Terminal Ready)

|DSR
|Готовность терминального оборудования (Data Set Ready)

|DCD
|Обнаружение несущей (Data Carrier Detect)

|SG
|Сигнальная земля (Signal Ground)

|RTS
|Запрос на передачу (Request to Send)

|CTS
|Готовность к приёму (Clear to Send)
|===

[[nullmodem-db25]]
.от DB-25 к DB-25 кабель нуль-модема
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Сигнал
<| # пина
| 
<| # пина
<| Сигнал

|SG
|7
|соединяется с
|7
|SG

|TD
|2
|соединяется с
|3
|RD

|RD
|3
|соединяется с
|2
|TD

|RTS
|4
|соединяется с
|5
|CTS

|CTS
|5
|соединяется с
|4
|RTS

|DTR
|20
|соединяется с
|6
|DSR

|DTR
|20
|соединяется с
|8
|DCD

|DSR
|6
|соединяется с
|20
|DTR

|DCD
|8
|соединяется с
|20
|DTR
|===

[[nullmodem-db9]]
.от DB-9 к DB-9 кабель нуль-модема
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Сигнал
<| # пина
| 
<| # пина
<| Сигнал

|RD
|2
|соединяется с
|3
|TD

|TD
|3
|соединяется с
|2
|RD

|DTR
|4
|соединяется с
|6
|DSR

|DTR
|4
|соединяется с
|1
|DCD

|SG
|5
|соединяется с
|5
|SG

|DSR
|6
|соединяется с
|4
|DTR

|DCD
|1
|соединяется с
|4
|DTR

|RTS
|7
|соединяется с
|8
|CTS

|CTS
|8
|соединяется с
|7
|RTS
|===

[[nullmodem-db9-25]]
.от DB-9 к DB-25 кабель нуль-модема
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Сигнал
<| # пина
| 
<| # пина
<| Сигнал

|RD
|2
|соединяется с
|2
|TD

|TD
|3
|соединяется с
|3
|RD

|DTR
|4
|соединяется с
|6
|DSR

|DTR
|4
|соединяется с
|8
|DCD

|SG
|5
|соединяется с
|7
|SG

|DSR
|6
|соединяется с
|20
|DTR

|DCD
|1
|соединяется с
|20
|DTR

|RTS
|7
|соединяется с
|5
|CTS

|CTS
|8
|соединяется с
|4
|RTS
|===

[NOTE]
====
Когда один контакт на одном конце соединяется с парой контактов на другом конце, это обычно реализуется с помощью одного короткого провода между парой контактов в их разъёме и длинного провода к другому одиночному контакту.
====

Последовательные порты — это устройства, через которые данные передаются между хост-компьютером FreeBSD и терминалом. Существует несколько видов последовательных портов. Перед покупкой или изготовлением кабеля убедитесь, что он подходит к портам на терминале и системе FreeBSD.

Большинство терминалов оснащено портами DB-25. Персональные компьютеры могут иметь порты DB-25 или DB-9. Многопортовые последовательные платы могут быть оснащены портами RJ-12 или RJ-45. Для определения типа порта обратитесь к документации, прилагаемой к оборудованию, или визуально проверьте тип порта.

В FreeBSD каждый последовательный порт доступен через запись в [.filename]#/dev#. Существует два разных типа записей:

* Поры входящих соединений именуются [.filename]#/dev/ttyuN#, где _N_ — это номер порта, начиная с нуля. Если терминал подключен к первому последовательному порту ([.filename]#COM1#), используйте [.filename]#/dev/ttyu0# для обращения к терминалу. Если терминал находится на втором последовательном порту ([.filename]#COM2#), используйте [.filename]#/dev/ttyu1#, и так далее. Как правило, порт входящих соединений используется для терминалов. Для корректной работы порта требуется, чтобы последовательная линия подавала сигнал "Data Carrier Detect".
* Порты исходящих соединений называются [.filename]#/dev/cuauN# в FreeBSD версий 8.X и выше и [.filename]#/dev/cuadN# в FreeBSD версий 7.X и ниже. Порты исходящих соединений обычно не используются для терминалов, но применяются для модемов. Порт может быть использован, если последовательный кабель или терминал не поддерживают сигнал "Data Carrier Detect".

FreeBSD также предоставляет устройства инициализации ([.filename]#/dev/ttyuN.init# и [.filename]#/dev/cuauN.init# или [.filename]#/dev/cuadN.init#) и устройства блокировки ([.filename]#/dev/ttyuN.lock# и [.filename]#/dev/cuauN.lock# или [.filename]#/dev/cuadN.lock#). Устройства инициализации используются для установки параметров порта связи при каждом его открытии, например, `crtscts` для модемов, использующих сигнализацию `RTS/CTS` для управления потоком. Устройства блокировки применяются для фиксации флагов на портах, чтобы предотвратить изменение определённых параметров пользователями или программами. Дополнительную информацию о настройках терминала, блокировке и инициализации устройств, а также установке параметров терминала можно найти в руководствах man:termios[4], man:uart[4] и man:stty[1] соответственно.

[[serial-hw-config]]
=== Настройка последовательного порта

По умолчанию FreeBSD поддерживает четыре последовательных порта, обычно известных как [.filename]#COM1#, [.filename]#COM2#, [.filename]#COM3# и [.filename]#COM4#. FreeBSD также поддерживает простые многопортовые последовательные интерфейсные карты, такие как BocaBoard 1008 и 2016, а также более интеллектуальные многопортовые карты, например, производства Digiboard. Однако стандартное ядро ищет только порты [.filename]#COM#.

Чтобы проверить, распознает ли система последовательные порты, найдите сообщения загрузки системы, начинающиеся с `uart`:

[source, shell]
....
# grep uart /var/run/dmesg.boot
....

Если система не распознает все необходимые последовательные порты, в файл [.filename]#/boot/device.hints# можно добавить дополнительные записи. Этот файл уже содержит записи `hint.uart.0.\*` для [.filename]#COM1# и `hint.uart.1.*` для [.filename]#COM2#. При добавлении записи для порта [.filename]#COM3# используйте `0x3E8`, а для [.filename]#COM4# — `0x2E8`. Обычные адреса IRQ: `5` для [.filename]#COM3# и `9` для [.filename]#COM4#.

Для определения стандартных настроек терминального ввода-вывода, используемых портом, укажите имя его устройства. В этом примере определяются настройки для порта вызова на [.filename]#COM2#:

[source, shell]
....
# stty -a -f /dev/ttyu1
....

Системная инициализация последовательных устройств управляется файлом [.filename]#/etc/rc.d/serial#. Этот файл влияет на настройки по умолчанию для последовательных устройств. Чтобы изменить настройки устройства, используйте команду `stty`. По умолчанию изменённые настройки действуют до закрытия устройства, а при повторном открытии устройства возвращаются значения по умолчанию. Чтобы навсегда изменить настройки по умолчанию, откройте и настройте параметры инициализационного устройства. Например, чтобы включить режим `CLOCAL`, 8-битную передачу данных и управление потоком `XON/XOFF` для устройства [.filename]#ttyu5#, введите:

[source, shell]
....
# stty -f /dev/ttyu5.init clocal cs8 ixon ixoff
....

Чтобы предотвратить изменение определённых настроек приложением, внесите изменения в блокирующее устройство. Например, чтобы зафиксировать скорость [.filename]#ttyu5# на уровне 57600 бод, введите:

[source, shell]
....
# stty -f /dev/ttyu5.lock 57600
....

Теперь любое приложение, открывающее [.filename]#ttyu5# и пытающееся изменить скорость порта, будет ограничено скоростью 57600 бод.

[[term]]
== Терминалы

Терминалы обеспечивают удобный и недорогой способ доступа к системе FreeBSD, когда пользователь не находится за консолью компьютера или в подключенной сети. В этом разделе описывается, как использовать терминалы с FreeBSD.

Оригинальные системы UNIX(R) не имели консолей. Вместо этого пользователи входили в систему и запускали программы через терминалы, подключённые к последовательным портам компьютера.

Возможность установить сеанс входа через последовательный порт до сих пор присутствует практически во всех UNIX(R)-подобных операционных системах, включая FreeBSD. Подключив терминал к неиспользуемому последовательному порту, пользователь может войти в систему и запускать любые текстовые программы, которые обычно можно запустить на консоли или в окне `xterm`.

Многие терминалы могут быть подключены к системе FreeBSD. Старый запасной компьютер можно использовать в качестве терминала, подключенного к более мощному компьютеру с FreeBSD. Это позволяет превратить, казалось бы, однопользовательский компьютер в мощную многопользовательскую систему.

FreeBSD поддерживает три типа терминалов:

Простые терминалы::
Простые терминалы — это специализированные аппаратные устройства, подключаемые к компьютерам через последовательные линии. Они называются простыми, потому что обладают лишь достаточной вычислительной мощностью для отображения, отправки и приёма текста. На этих устройствах нельзя запускать программы. Вместо этого простые терминалы подключаются к компьютеру, на котором выполняются необходимые программы.
+
Существуют сотни видов простых терминалов, выпускаемых разными производителями, и практически любой из них будет работать с FreeBSD. Некоторые продвинутые терминалы даже поддерживают отображение графики, но только определённые программные пакеты могут использовать эти дополнительные возможности.
+
Простые терминалы популярны в рабочих средах, где сотрудникам не нужен доступ к графическим приложениям.

Компьютеры, выступающие в качестве терминалов::
Поскольку простой терминал обладает лишь минимальными возможностями для отображения, отправки и получения текста, в его роли может выступать практически любой компьютер. Всё, что для этого требуется, — это подходящий кабель и _программное обеспечение для эмуляции терминала_, запущенное на компьютере.
+
Такая конфигурация может быть полезной. Например, если один пользователь занят работой за консолью системы FreeBSD, другой пользователь может одновременно выполнять текстовые задачи на менее мощном персональном компьютере, подключённом как терминал к системе FreeBSD.
+
В базовой системе FreeBSD есть как минимум две утилиты для работы через последовательное соединение: man:cu[1] и man:tip[1].
+
Например, чтобы подключиться с клиентской системы под управлением FreeBSD к последовательному соединению другой системы:
+
[source, shell]
....
# cu -l /dev/cuauN
....
+
Порты нумеруются начиная с нуля. Это означает, что [.filename]#COM1# соответствует [.filename]#/dev/cuau0#.
+
Дополнительные программы доступны через Коллекцию портов, например, package:comms/minicom[].

X Терминалы::
X терминалы представляют собой наиболее продвинутый тип терминалов. Вместо подключения к последовательному порту они обычно работают через сеть, такую как Ethernet. В отличие от ограниченных текстовыми приложениями терминалов, они способны отображать любые приложения Xorg.
+
Эта глава не охватывает настройку, конфигурацию или использование X терминалов.

[[term-config]]
=== Настройка терминала

В этом разделе описывается, как настроить систему FreeBSD для включения сеанса входа через последовательный терминал. Предполагается, что система распознает последовательный порт, к которому подключен терминал, и что терминал подключен с помощью правильного кабеля.

В FreeBSD `init` читает файл [.filename]#/etc/ttys# и запускает процесс `getty` на доступных терминалах. Процесс `getty` отвечает за чтение имени пользователя и запуск программы `login`. Порты в системе FreeBSD, которые разрешают вход в систему, перечислены в файле [.filename]#/etc/ttys#. Например, первая виртуальная консоль [.filename]#ttyv0# имеет запись в этом файле, что разрешает вход на консоли. Этот файл также содержит записи для других виртуальных консолей, последовательных портов и псевдо-терминалов. Для физического терминала последовательный порт указывается как запись в [.filename]#/dev# без части `/dev`. Например, [.filename]#/dev/ttyv0# указывается как `ttyv0`.

Файл [.filename]#/etc/ttys# по умолчанию настраивает поддержку первых четырёх последовательных портов, от [.filename]#ttyu0# до [.filename]#ttyu3#:

[.programlisting]
....
ttyu0   "/usr/libexec/getty std.115200"   dialup  off secure
ttyu1   "/usr/libexec/getty std.115200"   dialup  off secure
ttyu2   "/usr/libexec/getty std.115200"   dialup  off secure
ttyu3   "/usr/libexec/getty std.115200"   dialup  off secure
....

При подключении терминала к одному из этих портов измените запись по умолчанию, чтобы установить необходимую скорость и тип терминала, включить устройство (`on`) и, если требуется, изменить настройку `secure` для порта. Если терминал подключен к другому порту, добавьте запись для этого порта.

В crossref:serialcomms[ex-etc-ttys,Настройка записей терминалов] настраиваются два терминала в [.filename]#/etc/ttys#. Первая запись настраивает терминал Wyse-50, подключённый к [.filename]#COM2#. Вторая запись настраивает старый компьютер с программным обеспечением терминала Procomm, эмулирующим терминал VT-100. Компьютер подключён к шестому последовательному порту многопортовой последовательной платы.

[example]
[[ex-etc-ttys]]
.Настройка записей терминалов
====

[.programlisting]
....
ttyu1  "/usr/libexec/getty std.38400"  wy50   on insecure
ttyu5   "/usr/libexec/getty std.19200"  vt100  on insecure
....

Первое поле указывает имя устройства последовательного терминала.

Второе поле указывает `getty` инициализировать и открыть линию, установить скорость линии, запросить имя пользователя и затем выполнить программу `login`. Необязательный _тип getty_ настрайвает характеристики линии терминала, такие как скорость передачи и контроль четности. Доступные типы getty перечислены в [.filename]#/etc/gettytab#. Почти во всех случаях подходят типы getty, начинающиеся с `std`, так как эти записи игнорируют контроль четности. Для каждой скорости передачи от 110 до 115200 существует запись `std`. Дополнительную информацию можно найти в man:gettytab[5]. При настройке типа getty убедитесь, что он соответствует параметрам связи, используемым терминалом. В данном примере Wyse-50 работает без контроля четности и подключается на скорости 38400 бод. Компьютер также работает без контроля четности и подключается на скорости 19200 бод.

Третье поле указывает тип терминала. Для коммутируемых портов обычно используется `unknown` или `dialup`, так как пользователи могут подключаться практически с любым типом терминала или программного обеспечения. Поскольку тип терминала не меняется для проводных терминалов, можно указать реальный тип терминала из [.filename]#/etc/termcap#. В данном примере для Wyse-50 используется реальный тип терминала, а для компьютера с Procomm установлена эмуляция VT-100.

Четвёртое поле определяет, должен ли порт быть включён. Чтобы разрешить входы через этот порт, в поле должно быть указано значение `on`.

Последнее поле используется для указания, является ли порт безопасным. Пометка порта как `secure` означает, что он считается достаточно доверенным, чтобы разрешить вход `root` с этого порта. Небезопасные порты не позволяют вход под `root`. На небезопасном порту пользователи должны входить с непривилегированных учетных записей, а затем использовать `su` или аналогичный механизм для получения прав суперпользователя, как описано в crossref:basics[users-superuser,“Учетная запись суперпользователя”]. В целях безопасности рекомендуется изменить этот параметр на `insecure`.
====

После внесения изменений в [.filename]#/etc/ttys# отправьте сигнал SIGHUP (завершения работы) процессу `init`, чтобы заставить его перечитать конфигурационный файл:

[source, shell]
....
# kill -HUP 1
....

Поскольку `init` всегда является первым процессом, запускаемым в системе, его идентификатор процесса всегда равен `1`.

Если всё настроено правильно, все кабели подключены, и терминалы включены, процесс `getty` должен быть запущен на каждом терминале, и на каждом терминале должна быть доступна приглашение для входа в систему.

[[term-debug]]
=== Устранение проблем с подключением

Даже при самом тщательном внимании к деталям что-то может пойти не так при настройке терминала. Вот список распространённых симптомов и некоторые предлагаемые решения.

Если приглашение для входа не появляется, убедитесь, что терминал подключен и включен. Если в качестве терминала используется персональный компьютер, убедитесь, что на нём запущено программное обеспечение эмуляции терминала на правильном последовательном порту.

Убедитесь, что кабель надежно подключен как к терминалу, так и к компьютеру с FreeBSD. Убедитесь, что используется правильный тип кабеля.

Убедитесь, что терминал и FreeBSD используют одинаковые скорость (bps) и настройки четности. Для видеотерминала убедитесь, что регуляторы контрастности и яркости включены. Если это печатающий терминал, проверьте наличие бумаги и чернил.

Используйте `ps`, чтобы убедиться, что процесс `getty` запущен и обслуживает терминал. Например, следующий вывод показывает, что `getty` работает на втором последовательном порту, [.filename]#ttyu1#, и использует запись `std.38400` в файле [.filename]#/etc/gettytab#:

[source, shell]
....
# ps -axww|grep ttyu
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1
....

Если процесс `getty` не запущен, убедитесь, что порт включен в файле [.filename]#/etc/ttys#. Не забудьте выполнить `kill -HUP 1` после изменения файла [.filename]#/etc/ttys#.

Если процесс `getty` работает, но терминал по-прежнему не отображает приглашение для входа, или если он отображает приглашение, но не принимает вводимые данные, возможно, терминал или кабель не поддерживают аппаратное подтверждение связи. Попробуйте изменить запись в [.filename]#/etc/ttys# с `std.38400` на `3wire.38400`, затем выполните `kill -HUP 1` после изменения [.filename]#/etc/ttys#. Запись `3wire` аналогична `std`, но игнорирует аппаратное подтверждение связи. Также может потребоваться уменьшить скорость передачи данных или включить программное управление потоком при использовании `3wire`, чтобы избежать переполнения буфера.

Если вместо приглашения к входу в систему появляется мусор, убедитесь, что терминал и FreeBSD используют одинаковые скорость (bps) и настройки четности. Проверьте процессы `getty`, чтобы убедиться, что используется правильный тип _getty_. Если это не так, отредактируйте файл [.filename]#/etc/ttys# и выполните команду `kill -HUP 1`.

Если символы отображаются удвоенными, а пароль виден при вводе, переключите терминал или программу эмуляции терминала из режима «полудуплексный» или «локальный эхо-контроль» в режим «полнодуплексный».

[[dialup]]
== Входящие соединения по модему

Настройка системы FreeBSD для предоставления входящих соединений аналогична настройке терминалов, за исключением того, что вместо терминальных устройств используются модемы. FreeBSD поддерживает как внешние, так и внутренние модемы.

Внешние модемы удобнее, так как их часто можно настроить с помощью параметров, хранящихся в энергонезависимой памяти, и они обычно оснащены световыми индикаторами, отображающими состояние важных сигналов RS-232, что позволяет определить, работает ли модем правильно.

Внутренние модемы обычно не имеют энергонезависимой памяти, поэтому их настройка может ограничиваться установкой перемычек. Если у внутреннего модема есть индикаторные лампы, их трудно увидеть, когда корпус системы закрыт.

При использовании внешнего модема необходим соответствующий кабель. Достаточно стандартного последовательного кабеля RS-232C.

FreeBSD требует сигналов RTS и CTS для управления потоком данных на скоростях выше 2400 бит/с, сигнала CD для определения ответа на вызов или завершения соединения, а также сигнала DTR для сброса модема после завершения сеанса. Некоторые кабели подключены без всех необходимых сигналов, поэтому, если сеанс входа в систему не завершается при разрыве соединения, проблема может быть в кабеле. Дополнительную информацию об этих сигналах можно найти в разделе crossref:serialcomms[term-cables-null, Последовательные кабели и порты].

Как и другие UNIX(R)-подобные операционные системы, FreeBSD использует аппаратные сигналы для определения ответа на вызов или завершения соединения, а также для сброса и разрыва соединения модема после вызова. FreeBSD избегает отправки команд модему или отслеживания его статусных отчетов.

FreeBSD поддерживает интерфейсы связи RS-232C (CCITT V.24) на основе NS8250, NS16450, NS16550 и NS16550A. Устройства 8250 и 16450 имеют однобайтовые буферы. Устройство 16550 предоставляет 16-байтовый буфер, что позволяет повысить производительность системы. Ошибки в обычных чипах 16550 не позволяют использовать 16-байтовый буфер, поэтому по возможности следует использовать устройства 16550A. Поскольку устройства с однобайтовым буфером требуют больше работы от операционной системы, чем устройства с 16-байтовым буфером, предпочтительнее использовать последовательные интерфейсные карты на основе 16550A. Если в системе много активных последовательных портов или ожидается высокая нагрузка, карты на основе 16550A обеспечивают более надежную связь с низким уровнем ошибок.

Оставшаяся часть этого раздела демонстрирует, как настроить модем для приема входящих соединений, как взаимодействовать с модемом, а также предлагает несколько советов по устранению неполадок.

[[dialup-ttys]]
=== Настройка модема

Как и в случае с терминалами, `init` запускает процесс `getty` для каждого настроенного последовательного порта, используемого для входящих соединений. Когда пользователь дозванивается по линии модема и модемы соединяются, модем сообщает о сигнале "Carrier Detect". Ядро обнаруживает наличие несущей и указывает `getty` открыть порт и вывести приглашение `login:` с указанной начальной скоростью линии. В типичной конфигурации, если получены некорректные символы (обычно из-за несоответствия скорости соединения модема и настроенной скорости), `getty` пытается изменить скорость линии, пока не получит разборчивые символы. После того как пользователь вводит имя для входа, `getty` запускает `login`, который завершает процесс входа, запрашивая пароль пользователя и затем запуская его оболочку.

Существует два подхода к настройке модемов для коммутируемого доступа. Первый метод заключается в том, чтобы настроить модемы и систему таким образом, что независимо от скорости, с которой удалённый пользователь подключается, скорость интерфейса RS-232 остаётся фиксированной. Преимущество такой настройки в том, что удалённый пользователь всегда сразу видит приглашение системы к вводу логина. Недостаток же состоит в том, что система не знает реальной скорости передачи данных пользователя, поэтому полноэкранные программы, такие как Emacs, не могут адаптировать методы отрисовки экрана для улучшения отклика на медленных соединениях.

Второй способ заключается в настройке интерфейса RS-232 для изменения скорости в зависимости от скорости соединения удаленного пользователя. Поскольку `getty` не понимает отчеты о скорости соединения конкретного модема, он выводит сообщение `login:` на начальной скорости и отслеживает символы, которые приходят в ответ. Если пользователь видит непонятные символы, он должен нажать kbd:[Enter], пока не увидит узнаваемое приглашение. Если скорости передачи данных не совпадают, `getty` воспринимает введенные пользователем символы как непонятные, переключается на следующую скорость и снова выводит приглашение `login:`. Обычно для появления корректного приглашения достаточно нажать одну-две клавиши. Этот процесс входа выглядит не так аккуратно, как метод с фиксированной скоростью, но пользователь с низкоскоростным соединением получит лучшую интерактивную реакцию от полноэкранных программ.

При фиксации скорости передачи данных модема на определенном значении изменения в файле [.filename]#/etc/gettytab# обычно не требуются. Однако для конфигурации с согласованием скоростей могут понадобиться дополнительные записи, чтобы определить скорости, используемые для модема. В этом примере настраивается модем 14,4 Кбит/с с максимальной скоростью интерфейса 19,2 Кбит/с при 8-битных соединениях без контроля четности. Здесь `getty` настраивается на начало связи для соединения V.32bis со скоростью 19,2 Кбит/с, затем перебирает скорости 9600 бит/с, 2400 бит/с, 1200 бит/с, 300 бит/с и снова возвращается к 19,2 Кбит/с. Перебор скоростей связи реализуется с помощью возможности `nx=` (следующая таблица). Каждая строка использует запись `tc=` (продолжение таблицы) для наследования остальных параметров для конкретной скорости передачи данных.

[.programlisting]
....
#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:
....

Для модема со скоростью 28,8 Кбит/с или для использования сжатия на модеме 14,4 Кбит/с следует установить более высокую скорость передачи данных, как показано в этом примере:

[.programlisting]
....
#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:
....

Для медленного процессора или сильно загруженной системы без последовательных портов на базе 16550A такая конфигурация может вызывать ошибки "silo" в `uart` на скорости 57,6 Кбит/с.

Конфигурация [.filename]#/etc/ttys# аналогична crossref:serialcomms[ex-etc-ttys,Конфигурация записей терминалов], но в `getty` передается другой аргумент, а в качестве типа терминала используется `dialup`. Замените _xxx_ на процесс, который `init` будет запускать на устройстве:

[.programlisting]
....
ttyu0   "/usr/libexec/getty xxx"   dialup on
....

Тип терминала `dialup` можно изменить. Например, установка `vt102` в качестве типа терминала по умолчанию позволяет пользователям использовать эмуляцию VT102 на их удалённых системах.

Для конфигурации с фиксированной скоростью укажите скорость с допустимым типом, перечисленным в [.filename]#/etc/gettytab#. В этом примере показана настройка для модема, скорость порта которого зафиксирована на 19,2 Кбит/с:

[.programlisting]
....
ttyu0   "/usr/libexec/getty std.19200"   dialup on
....

В конфигурации с согласованной скоростью запись должна ссылаться на соответствующую начальную запись "автонастройки скорости" в [.filename]#/etc/gettytab#. Чтобы продолжить пример для модема с согласованной скоростью, начинающего работу с 19,2 Кбит/с, используйте следующую запись:

[.programlisting]
....
ttyu0   "/usr/libexec/getty V19200"   dialup on
....

После редактирования [.filename]#/etc/ttys# дождитесь, пока модем будет правильно настроен и подключен, прежде чем подавать сигнал `init`:

[source, shell]
....
# kill -HUP 1
....

Высокоскоростные модемы, такие как V.32, V.32bis и V.34, используют аппаратное управление потоком (`RTS/CTS`). Используйте `stty` для установки флага аппаратного управления потоком для порта модема. В этом примере устанавливается флаг `crtscts` для устройств инициализации входящих и исходящих соединений на [.filename]#COM2#:

[source, shell]
....
# stty -f /dev/ttyu1.init crtscts
# stty -f /dev/cuau1.init crtscts
....

=== Устранение неполадок

В этом разделе приведены несколько советов по устранению неполадок с модемом для коммутируемого доступа, который не подключается к системе FreeBSD.

Подключите модем к системе FreeBSD и загрузите систему. Если на модеме есть индикаторы состояния, следите за тем, загорается ли индикатор DTR модема при появлении приглашения `login:` на консоли системы. Если он загорается, это должно означать, что FreeBSD запустила процесс `getty` на соответствующем коммуникационном порту и ожидает принятия вызова модемом.

Если индикатор DTR не горит, войдите в систему FreeBSD через консоль и введите `ps ax`, чтобы проверить, запущен ли процесс `getty` на правильном порту в FreeBSD:

[source, shell]
....
  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
....

Если во втором столбце указано `d0` вместо `??` и модем ещё не принял звонок, это означает, что `getty` завершил открытие коммуникационного порта. Это может указывать на проблему с кабелем или неправильную настройку модема, так как `getty` не должен иметь возможности открыть коммуникационный порт до тех пор, пока модем не подал сигнал обнаружения несущей.

Если нет процессов `getty`, ожидающих открытия порта, дважды проверьте, что запись для порта корректна в [.filename]#/etc/ttys#. Также проверьте [.filename]#/var/log/messages#, чтобы увидеть, есть ли какие-либо сообщения в логе от `init` или `getty`.

Далее попробуйте подключиться к системе. Убедитесь, что на удалённой системе установлены 8 бит, отсутствие контроля чётности и 1 стоповый бит. Если приглашение не появляется сразу или отображается как бессмыслица, попробуйте нажимать kbd:[Enter] примерно раз в секунду. Если приглашение `login:` так и не появилось, попробуйте отправить `BREAK`. При использовании высокоскоростного модема попробуйте набрать номер ещё раз после фиксации скорости интерфейса набирающего модема.

Если приглашение `login:` по-прежнему не появляется, проверьте [.filename]#/etc/gettytab# ещё раз и убедитесь, что:

* Изначальное название возможности, указанное в записи файла [.filename]#/etc/ttys#, соответствует названию возможности в файле [.filename]#/etc/gettytab#.
* Каждая запись `nx=` соответствует другому имени возможности в [.filename]#gettytab#.
* Каждая запись `tc=` соответствует другому имени возможности в [.filename]#gettytab#.

Если модем в системе FreeBSD не отвечает, убедитесь, что он настроен на ответ на звонок при активном сигнале DTR. Если модем, кажется, настроен правильно, проверьте, что линия DTR активна, по индикаторам модема.

Если это по-прежнему не работает, попробуйте отправить письмо в {freebsd-questions} с описанием модема и возникшей проблемы.

[[dialout]]
== Исходящие соединения по модему

Вот несколько советов по подключению хоста через модем к другому компьютеру. Это подходит для установки терминального сеанса с удалённым хостом.

Такой тип соединения может быть полезен для получения файла из Интернета, если возникли проблемы с использованием PPP. Если PPP не работает, используйте терминальную сессию для FTP-загрузки нужного файла. Затем воспользуйтесь zmodem для его передачи на машину.

[[hayes-unsupported]]
=== Использование стандартного модема Hayes

В `tip` встроен стандартный Hayes-совместимый наборщик номера. Используйте `at=hayes` в [.filename]#/etc/remote#.

Драйвер Hayes недостаточно интеллектуален, чтобы распознать некоторые расширенные функции современных модемов, такие как сообщения `BUSY`, `NO DIALTONE` или `CONNECT 115200`. Отключите эти сообщения при использовании `tip` с помощью команды `ATX0&W`.

Таймаут набора номера для `tip` составляет 60 секунд. Модем должен использовать значение меньше, иначе `tip` решит, что возникли проблемы со связью. Попробуйте `ATS7=45&W`.

[[direct-at]]
=== Использование команд `AT`

Создайте запись "direct" в файле [.filename]#/etc/remote#. Например, если модем подключён к первому последовательному порту, [.filename]#/dev/cuau0#, используйте следующую строку:

[.programlisting]
....
cuau0:dv=/dev/cuau0:br#19200:pa=none
....

Используйте наибольшую скорость передачи данных, которую поддерживает модем, в параметре `br`. Затем введите `tip cuau0` для подключения к модему.

Или используйте `cu` от имени `root` с следующей командой:

[source, shell]
....
# cu -lline -sspeed
....

Строка _line_ указывает на последовательный порт, например, [.filename]#/dev/cuau0#, а _speed_ — это скорость, например, `57600`. После завершения ввода AT-команд введите `~.` для выхода.

[[gt-failure]]
=== Знак `@` не работает

Знак `@` в параметре номера телефона указывает `tip` искать номер в файле [.filename]#/etc/phones#. Однако, знак `@` также является специальным символом в файлах параметров, таких как [.filename]#/etc/remote#, поэтому его необходимо экранировать обратной косой чертой:

[.programlisting]
....
pn=\@
....

[[dial-command-line]]
=== Набор номера из командной строки

Поместите запись "generic" в [.filename]#/etc/remote#. Например:

[.programlisting]
....
tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:
....

Это должно теперь работать:

[source, shell]
....
# tip -115200 5551234
....

Пользователи, предпочитающие `cu` вместо `tip`, могут использовать общую запись `cu`:

[.programlisting]
....
cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:
....

и введите:

[source, shell]
....
# cu 5551234 -s 115200
....

[[set-bps]]
=== Установка скорости в бодах

Добавьте запись для `tip1200` или `cu1200`, но используйте подходящую скорость передачи (bps) с помощью возможности `br`. `tip` считает хорошим значением по умолчанию 1200 bps, поэтому ищет запись `tip1200`. Однако, не обязательно использовать именно 1200 bps.

[[terminal-server]]
=== Доступ к нескольким хостам через терминальный сервер

Вместо того чтобы каждый раз ждать подключения и вводить `CONNECT _хост_`, используйте возможность `cm` в ``tip``. Например, следующие записи в [.filename]#/etc/remote# позволят вам набрать `tip pain` или `tip muffin` для подключения к хостам `pain` или `muffin`, а `tip deep13` — для подключения к терминальному серверу.

[.programlisting]
....
pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:
....

[[tip-multiline]]
=== Использование более одного телефонного номера с `tip`

Это часто оказывается проблемой, когда в университете есть несколько модемных линий и несколько тысяч студентов, пытающихся до них дозвониться.

Сделайте запись в [.filename]#/etc/remote# и используйте `@` для возможности `pn`:

[.programlisting]
....
big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:
....

Затем перечислите номера телефонов в [.filename]#/etc/phones#:

[.programlisting]
....
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
....

`tip` будет пробовать каждый номер в указанном порядке, затем завершит работу. Для повторных попыток запустите `tip` в цикле `while`.

[[multi-controlp]]
=== Использование управляющего символа

По умолчанию `kbd:[Ctrl+P]` — это символ "принуждения", используемый для указания `tip`, что следующий символ является буквальными данными. Символ принуждения можно изменить на любой другой с помощью экранирования `~s`, что означает "установить переменную".

Введите `~sforce=_одиночный-символ_`, затем нажмите Enter. _одиночный-символ_ — это любой одиночный символ. Если _одиночный-символ_ не указан, то управляющий символ будет нулевым символом, который вводится с помощью kbd:[Ctrl+2] или kbd:[Ctrl+Пробел]. Хорошим значением для _одиночный-символ_ может быть kbd:[Shift+Ctrl+6], который используется только на некоторых терминальных серверах.

Чтобы изменить управляющий символ, укажите следующее в [.filename]#~/.tiprc#:

[.programlisting]
....
force=single-char
....

[[uppercase]]
=== Верхний регистр символов

Это происходит при нажатии kbd:[Ctrl+A], что является «raise character» в ``tip``, специально предназначенным для людей с неработающими клавишами caps-lock. Используйте `~s`, чтобы установить `raisechar` в разумное значение. Его можно установить таким же, как и «force character», если ни одна из функций не используется.

Вот пример файла [.filename]#~/.tiprc# для пользователей Emacs, которым нужно вводить kbd:[Ctrl+2] и kbd:[Ctrl+A]:

[.programlisting]
....
force=^^
raisechar=^^
....

`^^` — это kbd:[Shift+Ctrl+6].

[[tip-filetransfer]]
=== Копирование файлов с помощью `tip`

При обмене данными с другой UNIX(R)-подобной операционной системой файлы можно отправлять и получать с помощью команд `~p` (put) и `~t` (take). Эти команды выполняют `cat` и `echo` на удалённой системе для приёма и отправки файлов. Синтаксис следующий: `~p` локальный-файл [ удалённый-файл ] `~t` удалённый-файл [ локальный-файл ]

Проверка ошибок отсутствует, поэтому следует использовать другой протокол, например, zmodem.

[[zmodem-tip]]
=== Как использовать zmodem с `tip`?

Для получения файлов запустите программу отправки на удаленной стороне. Затем введите `~C rz`, чтобы начать их получение локально.

Для отправки файлов запустите программу приема на удаленной стороне. Затем введите `~C sz _файлы_`, чтобы отправить их на удаленную систему.

[[serialconsole-setup]]
== Настройка последовательной консоли

FreeBSD поддерживает возможность загрузки системы с использованием простого терминала на последовательном порту в качестве консоли. Такая конфигурация полезна для системных администраторов, которые хотят установить FreeBSD на машины без подключённых клавиатуры или монитора, а также для разработчиков, отлаживающих ядро или драйверы устройств.

Как описано в crossref:boot[boot,Процесс загрузки FreeBSD], FreeBSD использует трехэтапную загрузку. Первые два этапа находятся в коде загрузочного блока, который хранится в начале раздела FreeBSD на загрузочном диске. Затем загрузочный блок загружает и запускает загрузчик в качестве кода третьего этапа.

Для настройки загрузки с последовательной консоли необходимо настроить код загрузочного блока, код загрузчика и ядро.

[[serialconsole-howto-fast]]
=== Быстрая настройка последовательной консоли

В этом разделе представлено краткое описание настройки последовательной консоли. Данная процедура может быть использована, когда к [.filename]#COM1# подключён алфавитно-цифровой терминал.

[.procedure]
.Процедура: Настройка последовательной консоли на [.filename]#COM1#
. Подключите последовательный кабель к [.filename]#COM1# и управляющему терминалу.
. Для настройки вывода загрузочных сообщений на последовательный консоль выполните следующую команду от имени суперпользователя:
+
[source, shell]
....
# echo 'console="comconsole"' >> /boot/loader.conf
....

. Отредактируйте файл [.filename]#/etc/ttys# и измените `off` на `on`, а `dialup` на `vt100` для записи [.filename]#ttyu0#. В противном случае, для подключения через последовательную консоль не потребуется пароль, что создаст потенциальную уязвимость безопасности.
. Перезагрузите систему, чтобы проверить, вступили ли изменения в силу.

Если требуется другая конфигурация, обратитесь к следующему разделу для более подробного объяснения настройки.

[[serialconsole-howto]]
=== Углубленная настройка последовательной консоли

В этом разделе представлено более подробное объяснение шагов, необходимых для настройки последовательной консоли в FreeBSD.

[.procedure]
.Процедура: Настройка последовательной консоли
. Подготовьте последовательный кабель.
+
Используйте нуль-модемный кабель либо стандартный последовательный кабель с нуль-модемным адаптером. Подробнее о последовательных кабелях см. в разделе crossref:serialcomms[term-cables-null, Последовательные кабели и порты].
. Отключите клавиатуру.
+
Многие системы проверяют наличие клавиатуры во время самотестирования при включении (POST) и выдают ошибку, если клавиатура не обнаружена. Некоторые компьютеры отказываются загружаться, пока клавиатура не будет подключена.
+
Если компьютер сообщает об ошибке, но всё же загружается, дальнейшая настройка не требуется.
+
Если компьютер отказывается загружаться без подключённой клавиатуры, настройте BIOS так, чтобы он игнорировал эту ошибку. Подробности о том, как это сделать, можно найти в руководстве к материнской плате.
+
[TIP]
====
Попробуйте установить значение "Не установлена" для клавиатуры в BIOS. Этот параметр указывает BIOS не проверять наличие клавиатуры при включении, поэтому он не должен выдавать ошибку при её отсутствии. Если такой опции нет в BIOS, поищите параметр "Останов при ошибке". Установка его в значение "Все, кроме клавиатуры" или "Нет ошибок" даст тот же эффект.
====
+
Если в системе есть мышь PS/2(R), её также следует отключить. Мыши PS/2(R) используют общее оборудование с клавиатурой, и если оставить мышь подключённой, это может ввести проверку клавиатуры в заблуждение, заставив её считать, что клавиатура всё ещё подключена.
+
[NOTE]
====
Хотя большинство систем загружаются без клавиатуры, многие не загрузятся без графического адаптера. Некоторые системы можно настроить на загрузку без графического адаптера, изменив параметр "графический адаптер" в конфигурации BIOS на "Не установлен". Другие системы не поддерживают эту опцию и откажутся загружаться, если в системе нет оборудования для вывода изображения. На таких машинах следует оставить какой-либо графический адаптер, даже если это просто старая монохромная плата. Монитор подключать не обязательно.
====

. Подключите простой терминал, старый компьютер с модемной программой или последовательный порт другого UNIX(R)-компьютера к последовательному порту.
. Добавьте соответствующие записи `hint.uart.*` в файл [.filename]#/boot/device.hints# для последовательного порта. Некоторые многопортовые карты также требуют настройки параметров ядра. Рекомендуемые параметры и подсказки для устройств каждого поддерживаемого последовательного порта смотрите в man:uart[4].
. Создайте [.filename]#boot.config# в корневом каталоге раздела `a` на загрузочном диске.
+
Этот файл указывает коду загрузочного блока, как загружать систему. Для активации последовательной консоли необходима одна или несколько следующих опций. При использовании нескольких опций включите их все в одну строку:
+
`-h`:::
Переключает между внутренней и последовательной консолями. Используйте это для смены устройств консоли. Например, для загрузки с внутренней (видео) консоли используйте `-h`, чтобы указать загрузчику и ядру использовать последовательный порт в качестве устройства консоли. Или же, для загрузки с последовательного порта, используйте `-h`, чтобы указать загрузчику и ядру использовать видеодисплей в качестве консоли.

`-D`:::
Переключает между одноконсольной и двухконсольной конфигурациями. В одноконсольной конфигурации консолью будет либо внутренняя консоль (видеодисплей), либо последовательный порт, в зависимости от состояния `-h`. В двухконсольной конфигурации и видеодисплей, и последовательный порт одновременно становятся консолью, независимо от состояния `-h`. Однако двухконсольная конфигурация действует только во время работы загрузочного блока. Как только загрузчик получает управление, консоль, указанная с помощью `-h`, становится единственной консолью.

`-P`:::
Заставляет загрузочный блок проверять наличие клавиатуры. Если клавиатура не обнаружена, опции `-D` и `-h` устанавливаются автоматически.
+
[NOTE]
====
Из-за ограничений места в текущей версии загрузочных блоков, `-P` способен обнаруживать только расширенные клавиатуры. Клавиатуры с менее чем 101 клавишей и без клавиш F11 и F12 могут не быть обнаружены. Клавиатуры на некоторых ноутбуках могут не находиться корректно из-за этого ограничения. Если это так, не используйте `-P`.
====
+
Используйте `-P` для автоматического выбора консоли или `-h` для активации последовательной консоли. Подробности смотрите в man:boot[8] и man:boot.config[5].
+
Параметры, за исключением `-P`, передаются загрузчику. Загрузчик определит, должна ли внутренняя видеосистема или последовательный порт быть консолью, анализируя состояние параметра `-h`. Это означает, что если указан `-D`, но параметр `-h` не указан в [.filename]#/boot.config#, последовательный порт может использоваться в качестве консоли только во время загрузки блока, так как загрузчик будет использовать внутренний видеоадаптер в качестве консоли.
. Загрузите компьютер.
+
При загрузке FreeBSD загрузочные блоки выводят содержимое файла [.filename]#/boot.config# на консоль. Например:
+
[source, shell]
....
/boot.config: -P
Keyboard: no
....
+
Вторая строка появляется только при наличии `-P` в [.filename]#/boot.config# и указывает на наличие или отсутствие клавиатуры. Эти сообщения выводятся на последовательный или внутренний консоль, или на оба, в зависимости от опции в [.filename]#/boot.config#:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
<| Опции
<| Сообщение отправляется на

|none
|внутреннюю консоль

|`-h`
|последовательную консоль

|`-D`
|последовательную и внутреннюю консоли

|`-Dh`
|последовательную и внутреннюю консоли

|`-P`, клавиатура подключена
|внутреннюю консоль

|`-Р`, клавиатура отсутствует
|последовательную консоль
|===
+
После сообщения будет небольшая пауза перед тем, как загрузочные блоки продолжат загрузку и выполнение загрузчика и до вывода следующих сообщений на консоль. В обычных условиях нет необходимости прерывать работу загрузочных блоков, но это можно сделать, чтобы убедиться, что всё настроено правильно.
+
Нажмите любую клавишу, кроме kbd:[Enter], на консоли, чтобы прервать процесс загрузки. Затем загрузочные блоки запросят дальнейшие действия:
+
[source, shell]
....
>> FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:
....
+
Убедитесь, что указанное сообщение появилось на последовательном или внутреннем консоле, или на обоих, в соответствии с параметрами в [.filename]#/boot.config#. Если сообщение появилось на правильной консоли, нажмите kbd:[Enter] для продолжения процесса загрузки.
+
Если на последовательном терминале нет приглашения, значит, что-то не так с настройками. Введите `-h`, затем kbd:[Enter] или kbd:[Return], чтобы указать загрузочному блоку (а затем загрузчику и ядру) выбрать последовательный порт для консоли. После загрузки системы вернитесь и проверьте, что пошло не так.

На третьем этапе процесса загрузки можно по-прежнему переключаться между внутренней консолью и последовательной консолью, установив соответствующие переменные окружения в загрузчике. Подробнее см. в man:loader[8].

[NOTE]
====
Эта строка в [.filename]#/boot/loader.conf# или [.filename]#/boot/loader.conf.local# настраивает загрузчик и ядро для отправки загрузочных сообщений на последовательную консоль, независимо от параметров в [.filename]#/boot.config#:

[.programlisting]
....
console="comconsole"
....

Эта строка должна быть первой в [.filename]#/boot/loader.conf#, чтобы сообщения загрузки выводились на последовательную консоль как можно раньше.

Если эта строка отсутствует или имеет значение `console="vidconsole"`, загрузчик и ядро будут использовать консоль, указанную параметром `-h` в загрузочном блоке. Подробнее см. в man:loader.conf[5].

На данный момент загрузчик не имеет опции, аналогичной `-P` в загрузочном блоке, и не предусмотрена возможность автоматического выбора внутренней консоли и последовательной консоли в зависимости от наличия клавиатуры.
====

[TIP]
====
Хотя это и не обязательно, можно настроить вывод приглашения `login` через последовательный порт. Для этого отредактируйте запись для последовательного порта в [.filename]#/etc/ttys#, следуя инструкциям в crossref:serialcomms[term-config, Настройка терминала]. Если скорость последовательного порта была изменена, замените `std.115200` на новое значение.
====

=== Установка более высокой скорости последовательного порта

По умолчанию настройки последовательного порта: скорость 115200 бод, 8 бит данных, без контроля чётности и 1 стоповый бит. Чтобы изменить стандартную скорость консоли, используйте один из следующих вариантов:

* Отредактируйте файл [.filename]#/etc/make.conf# и установите значение `BOOT_COMCONSOLE_SPEED` на новую скорость консоли. Затем перекомпилируйте и установите загрузочные блоки и загрузчик:
+
[source, shell]
....
# cd /sys/boot
# make clean
# make
# make install
....
+
Если последовательная консоль настроена иным способом, кроме загрузки с `-h`, или если последовательная консоль, используемая ядром, отличается от той, что используется загрузочными блоками, добавьте следующую опцию с нужной скоростью в файл конфигурации собственного ядра и соберите новое ядро:
+
[.programlisting]
....
options CONSPEED=19200
....

* Добавьте параметр загрузки `-S__19200__` в [.filename]#/boot.config#, заменив `_19200_` на нужную скорость.
* Добавьте следующие параметры в [.filename]#/boot/loader.conf#. Замените `_115200_` на нужную скорость.
+
[.programlisting]
....
boot_multicons="YES"
boot_serial="YES"
comconsole_speed="115200"
console="comconsole,vidconsole"
....

[[serialconsole-ddb]]
=== Вход в отладчик DDB с последовательной линии

Для настройки возможности перехода в отладчик ядра с последовательной консоли добавьте следующие параметры в пользовательский конфигурационный файл ядра и соберите ядро, используя инструкции из crossref:kernelconfig[kernelconfig,Настройка ядра FreeBSD]. Обратите внимание, что хотя это полезно для удалённой диагностики, это также опасно, если на последовательном порту генерируется ложный BREAK. Дополнительную информацию об отладчике ядра можно найти в man:ddb[4] и man:ddb[8].

[.programlisting]
....
options BREAK_TO_DEBUGGER
options DDB
....
