---
description: 'Эта глава посвящена использованию режима USB Device Mode и USB On The Go (USB OTG) в FreeBSD'
next: books/handbook/partiv
params:
  path: /books/handbook/usb-device-mode/
part: 'Часть III. Администрирование системы'
prev: books/handbook/dtrace
showBookMenu: true
tags: ["OTG", "USB"]
title: 'Глава 28. Режим USB-устройства / USB OTG'
weight: 32
---

[[usb-device-mode]]
= Режим устройства USB / USB OTG
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 28
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/usb-device-mode/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[usb-device-mode-synopsis]]
== Обзор

Эта глава посвящена использованию USB Device Mode и USB On The Go (USB OTG) в FreeBSD. В неё входят виртуальные последовательные консоли, виртуальные сетевые интерфейсы и виртуальные USB-накопители.

При работе на оборудовании, поддерживающем режим USB-устройства или USB OTG, который встроен во многие материнские платы, стек USB FreeBSD может работать в _режиме устройства_. Режим устройства позволяет компьютеру представлять себя как различные классы USB-устройств, включая последовательные порты, сетевые адаптеры и устройства хранения данных, или их комбинацию. USB-хост, такой как ноутбук или настольный компьютер, может обращаться к ним так же, как к физическим USB-устройствам. Режим устройства иногда называют «режимом USB-гаджета».

Существует два основных способа, которыми оборудование может обеспечивать функциональность режима устройства: с отдельным "клиентским портом", который поддерживает только режим устройства, и с портом USB OTG, который может обеспечивать как режим устройства, так и режим хоста. Для портов USB OTG стек USB автоматически переключается между режимом хоста и режимом устройства в зависимости от того, что подключено к порту. Подключение USB-устройства, такого как флеш-накопитель, приводит к переключению FreeBSD в режим хоста. Подключение USB-хоста, например компьютера, приводит к переключению FreeBSD в режим устройства. Однонаправленные "клиентские порты" всегда работают в режиме устройства.

То, что FreeBSD предоставляет USB-хосту, зависит от параметра `hw.usb.template` в sysctl. Некоторые шаблоны предоставляют одно устройство, например, последовательный терминал; другие предоставляют несколько устройств, которые можно использовать одновременно. Примером является шаблон 10, который предоставляет устройство хранения данных, последовательную консоль и сетевой интерфейс. Список доступных значений смотрите в man:usb_template[4].

Обратите внимание, что в некоторых случаях, в зависимости от оборудования и операционной системы хоста, для того чтобы хост заметил изменение конфигурации, может потребоваться либо физическое отключение и повторное подключение, либо принудительное повторное сканирование шины USB способом, зависящим от системы. Если на хосте запущена FreeBSD, можно использовать man:usbconfig[8] `reset`. Это также необходимо сделать после загрузки [.filename]#usb_template.ko#, если USB-хост уже был подключен к разъему USBOTG.

Прочитав эту главу, вы будете знать:

* Как настроить функциональность USB Device Mode в FreeBSD.
* Как настроить виртуальный последовательный порт на FreeBSD.
* Как подключиться к виртуальному последовательному порту из различных операционных систем.
* Как настроить FreeBSD для предоставления виртуального USB-сетевого интерфейса.
* Как настроить FreeBSD для предоставления виртуального USB-накопителя.

[[usb-device-mode-terminals]]
== Виртуальные последовательные порты USB

=== Настройка последовательных портов в режиме USB-устройства

Поддержка виртуальных последовательных портов предоставляется шаблонами 3, 8 и 10. Обратите внимание, что шаблон 3 работает с Microsoft Windows 10 без необходимости в специальных драйверах и INF-файлах. Другие операционные системы хоста работают со всеми тремя шаблонами. Необходимо загрузить оба модуля ядра man:usb_template[4] и man:umodem[4].

Чтобы включить последовательные порты в режиме устройства USB, добавьте следующие строки в [.filename]#/etc/ttys#:

[.programlisting]
....
ttyU0	"/usr/libexec/getty 3wire"	vt100	onifconsole secure
ttyU1	"/usr/libexec/getty 3wire"	vt100	onifconsole secure
....

Затем добавьте следующие строки в [.filename]#/etc/devd.conf#:

[.programlisting]
....
notify 100 {
	match "system"		"DEVFS";
	match "subsystem"	"CDEV";
	match "type"		"CREATE";
	match "cdev"		"ttyU[0-9]+";
	action "/sbin/init q";
};
....

Перезагрузите конфигурацию, если man:devd[8] уже запущен:

[source, shell]
....
# service devd restart
....

Убедитесь, что необходимые модули загружены, и правильный шаблон установлен при загрузке, добавив следующие строки в [.filename]#/boot/loader.conf#, создав его, если он ещё не существует:

[source, shell]
....
umodem_load="YES"
hw.usb.template=3
....

Для загрузки модуля и установки шаблона без перезагрузки используйте:

[source, shell]
....
# kldload umodem
# sysctl hw.usb.template=3
....

=== Подключение к последовательным портам в режиме USB-устройств из FreeBSD

Для подключения к плате, настроенной для предоставления последовательных портов в режиме USB-устройства, подключите USB-хост, например ноутбук, к USB OTG или клиентскому USB-порту платы. Используйте команду `pstat -t` на хосте для вывода списка терминальных линий. В конце списка должен отобразиться USB-последовательный порт, например "ttyU0". Для установки соединения используйте:

[source, shell]
....
# cu -l /dev/ttyU0
....

После нажатия клавиши kbd:[Enter] несколько раз вы увидите приглашение для входа в систему.

=== Подключение к последовательным портам в режиме USB-устройства из macOS

Для подключения к плате, настроенной для предоставления последовательных портов в режиме USB-устройства, подключите USB-хост, например ноутбук, к USB OTG или клиентскому USB-порту платы. Чтобы открыть соединение, используйте:

[source, shell]
....
# cu -l /dev/cu.usbmodemFreeBSD1
....

=== Подключение к последовательным портам в режиме USB-устройства из Linux

Для подключения к плате, настроенной для предоставления последовательных портов в режиме USB-устройства, подключите USB-хост, например ноутбук, к USB OTG или клиентскому USB-порту платы. Чтобы открыть соединение, используйте:

[source, shell]
....
# minicom -D /dev/ttyACM0
....

=== Подключение к последовательным портам в режиме USB-устройства из Microsoft Windows 10

Для подключения к плате, настроенной для предоставления последовательных портов в режиме USB-устройства, подключите USB-хост, например ноутбук, к USB OTG или клиентскому USB-порту платы. Чтобы открыть соединение, вам понадобится программа для работы с последовательным портом, например PuTTY. Для проверки имени COM-порта, используемого Windows, запустите Диспетчер устройств, раскройте раздел "Порты (COM и LPT)". Вы увидите имя, похожее на "USB Serial Device (COM4)". Запустите выбранную программу для работы с последовательным портом, например PuTTY. В диалоговом окне PuTTY установите "Connection type" в значение "Serial", введите COMx (полученный из Диспетчера устройств) в поле "Serial line" и нажмите "Open".

[[usb-device-mode-network]]
== Сетевые интерфейсы в режиме USB-устройства

Поддержка виртуальных сетевых интерфейсов обеспечивается шаблонами 1, 8 и 10. Обратите внимание, что ни один из них не работает с Microsoft Windows. Другие операционные системы хоста работают со всеми тремя шаблонами. Необходимо загрузить оба модуля ядра: man:usb_template[4] и man:if_cdce[4].

Убедитесь, что необходимые модули загружены, и правильный шаблон установлен при загрузке, добавив следующие строки в [.filename]#/boot/loader.conf#, создав его, если он ещё не существует:

[.programlisting]
....
if_cdce_load="YES"
hw.usb.template=1
....

Для загрузки модуля и установки шаблона без перезагрузки используйте:

[source, shell]
....
# kldload if_cdce
# sysctl hw.usb.template=1
....

[[usb-device-mode-storage]]
== Виртуальное устройство хранения данных USB

[NOTE]
====
Драйвер man:cfumass[4] — это драйвер режима USB-устройства, впервые появившийся в FreeBSD 12.0.
====

Целевое устройство хранения данных (Mass Storage) предоставляется шаблонами 0 и 10. Необходимо загрузить оба модуля ядра: man:usb_template[4] и man:cfumass[4]. Модуль man:cfumass[4] взаимодействует с подсистемой CTL, той же самой, что используется для целевых устройств iSCSI или Fibre Channel. Со стороны хоста инициаторы USB Mass Storage могут обращаться только к одному LUN — LUN 0.

=== Настройка USB-накопителя с использованием стартового скрипта cfumass

Самый простой способ настроить USB-накопитель только для чтения — использовать скрипт [.filename]#cfumass#. Для этого скопируйте файлы, которые должны быть доступны на USB-хосте, в директорию `/var/cfumass` и добавьте следующую строку в [.filename]#/etc/rc.conf#:

[.programlisting]
....
cfumass_enable="YES"
....

Для настройки цели без перезагрузки выполните следующую команду:

[source, shell]
....
# service cfumass start
....

В отличие от последовательных и сетевых функций, шаблон не следует устанавливать в 0 или 10 в [.filename]#/boot/loader.conf#. Это связано с тем, что LUN должен быть настроен до установки шаблона. Скрипт запуска cfumass автоматически устанавливает правильный номер шаблона при запуске.

=== Настройка USB-накопителей с использованием других методов

Оставшаяся часть этой главы содержит подробное описание настройки цели без использования файла `cfumass rc`. Это необходимо, например, если требуется предоставить доступную для записи LUN.

USB-накопитель не требует работы демона man:ctld[8], хотя его можно использовать при необходимости. Это отличается от iSCSI. Таким образом, есть два способа настройки цели: man:ctladm[8] или man:ctld[8]. Оба способа требуют загрузки модуля ядра [.filename]#cfumass.ko#. Модуль можно загрузить вручную:

[source, shell]
....
# kldload cfumass
....

Если модуль [.filename]#cfumass.ko# не встроен в ядро, можно настроить [.filename]#/boot/loader.conf# для его загрузки при старте системы:

[.programlisting]
....
cfumass_load="YES"
....

LUN может быть создан без использования демона man:ctld[8]:

[source, shell]
....
# ctladm create -b block -o file=/data/target0
....

Это предоставляет содержимое файла образа [.filename]#/data/target0# как LUN для USB-хоста. Файл должен существовать до выполнения команды. Чтобы настроить LUN при загрузке системы, добавьте команду в [.filename]#/etc/rc.local#.

man:ctld[8] также может использоваться для управления LUN. Создайте файл [.filename]#/etc/ctl.conf#, добавьте строку в [.filename]#/etc/rc.conf#, чтобы убедиться, что man:ctld[8] автоматически запускается при загрузке, а затем запустите демон.

Вот пример простого файла конфигурации [.filename]#/etc/ctl.conf#. Полное описание параметров можно найти в man:ctl.conf[5].

[.programlisting]
....
target naa.50015178f369f092 {
	lun 0 {
		path /data/target0
		size 4G
	}
}
....

Пример создает одну цель с одним LUN. `naa.50015178f369f092` — это идентификатор устройства, состоящий из 32 случайных шестнадцатеричных цифр. Строка `path` определяет полный путь к файлу или zvol, который используется для LUN. Этот файл должен существовать до запуска man:ctld[8]. Вторая строка необязательна и указывает размер LUN.

Чтобы убедиться, что демон man:ctld[8] запускается при загрузке, добавьте следующую строку в [.filename]#/etc/rc.conf#:

[.programlisting]
....
ctld_enable="YES"
....

Чтобы запустить man:ctld[8] сейчас, выполните следующую команду:

[source, shell]
....
# service ctld start
....

При запуске демона man:ctld[8] он читает файл [.filename]#/etc/ctl.conf#. Если этот файл отредактирован после запуска демона, перезагрузите изменения, чтобы они вступили в силу немедленно:

[source, shell]
....
# service ctld reload
....
