---
description: 'Флейворы — это способ создания нескольких вариаций порта'
next: books/porters-handbook/plist
params:
  path: /books/porters-handbook/flavors/
prev: books/porters-handbook/special
showBookMenu: true
tags: ["Ports", "Flavors", "introduction", "how-to", "guide"]
title: 'Глава 7. Флейворы'
weight: 7
---

[[flavors]]
= Флейворы
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 7
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/porters-handbook/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[flavors-intro]]
== Введение в флейворы (Flavors)

Флейворы (Flavors) — это способ создания нескольких вариаций порта. Порт собирается несколько раз с различными вариациями.

Например, порт может иметь обычную версию с множеством функций и значительным количеством зависимостей, а также облегчённую "lite"-версию только с базовыми функциями и минимальными зависимостями.

Еще одним примером может быть порт с вариантом GTK и вариантом QT, в зависимости от используемого набора инструментов.

[[flavors-using]]
== Использование FLAVORS

Чтобы объявить порт с несколькими флейворами, добавьте `FLAVORS` в его [.filename]#Makefile#. Первый вариант в `FLAVORS` является вариантом по умолчанию.

[TIP]
====
Это может помочь упростить логику [.filename]#Makefile#, также определив `FLAVOR` как:

[.programlisting]
....
FLAVOR?=	${FLAVORS:[1]}
....
====

[IMPORTANT]
====
Чтобы отличать флейворы от опций, которые всегда обозначаются заглавными буквами, названия флейворов могут содержать _только_ строчные буквы, цифры и символ подчёркивания `_`.
====

[[flavors-using-ex1]]
.Основы использования флейворов
[example]
====
Если порт имеет "облегченный" подчиненный порт (lite slave port), подчиненный порт можно удалить, а порт преобразовать во флейворы с помощью:

[.programlisting]
....
FLAVORS=	default lite
lite_PKGNAMESUFFIX=	-lite
[...]
.if ${FLAVOR:U} != lite
[enable non lite features]
.endif
....

====

[[flavors-using-ex2]]
.Еще один пример базового использования флейворов
[example]
====
Если порт имеет подчиненный порт `-nox11`, подчиненный порт можно удалить, а порт преобразовать в флейворы с помощью:

[.programlisting]
....
FLAVORS=	x11 nox11
FLAVOR?=	${FLAVORS:[1]}
nox11_PKGNAMESUFFIX=	-nox11
[...]
.if ${FLAVOR} == x11
[enable x11 features]
.endif
....

====

[[flavors-using-ex3]]
.Использование флейворов в более сложных примерах
[example]
====
Вот слегка отредактированный отрывок из того, что присутствует в пакете package:devel/libpeas[], порте, который использует crossref:flavors[flavors-auto-python,флейворы Python]. При стандартных версиях Python 2 и 3, а именно 2.7 и 3.6, он автоматически получит `FLAVORS=py27 py36`

[.programlisting]
....
USES=		gnome python
USE_PYTHON=	flavors 

.if ${FLAVOR:Upy27:Mpy2*} 
USE_GNOME=	pygobject3 

CONFIGURE_ARGS+=	--enable-python2 --disable-python3

BUILD_WRKSRC=	${WRKSRC}/loaders/python 
INSTALL_WRKSRC=	${WRKSRC}/loaders/python 
.else # py3*
USE_GNOME+=	py3gobject3 

CONFIGURE_ARGS+=	--disable-python2 --enable-python3 \
			ac_cv_path_PYTHON3_CONFIG=${LOCALBASE}/bin/python${PYTHON_VER}-config 

BUILD_WRKSRC=	${WRKSRC}/loaders/python3 
INSTALL_WRKSRC=	${WRKSRC}/loaders/python3 
.endif

py34_PLIST=	${.CURDIR}/pkg-plist-py3 
py35_PLIST=	${.CURDIR}/pkg-plist-py3 
py36_PLIST=	${.CURDIR}/pkg-plist-py3
....

Этот порт не использует `USE_PYTHON=distutils`, но всё равно требует флейворы Python. Чтобы избежать ошибки в man:make[1] из-за пустого значения `FLAVOR`, используйте `${FLAVOR:U}` в сравнениях строк вместо `${FLAVOR}`. Привязки Gnome Python gobject3 имеют два разных названия: pygobject3 для Python 2 и py3gobject3 для Python 3. Скрипт `configure` должен выполняться в [.filename]#${WRKSRC}#, но нас интересует только сборка и установка частей программного обеспечения для Python 2 или Python 3, поэтому установите базовые каталоги сборки и установки соответствующим образом. Подсказка о правильном пути к конфигурационному скрипту Python 3. Список упаковки отличается при сборке с Python 3. Поскольку есть три возможные версии Python 3, установите `PLIST` для всех трёх с помощью crossref:flavors[flavors-using-helpers, вспомогательные инструменты флейворов].
====

[[flavors-using-helpers]]
=== Вспомогательные инструменты для флейворов (Flavors Helpers)

Чтобы упростить написание [.filename]#Makefile#, существуют несколько вспомогательных инструментов (помощников) флейворов.

Этот список помощников установит их переменную:

* `__flavor___PKGNAMEPREFIX`
* `__flavor___PKGNAMESUFFIX`
* `__flavor___PLIST`
* `__flavor___DESCR`

Этот список помощников будет добавлен к их переменной:

* `__flavor___CONFLICTS`
* `__flavor___CONFLICTS_BUILD`
* `__flavor___CONFLICTS_INSTALL`
* `__flavor___PKG_DEPENDS`
* `__flavor___EXTRACT_DEPENDS`
* `__flavor___PATCH_DEPENDS`
* `__flavor___FETCH_DEPENDS`
* `__flavor___BUILD_DEPENDS`
* `__flavor___LIB_DEPENDS`
* `__flavor___RUN_DEPENDS`
* `__flavor___TEST_DEPENDS`

[[flavors-helpers-ex1]]
.Специфичный для флейвора `PKGNAME`
[example]
====
Поскольку все пакеты должны иметь уникальные имена, флейворы должны изменять их, используя `__flavor___PKGNAMEPREFIX` и `__flavor___PKGNAMESUFFIX`, что упрощает задачу:

[.programlisting]
....
FLAVORS=	normal lite
lite_PKGNAMESUFFIX=	-lite
....

====

[[flavors-auto-php]]
== `USES=php` и флейворы

При использовании crossref:uses[uses-php,`php`] с одним из этих аргументов: `phpize`, `ext`, `zend` или `pecl`, порт автоматически получит заполненный параметр `FLAVORS` с версиями PHP, которые он поддерживает.

[[flavors-auto-php-ex1]]
.Простое расширение `USES=php`
[example]
====
Это создаст пакет для всех поддерживаемых версий:

[.programlisting]
....
PORTNAME=	some-ext
PORTVERSION=	0.0.1
PKGNAMEPREFIX=	${PHP_PKGNAMEPREFIX}

USES=		php:ext
....

Это создаст пакет для всех поддерживаемых версий, кроме 7.2:

[.programlisting]
....
PORTNAME=	some-ext
PORTVERSION=	0.0.1
PKGNAMEPREFIX=	${PHP_PKGNAMEPREFIX}

USES=		php:ext
IGNORE_WITH_PHP=	72
....

====

[[flavors-auto-php-app]]
=== Версии PHP с приложениями PHP

Приложения PHP также могут быть созданы с использованием флейворов.

Это позволяет создавать пакеты для всех версий PHP, чтобы пользователи могли использовать их с любой необходимой версией на своих серверах.

[IMPORTANT]
====
Приложения PHP, которые используют флейворы, _обязаны_ добавлять `PHP_PKGNAMESUFFIX` к именам своих пакетов.
====

[[flavors-auto-php-app-ex1]]
.Добавление флейворов в PHP-приложения
[example]
====
Добавление поддержки флейворов в PHP-приложение просто:

[.programlisting]
....
PKGNAMESUFFIX=	${PHP_PKGNAMESUFFIX}

USES=	php:flavors
....

====

[TIP]
====
При добавлении зависимости к порту с вариантом PHP используйте `@${PHP_FLAVOR}`. _Никогда_ не используйте `FLAVOR` напрямую.
====

[[flavors-auto-python]]
== `USES=python` и флейворы

При использовании crossref:uses[uses-python,`python`] и `USE_PYTHON=distutils` порт автоматически получит заполненные `FLAVORS` с версиями Python, которые он поддерживает.

[[flavors-auto-python-ex1]]
.Простой `USES=python`
[example]
====
Предполагая, что поддерживаемые версии Python — 2.7, 3.4, 3.5 и 3.6, а версии Python 2 и 3 по умолчанию — 2.7 и 3.6, порт с параметрами:

[.programlisting]
....
USES=	python
USE_PYTHON=	distutils
....

получит следующие флейворы: `py27` и `py36`.

[.programlisting]
....
USES=	python
USE_PYTHON=	distutils allflavors
....

получит следующие флейворы: `py27`, `py34`, `py35` и `py36`.
====

[[flavors-auto-python-ex2]]
.`USES=python` с требованиями к версии
[example]
====
Предполагая, что поддерживаемые версии Python — 2.7, 3.4, 3.5 и 3.6, а версии Python 2 и 3 по умолчанию — 2.7 и 3.6, порт с параметрами:

[.programlisting]
....
USES=	python:-3.5
USE_PYTHON=	distutils
....

получит следующие флейвор: `py27`.

[.programlisting]
....
USES=	python:-3.5
USE_PYTHON=	distutils allflavors
....

получит следующие флейворы: `py27`, `py34` и `py35`.

[.programlisting]
....
USES=	python:3.4+
USE_PYTHON=	distutils
....

получит следующий флейвор: `py36`.

[.programlisting]
....
USES=	python:3.4+
USE_PYTHON=	distutils allflavors
....

получит следующие флейворы: `py34`, `py35` и `py36`.
====

`PY_FLAVOR` доступен для указания правильной версии модулей Python. Все зависимости от вариантов портов Python должны использовать `PY_FLAVOR`, а не `FLAVOR` напрямую.

[[flavors-auto-python-ex3]]
.Для порта, не использующего `distutils`
[example]
====
Если версия Python 3 по умолчанию — 3.6, следующая команда установит `PY_FLAVOR` в значение `py36`:

[.programlisting]
....
RUN_DEPENDS=	${PYTHON_PKGNAMEPREFIX}mutagen>0:audio/py-mutagen@${PY_FLAVOR}

USES=	python:3.5+
....

====

[[flavors-auto-lua]]
== `USES=lua` и флейворы

При использовании crossref:uses[uses-lua,`lua:module`] или crossref:uses[uses-lua,`lua:flavors`] порт автоматически получит заполненный параметр `FLAVORS` с версиями Lua, которые он поддерживает. Однако предполагается, что обычные приложения (а не модули Lua) не должны использовать эту возможность; большинству приложений, которые встраивают или иным образом используют Lua, следует просто указывать `USES=lua`.

`LUA_FLAVOR` доступен (и должен использоваться) для зависимости от правильной версии зависимостей, независимо от того, использовал ли порт параметры `flavors` или `module`.

См. crossref:special[using-lua,Использование Lua] для получения дополнительной информации.

[[flavors-auto-guile]]
== `USES=guile` и флейворы

При использовании crossref:uses[uses-guile,`guile:flavors`] порт автоматически получит заполненное поле `FLAVORS` с версиями Guile, которые он поддерживает. Однако не предполагается, что обычные приложения должны использовать эту возможность; она в первую очередь предназначена для библиотек и расширений, таких как `guile-lib` или `guile-cairo`.

`GUILE_FLAVOR` доступен (и должен использоваться) для зависимости от правильной версии зависимостей с флейворами, независимо от того, использовал ли порт параметр `flavors` или нет.

См. crossref:special[using-guile,Использование Guile] для получения дополнительной информации.
