---
description: 'FreeBSD предоставляет две взаимодополняющие технологии для установки стороннего программного обеспечения: коллекцию портов FreeBSD для установки из исходного кода и пакеты для установки из предварительно собранных бинарных файлов'
next: books/handbook/x11
params:
  path: /books/handbook/ports/
part: 'В начале'
prev: books/handbook/basics
showBookMenu: true
tags: ["ports", "collection", "pkg", "poudriere", "management"]
title: 'Глава 4. Установка приложений: Пакеты и Порты'
weight: 6
---

[[ports]]
= Установка приложений: пакеты и порты
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== Обзор

FreeBSD поставляется с богатым набором системных инструментов в составе базовой системы. Кроме того, FreeBSD предоставляет две дополнительные технологии для установки стороннего программного обеспечения: коллекцию портов FreeBSD для установки из исходных кодов и пакеты для установки из предварительно собранных бинарных файлов. Оба метода могут быть использованы для установки программного обеспечения как с локальных носителей, так и из сети.

Прочитав эту главу, вы будете знать:

* Разница между бинарными пакетами и портами.
* Как найти стороннее программное обеспечение, портированное на FreeBSD.
* Как управлять бинарными пакетами с помощью pkg.
* Как собрать стороннее программное обеспечение из исходных кодов с использованием Коллекции портов.
* Как найти файлы, установленные с приложением, для пост-установочной настройки.
* Что делать, если установка программного обеспечения не удалась.

[[ports-overview]]
== Обзор установки программного обеспечения

Порт FreeBSD — это набор файлов, предназначенных для автоматизации процесса компиляции приложения из исходного кода. Файлы, из которых состоит порт, содержат всю необходимую информацию для автоматической загрузки, распаковки, наложения исправлений, компиляции и установки приложения.

Если программное обеспечение ещё не адаптировано и не протестировано на FreeBSD, может потребоваться редактирование исходного кода для его правильной установки и работы.

Однако более link:https://ports.FreeBSD.org[{numports}] сторонних приложений уже портированы на FreeBSD. По возможности эти приложения доступны для загрузки в виде предварительно скомпилированных _пакетов_.

Пакетами можно управлять с помощью команд управления пакетами FreeBSD.

Как пакеты, так и порты учитывают зависимости. Если приложение устанавливается с помощью пакета или порта, а необходимая библиотека ещё не установлена, эта библиотека будет автоматически установлена первой.

Пакет FreeBSD содержит предварительно скомпилированные версии всех команд приложения, а также любые конфигурационные файлы и документацию. Пакетом можно управлять с помощью команд man:pkg[8], таких как `pkg install`.

Хотя эти две технологии схожи, пакеты и порты имеют свои сильные стороны. Выберите технологию, которая соответствует вашим требованиям для установки конкретного приложения.

.Преимущества пакетов
* Сжатый tar-архив пакета обычно меньше, чем сжатый tar-архив с исходным кодом приложения.
* Пакеты не требуют времени на компиляцию. Для больших приложений, таких как Firefox, KDE Plasma или GNOME, это может быть важно на медленной системе.
* Пакеты не требуют понимания процесса компиляции программного обеспечения в FreeBSD.

.Преимущества портов
* Пакеты обычно компилируются с консервативными параметрами, так как они должны работать на максимальном количестве систем. При компиляции из портов можно изменить параметры компиляции.
* Некоторые приложения имеют параметры на этапе компиляции, определяющие, какие функции будут установлены. Например, NGINX(R) можно настроить с широким набором различных встроенных опций.
+
В некоторых случаях для одного приложения могут существовать несколько пакетов с разными настройками. Например, NGINX(R) доступен в виде пакетов `nginx` и `nginx-lite`. Первый имеет гораздо больше включенных опций, но это, в свою очередь, требует установки множества зависимостей для его работы, что увеличивает занимаемое место и поверхность для атак.
+
Транзитивные зависимости могут стать довольно большими, например, полный пакет `nginx` потянет за собой несколько X-библиотек, что может оказаться неожиданным. Сборка из портов позволяет выбрать только нужные опции, избегая подхода «всё включено». В некоторых случаях для одного приложения могут существовать несколько пакетов с разными настройками.
* Условия лицензирования некоторых программных продуктов запрещают распространение в бинарном виде. Такое программное обеспечение должно распространяться в виде исходного кода, который конечный пользователь должен самостоятельно скомпилировать.
* Некоторые люди не доверяют бинарным дистрибутивам или предпочитают изучать исходный код, чтобы выявить потенциальные проблемы.
* Исходный код необходим для применения пользовательских исправлений.

Для отслеживания обновлений портов подпишитесь на рассылки {freebsd-ports} и {freebsd-ports-bugs}.

[WARNING]
====
Перед установкой приложения проверьте https://vuxml.freebsd.org/[] на наличие связанных проблем с безопасностью.

Для проверки установленных пакетов на наличие известных уязвимостей выполните команду `pkg audit -F`.
====

Оставшаяся часть этой главы объясняет, как использовать пакеты и порты для установки и управления сторонним программным обеспечением в FreeBSD.

[[ports-finding-applications]]
== Поиск программного обеспечения

Список доступных приложений для FreeBSD постоянно растет. Существует несколько способов найти программное обеспечение для установки:

* Веб-сайт FreeBSD содержит актуальный поисковый список всех доступных приложений на странице link:https://ports.FreeBSD.org[Портала портов]. Порты можно искать по названию приложения или по категории программного обеспечения.
* Дэн Лангилл поддерживает https://www.freshports.org/[FreshPorts], который предоставляет удобный поиск и отслеживает изменения в приложениях из коллекции портов. Зарегистрированные пользователи могут создать индивидуальный список наблюдения, чтобы получать автоматические уведомления по электронной почте при обновлении отслеживаемых портов.
* Если найти конкретное приложение становится сложно, попробуйте поискать на таких сайтах, как https://sourceforge.net/[SourceForge] или https://github.com/[GitHub], а затем проверьте ссылку link:https://ports.FreeBSD.org[Ports Portal], чтобы узнать, было ли это приложение портировано.
* Поиск репозитория бинарных пакетов для приложения с помощью команды man:pkg[8]

[[pkgng-intro]]
== Использование pkg для управления бинарными пакетами

man:pkg[8] предоставляет интерфейс для управления пакетами: регистрации, добавления, удаления и обновления пакетов.

Для сайтов, которые хотят использовать только предварительно собранные бинарные пакеты из зеркал FreeBSD, управления пакетами с помощью man:pkg[8] может быть достаточно.

Однако для сайтов, собирающих из исходного кода, потребуется отдельный crossref:ports[ports-upgrading-tools,инструмент управления портами].

Поскольку man:pkg[8] работает только с бинарными пакетами, он не является заменой таким инструментам. Эти инструменты можно использовать для установки программного обеспечения как из бинарных пакетов, так и из коллекции портов, тогда как man:pkg[8] устанавливает только бинарные пакеты.

[[pkgng-initial-setup]]
=== Начало работы с pkg

Все поддерживаемые версии FreeBSD теперь содержат `/usr/sbin/pkg`, также известный как man:pkg[7]. Это небольшая заглушка, которая обладает лишь минимальной функциональностью, необходимой для установки настоящего man:pkg[8].

[NOTE]
====
Для успешного завершения процесса начальной загрузки требуется рабочее подключение к Интернету.
====

Выполните команду man:pkg[8] из командной строки:

[source, shell]
....
# pkg
....

Вывод должен быть похож на следующий:

[.programlisting]
....
The package management tool is not yet installed on your system.
Do you want to fetch and install it now? [y/N]
....

man:pkg[7] перехватит команду, и если вы подтвердите своё намерение, загрузит tarball man:pkg[8], установит man:pkg[8] из него, инициализирует локальную базу данных пакетов, а затем выполнит изначально запрошенную команду.

Более новые версии man:pkg[7] поддерживают `pkg -N` для проверки, установлен ли man:pkg[8], без запуска процесса установки, и, наоборот, `pkg bootstrap[-f]` для установки man:pkg[8] (или принудительной переустановки) без выполнения других действий.

Информация по использованию pkg доступна на man:pkg[8] или при запуске `pkg` без дополнительных аргументов. Дополнительные параметры настройки pkg описаны в man:pkg.conf[5].

Каждый аргумент команды pkg документирован в соответствующем руководстве, специфичном для команды.

Чтобы прочитать справочную страницу для `pkg install`, например, выполните следующую команду:

[source, shell]
....
# pkg help install
....

Оставшаяся часть этого раздела демонстрирует распространённые задачи управления бинарными пакетами, которые можно выполнять с помощью man:pkg[8]. Каждая из представленных команд предоставляет множество ключей для настройки их использования. Подробности и дополнительные примеры смотрите в справке (help) или man-странице соответствующей команды.

[[quarterly-latest-branch]]
=== Квартальные и Последние Ветви Портов

Ветка `Quarterly` предоставляет пользователям более предсказуемый и стабильный опыт установки и обновления портов и пакетов. Это достигается за счёт того, что в неё вносятся только обновления, не связанные с добавлением новых функций. Ветки Quarterly получают исправления безопасности (которые могут включать обновления версий или обратные порты коммитов), исправления ошибок, а также изменения, связанные с соответствием портов или изменения в их инфраструктуре. Ветка Quarterly создаётся из HEAD в начале каждого квартала (года) в январе, апреле, июле и октябре. Ветки именуются в соответствии с годом (YYYY) и кварталом (Q1-4), в котором они созданы. Например, ветка quarterly, созданная в январе 2023 года, называется 2023Q1. А ветка `Latest` предоставляет пользователям самые последние версии пакетов.

Чтобы переключить man:pkg[8] с Quarterly на Latest, выполните следующие команды:

[source, shell]
....
# mkdir -p /usr/local/etc/pkg/repos
# echo 'FreeBSD: { url: "pkg+http://pkg.FreeBSD.org/${ABI}/latest" }' > /usr/local/etc/pkg/repos/FreeBSD.conf
....

Затем выполните эту команду, чтобы обновить каталоги локальных репозиториев пакетов для ветки Latest:

[source, shell]
....
# pkg update -f
....

[[kmod-repository]]
=== Репозитории модулей ядра

Репозитории модулей ядра позволяют пользователям устанавливать готовые к использованию модули, такие как драйверы графики и поддержка специфичного оборудования. Начиная с FreeBSD 14.3, проект FreeBSD предоставляет собранные модули ядра для каждой поддерживаемой версии. Чтобы создать конфигурацию такого репозитория (если она отсутствует), добавьте следующее в [.filename]#/usr/local/etc/pkg/repos/kmods.conf#:
[source, shell]
....
FreeBSD-kmods: {
        url: "pkg+https://pkg.FreeBSD.org/${ABI}/KMODSFLAVOR",
        mirror_type: "srv",
        signature_type: "fingerprints",
        fingerprints: "/usr/share/keys/pkg",
        enabled: yes
}
....

Переменная `KMODSFLAVOR` использует следующий шаблон именования: `kmods_PORTBRANCH_MINORRELEASE`.

Например:

.Kmodsflavor

[options="header", cols="1,1,1"]
|===
| Релиз FreeBSD | главные порты | квартальные порты

| FreeBSD 14.2-RELEASE
| kmods_latest_2
| kmods_quarterly_2

| FreeBSD 14.3-RELEASE
| kmods_latest_3
| kmods_quarterly_3

| FreeBSD 14.3-STABLE
| kmods_latest
| kmods_quarterly

| FreeBSD 15.0-CURRENT
| kmods_latest
| 
|===

[[pkg-configuration]]
=== Настройка pkg

man:pkg.conf[5] — это общесистемный конфигурационный файл, используемый утилитами man:pkg[8]. Стандартное расположение этого файла — `/usr/local/etc/pkg.conf`.

[NOTE]
====
FreeBSD не требует наличия файла `pkg.conf`. Многие установки будут работать без `pkg.conf` вообще или с пустым `pkg.conf` (за исключением строк с комментариями).
====

Строки в файле, начинающиеся с символа "#", являются комментариями и игнорируются.

Файл имеет формат UCL. Для получения дополнительной информации о синтаксисе man:libucl[3] посетите link:https://github.com/vstakhov/libucl[официальный сайт UCL].

Распознаются следующие типы опций - логические, строковые и списковые.

Логическая опция считается включённой, если в файле конфигурации указано одно из следующих значений: YES, TRUE или ON.

[[pkg-search]]
=== Поиск пакетов

Для поиска пакета можно использовать man:pkg-search[8]:

[source, shell]
....
# pkg search nginx
....

Вывод должен быть похож на следующий:

[.programlisting]
....
modsecurity3-nginx-1.0.3       Instruction detection and prevention engine / nginx Wrapper
nginx-1.22.1_2,3               Robust and small WWW server
nginx-devel-1.23.2_4           Robust and small WWW server
nginx-full-1.22.1_1,3          Robust and small WWW server (full package)
nginx-lite-1.22.1,3            Robust and small WWW server (lite package)
nginx-naxsi-1.22.1,3           Robust and small WWW server (plus NAXSI)
nginx-prometheus-exporter-0.10.0_7 Prometheus exporter for NGINX and NGINX Plus stats
nginx-ultimate-bad-bot-blocker-4.2020.03.2005_1 Nginx bad bot and other things blocker
nginx-vts-exporter-0.10.7_7    Server that scraps NGINX vts stats and export them via HTTP
p5-Nginx-ReadBody-0.07_1       Nginx embeded perl module to read and evaluate a request body
p5-Nginx-Simple-0.07_1         Perl 5 module for easy to use interface for Nginx Perl Module
p5-Test-Nginx-0.30             Testing modules for Nginx C module development
py39-certbot-nginx-2.0.0       NGINX plugin for Certbot
rubygem-passenger-nginx-6.0.15 Modules for running Ruby on Rails and Rack applications
....

[[pkg-installing-fetching]]
=== Установка и загрузка пакетов

Для установки бинарного пакета можно использовать man:pkg-install[8]. Эта команда использует данные репозитория для определения версии программного обеспечения, которую нужно установить, а также наличия неустановленных зависимостей. Например, для установки curl:

[source, shell]
....
# pkg install curl
....

Вывод должен быть похож на следующий:

[.programlisting]
....
Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following 9 package(s) will be affected (of 0 checked):

New packages to be INSTALLED:
        ca_root_nss: 3.83
        curl: 7.86.0
        gettext-runtime: 0.21
        indexinfo: 0.3.1
        libidn2: 2.3.3
        libnghttp2: 1.48.0
        libpsl: 0.21.1_4
        libssh2: 1.10.0.3
        libunistring: 1.0

Number of packages to be installed: 9

The process will require 11 MiB more space.
3 MiB to be downloaded

Proceed with this action? [y/N]
....

Новый пакет и любые дополнительные пакеты, установленные в качестве зависимостей, можно увидеть в списке установленных пакетов:

[source, shell]
....
# pkg info
....

Вывод должен быть похож на следующий:

[.programlisting]
....
ca_root_nss-3.83               Root certificate bundle from the Mozilla Project
curl-7.86.0                    Command line tool and library for transferring data with URLs
gettext-runtime-0.21.1         GNU gettext runtime libraries and programs
indexinfo-0.3.1                Utility to regenerate the GNU info page index
libidn2-2.3.3                  Implementation of IDNA2008 internationalized domain names
libnghttp2-1.48.0              HTTP/2.0 C Library
libpsl-0.21.1_6                C library to handle the Public Suffix List
libssh2-1.10.0.3               Library implementing the SSH2 protocol
libunistring-1.0               Unicode string library
pkg-1.18.4                     Package manager
....

Для загрузки пакета с последующей установкой позже или в другом месте используйте man:pkg-fetch[8]. Например, чтобы скачать `nginx-lite`:

[source, shell]
....
# pkg fetch -d -o /usr/home/user/packages/ nginx-lite
....

* `-d`: используется для получения всех зависимостей
* `-o`: используется для указания каталога загрузки

Вывод должен быть похож на следующий:

[.programlisting]
....
Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following packages will be fetched:

New packages to be FETCHED:
        nginx-lite: 1.22.1,3 (342 KiB: 22.20% of the 2 MiB to download)
        pcre: 8.45_3 (1 MiB: 77.80% of the 2 MiB to download)

Number of packages to be fetched: 2

The process will require 2 MiB more space.
2 MiB to be downloaded.

Proceed with fetching packages? [y/N]:
....

Для установки загруженных пакетов можно использовать man:pkg-install[8] следующим образом:

[source, shell]
....
# cd /usr/home/user/packages/
....

[source, shell]
....
# pkg install nginx-lite-1.22.1,3.pkg
....

[[pkgng-pkg-info]]
=== Получение информации об установленных пакетах

Информацию об установленных в системе пакетах можно просмотреть с помощью команды man:pkg-info[8], которая при запуске без каких-либо параметров выводит версию пакета для всех установленных пакетов или указанного пакета.

Например, чтобы узнать, какая версия pkg установлена, выполните:

[source, shell]
....
# pkg info pkg
....

Вывод должен быть похож на следующий:

[.programlisting]
....
pkg-1.19.0
Name           : pkg
Version        : 1.19.0
Installed on   : Sat Dec 17 11:05:28 2022 CET
Origin         : ports-mgmt/pkg
Architecture   : FreeBSD:13:amd64
Prefix         : /usr/local
Categories     : ports-mgmt
Licenses       : BSD2CLAUSE
Maintainer     : pkg@FreeBSD.org
WWW            : https://github.com/freebsd/pkg
Comment        : Package manager
Options        :
        DOCS           : on
Shared Libs provided:
        libpkg.so.4
Annotations    :
        FreeBSD_version: 1301000
        repo_type      : binary
        repository     : FreeBSD
Flat size      : 33.2MiB
Description    :
Package management tool

WWW: https://github.com/freebsd/pkg
....

[[pkgng-upgrading]]
=== Обновление установленных пакетов

Установленные пакеты можно обновить до их последних версий с помощью man:pkg-upgrade[8]:

[source, shell]
....
# pkg upgrade
....

Эта команда сравнит установленные версии с доступными в каталоге репозитория и обновит их из репозитория.

[[pkgng-auditing]]
=== Проверка установленных пакетов

Уязвимости в программном обеспечении регулярно обнаруживаются в сторонних приложениях. Для решения этой проблемы pkg включает встроенный механизм аудита. Чтобы определить, есть ли известные уязвимости для программного обеспечения, установленного в системе, используйте man:pkg-audit[8]:

[source, shell]
....
# pkg audit -F
....

Вывод должен быть похож на следующий:

[.programlisting]
....
Fetching vuln.xml.xz: 100%  976 KiB 499.5kB/s    00:02
chromium-108.0.5359.98 is vulnerable:
  chromium -- multiple vulnerabilities
  CVE: CVE-2022-4440
  CVE: CVE-2022-4439
  CVE: CVE-2022-4438
  CVE: CVE-2022-4437
  CVE: CVE-2022-4436
  WWW: https://vuxml.FreeBSD.org/freebsd/83eb9374-7b97-11ed-be8f-3065ec8fd3ec.html
....

[[pkg-delete]]
=== Удаление пакетов

Пакеты, которые больше не нужны, можно удалить с помощью man:pkg-delete[8].

Например:

[source, shell]
....
# pkg delete curl
....

Вывод должен быть похож на следующий:

[.programlisting]
....
Checking integrity... done (0 conflicting)
Deinstallation has been requested for the following 1 packages (of 0 packages in the universe):

Installed packages to be REMOVED:
        curl :7.86.0

Number of packages to be removed: 1

The operation will free 4 MiB.

Proceed with deinstallation packages? [y/N]: y
[1/1] Deinstalling curl-7.86.0...
[1/1] Deleting files for curl-7.86.0: 100%
....

[[pkgng-autoremove]]
=== Автоматическое удаление неиспользуемых пакетов

Удаление пакета может оставить зависимости, которые больше не требуются. Ненужные пакеты, установленные как зависимости (листовые пакеты), могут быть автоматически обнаружены и удалены с помощью man:pkg-autoremove[8]:

[source, shell]
....
# pkg autoremove
....

Вывод должен быть похож на следующий:

[.programlisting]
....
Checking integrity... done (0 conflicting)
Deinstallation has been requested for the following 1 packages:

Installed packages to be REMOVED:
        ca_root_nss-3.83

Number of packages to be removed: 1

The operation will free 723 KiB.

Proceed with deinstalling packages? [y/N]:
....

Установленные в качестве зависимостей пакеты называются _автоматическими_ пакетами. Неавтоматические пакеты, то есть пакеты, которые были явно установлены не в качестве зависимости для другого пакета, можно вывести с помощью:

[source, shell]
....
# pkg prime-list
....

Вывод должен быть похож на следующий:

[.programlisting]
....
nginx
openvpn
sudo
....

`pkg prime-list` — это псевдоним команды, объявленный в `/usr/local/etc/pkg.conf`. Существует множество других команд, которые можно использовать для запросов к базе данных пакетов системы. Например, команда `pkg prime-origins` позволяет получить каталог портов происхождения для упомянутого выше списка:

[source, shell]
....
# pkg prime-origins
....

Вывод должен быть похож на следующий:

[.programlisting]
....
www/nginx
security/openvpn
security/sudo
....

Этот список можно использовать для пересборки всех пакетов, установленных в системе, с помощью инструментов сборки, таких как package:ports-mgmt/poudriere[] или package:ports-mgmt/synth[].

Пометить установленный пакет как автоматический можно с помощью:

[source, shell]
....
# pkg set -A 1 devel/cmake
....

Как только пакет становится листовым и помечается как автоматический, он выбирается командой `pkg autoremove`.

Пометить установленный пакет как _не_ автоматический можно с помощью:

[source, shell]
....
# pkg set -A 0 devel/cmake
....

[[pkgng-clean]]
=== Удаление устаревших пакетов

По умолчанию pkg хранит бинарные пакеты в кэш-каталоге, определённом параметром `PKG_CACHEDIR` в man:pkg.conf[5]. Сохраняются только копии последних установленных пакетов. В более старых версиях pkg сохранялись все предыдущие пакеты. Чтобы удалить устаревшие бинарные пакеты, выполните:

[source, shell]
....
# pkg clean
....

Весь кэш может быть очищен выполнением команды:

[source, shell]
....
# pkg clean -a
....

[[pkg-locking-unlocking]]
=== Блокировка и разблокировка пакетов

man:pkg-lock[8] используется для блокировки пакетов от переустановки, изменения или удаления. man:pkg-unlock[8] разблокирует указанные пакеты. Оба варианта влияют только на уже установленные пакеты. Следовательно, невозможно предотвратить установку нового пакета с помощью этого механизма, за исключением случаев, когда такая установка подразумевает обновление заблокированного пакета.

Например, чтобы заблокировать `nginx-lite`:

[source, shell]
....
# pkg lock nginx-lite
....

И чтобы разблокировать `nginx-lite`:

[source, shell]
....
# pkg unlock nginx-lite
....

[[pkgng-set]]
=== Изменение метаданных пакета

Программное обеспечение в коллекции портов FreeBSD может подвергаться изменениям основных номеров версий. Для решения этой проблемы в pkg есть встроенная команда для обновления происхождения пакетов. Это может быть полезно, например, если package:lang/python3[] переименован в package:lang/python311[], чтобы package:lang/python3[] теперь мог представлять версию `3.11`.

Чтобы изменить источник пакета для приведенного выше примера, выполните:

[source, shell]
....
# pkg set -o lang/python3:lang/python311
....

В качестве другого примера, чтобы обновить package:lang/ruby31[] до package:lang/ruby32[], выполните:

[source, shell]
....
# pkg set -o lang/ruby31:lang/ruby32
....

[NOTE]
====
При изменении происхождения пакетов важно переустановить пакеты, зависящие от пакета с изменённым происхождением. Для принудительной переустановки зависимых пакетов выполните:

[source, shell]
....
# pkg install -Rf lang/ruby32
....
====

[[ports-using]]
== Использование коллекции портов

Коллекция портов — это набор `Makefile`-файлов, патчей и описаний. Каждый такой набор файлов используется для сборки и установки отдельного приложения в FreeBSD и называется _портом_.

По умолчанию Коллекция портов хранится в подкаталоге `/usr/ports`.

[WARNING]
====
Прежде чем устанавливать и использовать Коллекцию портов, учтите, что обычно не рекомендуется использовать Коллекцию портов вместе с бинарными пакетами, предоставляемыми через pkg, для установки программного обеспечения. По умолчанию pkg отслеживает квартальные ветки-релизы дерева портов, а не HEAD. Зависимости для порта в HEAD могут отличаться от его аналога в квартальном релизе ветки, что может привести к конфликтам между зависимостями, установленными pkg, и теми, что из Коллекции портов. Если необходимо использовать Коллекцию портов и pkg вместе, убедитесь, что ваша Коллекция портов и pkg находятся на одной ветке релиза дерева портов.
====

Коллекция портов содержит каталоги для категорий программного обеспечения. В каждой категории находятся подкаталоги для отдельных приложений. Каждый подкаталог приложения содержит набор файлов, которые сообщают FreeBSD, как компилировать и устанавливать эту программу, называемый _каркасом порта_ (ports skeleton). Каждый каркас порта включает следующие файлы и каталоги:

* *Makefile*: contains statements that specify how the application should be compiled and where its components should be installed.
* *distinfo*: contains the names and checksums of the files that must be downloaded to build the port.
* *files/*: this directory contains any patches needed for the program to compile and install on FreeBSD. This directory may also contain other files used to build the port.
* *pkg-descr*: provides a more detailed description of the program.
* *pkg-plist*: a list of all the files that will be installed by the port. It also tells the ports system which files to remove upon deinstallation.

Некоторые порты включают файлы `pkg-message` или другие для обработки особых ситуаций. Для получения более подробной информации об этих файлах и о портах в целом обратитесь к extref:{porters-handbook}[Руководству по созданию портов FreeBSD].

Порт не включает в себя исходный код, также известный как `distfile`. Этап извлечения при сборке порта автоматически сохраняет загруженные исходные файлы в `/usr/ports/distfiles`.

[[ports-using-installation-methods]]
=== Установка коллекции портов

Прежде чем приложение можно будет скомпилировать с использованием порта, необходимо установить Коллекцию портов. Если она не была установлена во время установки FreeBSD, используйте следующий метод для её установки:

[[ports-using-git-method]]
[.procedure]
****
*Procedure: Git Method*

Если требуется больше контроля над деревом портов или необходимо поддерживать локальные изменения, либо если используется FreeBSD-CURRENT, для получения коллекции портов можно использовать Git. Подробное описание Git см. в extref:{committers-guide}[руководстве по Git, git-primer].

Добавляем `--depth 1` в командную строку `git`, чтобы клонировать дерево без получения истории коммитов, что экономит время и приемлемо для большинства пользователей. Если у вас есть собственные изменения в дереве портов или вам нужна история по какой-либо причине, опустите аргумент `--depth 1` ниже.

. Git должен быть установлен перед тем, как его можно будет использовать для получения дерева портов. Если копия дерева портов уже существует, установите Git следующим образом:
+
[source, shell]
....
# cd /usr/ports/devel/git
# make install clean
....
+
Если дерево портов недоступно или для управления пакетами используется pkg, Git можно установить как пакет:
+
[source, shell]
....
# pkg install git
....
+
. Извлеките копию ветки HEAD дерева портов:
+
[source, shell]
....
# git clone --depth 1 https://git.FreeBSD.org/ports.git /usr/ports
....
+
. Или склонируйте копию квартальной ветки:
+
[source, shell]
....
# git clone --depth 1 https://git.FreeBSD.org/ports.git -b 2023Q1 /usr/ports
....
+
. По мере необходимости обновите `/usr/ports` после первоначального получения из Git:
+
[source, shell]
....
# git -C /usr/ports pull
....
+
. По мере необходимости переключите `/usr/ports` на другую квартальную ветку:
+
[source, shell]
....
# git -C /usr/ports switch 2023Q1
....
****

=== Установка портов

Этот раздел содержит основные инструкции по использованию коллекции портов для установки или удаления программного обеспечения. Подробное описание доступных целей `make` и переменных окружения доступно в man:ports[7].

[WARNING]
====

Прежде чем компилировать любой порт, обязательно обновите коллекцию портов, как описано в предыдущем разделе. Поскольку установка любого стороннего программного обеспечения может привести к уязвимостям в безопасности, рекомендуется сначала проверить https://vuxml.freebsd.org/[] на наличие известных проблем безопасности, связанных с портом. Альтернативно, выполните `pkg audit -F` перед установкой нового порта. Эта команда может быть настроена для автоматической проверки безопасности и обновления базы данных уязвимостей в ходе ежедневной проверки безопасности системы. Для получения дополнительной информации обратитесь к man:pkg-audit[8] и man:periodic[8].
====

Использование коллекции портов предполагает наличие работающего подключения к Интернету. Также требуются права суперпользователя.

Для компиляции и установки порта перейдите в каталог порта, который нужно установить, затем введите `make install` в командной строке. Сообщения будут отображать прогресс:

[source, shell]
....
# cd /usr/ports/sysutils/lsof
# make install
>> lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.88
...
[extraction output snipped]
...
>> Checksum OK for lsof_4.88D.freebsd.tar.gz.
===>  Patching for lsof-4.88.d,8
===>  Applying FreeBSD patches for lsof-4.88.d,8
===>  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===>  Building for lsof-4.88.d,8
...
[compilation output snipped]
...

===>  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.88.d,8
===>   Registering installation for lsof-4.88.d,8
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#
....

Поскольку `lsof` — это программа, работающая с повышенными привилегиями, при её установке отображается предупреждение системы безопасности. После завершения установки будет возвращена командная строка.

Некоторые оболочки сохраняют кэш команд, доступных в каталогах, перечисленных в переменной окружения `PATH`, чтобы ускорить поиск исполняемых файлов этих команд. Пользователи оболочки `tcsh` должны ввести `rehash`, чтобы новоустановленная команда могла использоваться без указания полного пути. Для оболочки `sh` используйте `hash -r`. Дополнительную информацию можно найти в документации по используемой оболочке.

Во время установки создается рабочий подкаталог, содержащий все временные файлы, используемые при компиляции. Удаление этого каталога позволяет сэкономить место на диске и снижает вероятность возникновения проблем в дальнейшем при обновлении до более новой версии порта:

[source, shell]
....
# make clean
===>  Cleaning for lsof-88.d,8
#
....

[NOTE]
====
Чтобы избежать этого дополнительного шага, используйте `make install clean` при компиляции порта.
====

==== Настройка установки портов

Некоторые порты предоставляют опции сборки, которые можно использовать для включения или отключения компонентов приложения, обеспечения параметров безопасности или других настроек. Примеры включают package:www/firefox[] и package:security/gpgme[]. Если порт зависит от других портов с настраиваемыми опциями, процесс может несколько раз приостанавливаться для взаимодействия с пользователем, так как по умолчанию предлагается выбрать опции из меню. Чтобы избежать этого и выполнить всю настройку одной командой, выполните `make config-recursive` в каталоге порта. Затем выполните `make install [clean]` для компиляции и установки порта.

[TIP]
====
При использовании `config-recursive` список портов для настройки собирается с помощью цели `all-depends-list`. Рекомендуется выполнять `make config-recursive` до тех пор, пока не будут определены все параметры зависимых портов и экраны выбора опций портов больше не появляются, чтобы убедиться, что все параметры зависимостей настроены.
====

Существует несколько способов вернуться к меню настроек сборки порта, чтобы добавить, удалить или изменить параметры после того, как порт уже был собран. Один из методов — перейти в каталог с портом с помощью `cd` и ввести `make config`. Другой вариант — использовать `make showconfig`. Также можно выполнить `make rmconfig`, что удалит все выбранные параметры и позволит начать заново. Все эти и другие варианты подробно описаны в man:ports[7].

Система портов использует man:fetch[1] для загрузки исходных файлов, которая поддерживает различные переменные окружения. Переменные `FTP_PASSIVE_MODE`, `FTP_PROXY` и `FTP_PASSWORD` может потребоваться установить, если система FreeBSD находится за межсетевым экраном или FTP/HTTP прокси. Полный список поддерживаемых переменных смотрите в man:fetch[3].

Для пользователей, которые не могут быть постоянно подключены к интернету, команда `make fetch` может быть выполнена в `/usr/ports`, чтобы загрузить все distfiles, или в категории, например `/usr/ports/net`, или в конкретном скелете порта. Обратите внимание, что если порт имеет зависимости, выполнение этой команды в категории или скелете порта _не_ загрузит distfiles портов из другой категории. Вместо этого используйте `make fetch-recursive`, чтобы также загрузить distfiles для всех зависимостей порта.

В редких случаях, например, когда у организации есть локальный репозиторий distfiles, переменная `MASTER_SITES` может быть использована для переопределения мест загрузки, указанных в `Makefile`. При использовании укажите альтернативное расположение:

[source, shell]
....
# cd /usr/ports/directory
# make MASTER_SITE_OVERRIDE= \
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch
....

Переменные `WRKDIRPREFIX` и `PREFIX` позволяют переопределить рабочий и целевой каталоги по умолчанию. Например:

[source, shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

соберет порт в `/usr/home/example/ports` и установит все в `/usr/local`.

[source, shell]
....
# make PREFIX=/usr/home/example/local install
....

скомпилирует порт в `/usr/ports` и установит его в `/usr/home/example/local`. И:

[source, shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

объединит эти два.

Эти параметры также могут быть установлены как переменные среды. Обратитесь к руководству вашей оболочки для получения инструкций по установке переменных среды.

[[ports-removing]]
=== Удаление установленных портов

Установленные порты можно удалить с помощью `pkg delete`. Примеры использования этой команды приведены на man:pkg-delete[8].

Альтернативно, в каталоге порта можно выполнить `make deinstall`:

[source, shell]
....
# cd /usr/ports/sysutils/lsof
# make deinstall
===>  Deinstalling for sysutils/lsof
===>   Deinstalling
Deinstallation has been requested for the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done
....

Рекомендуется прочитать сообщения во время удаления порта. Если у порта есть приложения, которые от него зависят, эта информация будет отображена, но удаление продолжится. В таких случаях может быть лучше переустановить приложение, чтобы избежать нарушенных зависимостей.

[[ports-upgrading]]
=== Обновление портов

Со временем в Коллекции портов становятся доступны новые версии программного обеспечения. В этом разделе описано, как определить, какие программы можно обновить, и как выполнить обновление.

Чтобы определить, доступны ли более новые версии установленных портов, убедитесь, что у вас установлена последняя версия дерева портов, используя команду обновления, описанную в crossref:ports[ports-using-git-method, "Git Method"]. Следующая команда выведет список устаревших установленных портов:

[source, shell]
....
# pkg version -l "<"
....

[IMPORTANT]
====
Перед попыткой обновления прочитайте файл `/usr/ports/UPDATING` с начала до даты, наиболее близкой к последнему обновлению портов или установке системы. Этот файл описывает различные проблемы и дополнительные шаги, с которыми могут столкнуться пользователи при обновлении портов, включая такие вещи, как изменения форматов файлов, перемещение конфигурационных файлов или несовместимость с предыдущими версиями. Отметьте все инструкции, относящиеся к портам, которые требуют обновления, и следуйте этим инструкциям при выполнении обновления.
====

[[ports-upgrading-tools]]
==== Инструменты для обновления и управления портами

Коллекция портов содержит несколько утилит для выполнения обновления. У каждой есть свои сильные и слабые стороны.

Исторически большинство установок использовали либо Portmaster, либо Portupgrade. Synth — это более современная альтернатива.

[NOTE]
====
Выбор наилучшего инструмента для конкретной системы остается за системным администратором. Рекомендуется создать резервную копию данных перед использованием любого из этих инструментов.
====

[[portmaster]]
==== Обновление портов с помощью Portmaster

package:ports-mgmt/portmaster[] — это очень небольшая утилита для обновления установленных портов. Она предназначена для использования инструментов, установленных в базовой системе FreeBSD, без зависимости от других портов или баз данных. Чтобы установить эту утилиту как порт:

[source, shell]
....
# cd /usr/ports/ports-mgmt/portmaster
# make install clean
....

Portmaster определяет четыре категории портов:

* Корневой порт (root port): не имеет зависимостей и сам не является зависимостью для других портов.
* Ствольный порт (trunk port): не имеет зависимостей, но другие порты зависят от него.
* Веточный порт (branch port): имеет зависимости и другие порты зависят от него.
* Листовой порт (leaf port): имеет зависимости, но другие порты от него не зависят.

Чтобы перечислить эти категории и найти обновления:

[source, shell]
....
# portmaster -L
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache22-2.2.3
        ===>>> New version available: apache22-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
....

Эта команда используется для обновления всех устаревших портов:

[source, shell]
....
# portmaster -a
....

[NOTE]
====
По умолчанию Portmaster создаёт резервную копию пакета перед удалением существующего порта. Если установка новой версии проходит успешно, Portmaster удаляет резервную копию. Использование опции `-b` указывает Portmaster не удалять резервную копию автоматически. Добавление опции `-i` запускает Portmaster в интерактивном режиме, запрашивая подтверждение перед обновлением каждого порта. Доступно множество других опций. Подробности об их использовании можно узнать на man-странице man:portmaster[8].
====

Если в процессе обновления возникают ошибки, добавьте `-f` для обновления и пересборки всех портов:

[source, shell]
....
# portmaster -af
....

Portmaster также может использоваться для установки новых портов в системе, обновляя все зависимости перед сборкой и установкой нового порта. Чтобы использовать эту функцию, укажите расположение порта в коллекции портов:

[source, shell]
....
# portmaster shells/bash
....

Дополнительную информацию о package:ports-mgmt/portmaster[] можно найти в его `pkg-descr`.

[[portupgrade]]
==== Обновление портов с помощью Portupgrade

[WARNING]
====
Portupgrade устарел и будет удален в ближайшем будущем.
====


package:ports-mgmt/portupgrade[] — это ещё одна утилита, которую можно использовать для обновления портов. Она устанавливает набор приложений для управления портами. Однако она зависит от Ruby. Для установки порта выполните:

[source, shell]
....
# cd /usr/ports/ports-mgmt/portupgrade
# make install clean
....

Прежде чем выполнять обновление с помощью этой утилиты, рекомендуется проверить список установленных портов с помощью `pkgdb -F` и исправить все обнаруженные несоответствия.

Для обновления всех устаревших портов, установленных в системе, используйте `portupgrade -a`. Альтернативно, добавьте `-i` для запроса подтверждения каждого обновления:

[source, shell]
....
# portupgrade -ai
....

Для обновления только указанного приложения вместо всех доступных портов используйте `portupgrade _pkgname_`. Очень важно включить опцию `-R`, чтобы сначала обновить все порты, необходимые для данного приложения:

[source, shell]
....
# portupgrade -R firefox
....

Если указан `-P`, Portupgrade ищет доступные пакеты в локальных каталогах, перечисленных в `PKG_PATH`. Если локально пакеты не найдены, он загружает их с удалённого сайта. Если пакеты не могут быть найдены локально или загружены удалённо, Portupgrade использует порты. Чтобы полностью избежать использования портов, укажите `-PP`. Последний набор опций предписывает Portupgrade прервать работу, если пакеты недоступны:

[source, shell]
....
# portupgrade -PP gnome3
....

Чтобы только загрузить distfiles портов или пакеты (если указан `-P`), без сборки или установки, используйте `-F`. Для получения дополнительной информации о всех доступных опциях обратитесь к руководству `portupgrade`.

Дополнительную информацию о package:ports-mgmt/portupgrade[] можно найти в его `pkg-descr`.

[[ports-disk-space]]
=== Порты и дисковое пространство

Использование коллекции портов со временем приводит к расходу дискового пространства. После сборки и установки порта выполнение команды `make clean` в скелете порта очистит временный каталог `work`. При использовании Portmaster для установки порта этот каталог будет удалён автоматически, если не указан параметр `-K`. Если установлен Portupgrade, следующая команда удалит все каталоги `work` в локальной копии коллекции портов:

[source, shell]
....
# portsclean -C
....

Кроме того, устаревшие файлы исходных дистрибутивов со временем накапливаются в `/usr/ports/distfiles`. Чтобы использовать Portupgrade для удаления всех distfiles, на которые больше нет ссылок из портов:

[source, shell]
....
# portsclean -D
....

Portupgrade может удалить все distfiles, на которые нет ссылок из портов, установленных в системе:

[source, shell]
....
# portsclean -DD
....

Если установлен Portmaster, используйте:

[source, shell]
....
# portmaster --clean-distfiles
....

По умолчанию эта команда интерактивна и запрашивает подтверждение пользователя на удаление distfile.

В дополнение к этим командам, package:ports-mgmt/pkg_cutleaves[] автоматизирует задачу удаления установленных портов, которые больше не нужны.

[[ports-poudriere]]
== Сборка пакетов с poudriere

poudriere — это утилита с лицензией `BSD` для создания и тестирования пакетов FreeBSD. Она использует механизм jail в FreeBSD для настройки изолированных сред сборки. Эти jail могут использоваться для сборки пакетов для версий FreeBSD, отличных от версии системы, на которой установлена poudriere, а также для сборки пакетов под i386 на хосте с архитектурой amd64. После сборки пакеты располагаются в структуре, идентичной официальным зеркалам. Эти пакеты могут использоваться man:pkg[8] и другими инструментами управления пакетами.

poudriere устанавливается с помощью пакета package:ports-mgmt/poudriere[] или порта. Установка включает пример файла конфигурации `/usr/local/etc/poudriere.conf.sample`. Скопируйте этот файл в `/usr/local/etc/poudriere.conf`. Отредактируйте скопированный файл в соответствии с локальной конфигурацией.

Хотя `ZFS` не является обязательным для системы, на которой запущен poudriere, его использование дает преимущества. При использовании `ZFS` необходимо указать `ZPOOL` в `/usr/local/etc/poudriere.conf`, а `FREEBSD_HOST` следует установить на ближайшее зеркало. Определение `CCACHE_DIR` позволяет использовать package:devel/ccache[] для кэширования компиляции и сокращения времени сборки часто компилируемого кода. Может быть удобно разместить наборы данных poudriere в изолированном дереве, смонтированном в `/poudriere`. Значения по умолчанию для остальных параметров конфигурации являются приемлемыми.

Количество обнаруженных ядер процессора определяет, сколько сборок будет выполняться параллельно. Обеспечьте достаточный объем виртуальной памяти, используя `RAM` или файл подкачки. Если виртуальная память закончится, компиляционные окружения остановятся и будут уничтожены, что приведёт к странным сообщениям об ошибках.

[[poudriere-initialization]]
=== Инициализация Jail и дерева портов

После настройки инициализируйте poudriere, чтобы он установил jail с требуемым деревом FreeBSD и деревом портов. Укажите имя для jail с помощью `-j`, а версию FreeBSD — с помощью `-v`. На системах под управлением FreeBSD/amd64 архитектуру можно задать с помощью `-a`, указав `i386` или `amd64`. По умолчанию используется архитектура, отображаемая командой `uname`.

[source, shell]
....
# poudriere jail -c -j 13amd64 -v 13.1-RELEASE
[00:00:00] Creating 13amd64 fs at /poudriere/jails/13amd64... done
[00:00:00] Using pre-distributed MANIFEST for FreeBSD 13.1-RELEASE amd64
[00:00:00] Fetching base for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/base.txz              125 MB 4110 kBps    31s
[00:00:33] Extracting base... done
[00:00:54] Fetching src for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/src.txz               154 MB 4178 kBps    38s
[00:01:33] Extracting src... done
[00:02:31] Fetching lib32 for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
[00:02:38] Extracting lib32... done
[00:02:42] Cleaning up... done
[00:02:42] Recording filesystem state for clean... done
[00:02:42] Upgrading using ftp
/etc/resolv.conf -> /poudriere/jails/13amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... done.
Fetching metadata signature for 13.1-RELEASE from update4.freebsd.org... done.
Fetching metadata index... done.
Fetching 2 metadata files... done.
Inspecting system... done.
Preparing to download files... done.
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. done.
Applying patches... done.
Fetching 6 files... done.
The following files will be added as part of updating to
13.1-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
13.1-RELEASE-p1:
[…]
Installing updates...Scanning //usr/share/certs/blacklisted for certificates...
Scanning //usr/share/certs/trusted for certificates...
 done.
13.1-RELEASE-p1
[00:04:06] Recording filesystem state for clean... done
[00:04:07] Jail 13amd64 13.1-RELEASE-p1 amd64 is ready to be used
....

[source, shell]
....
# poudriere ports -c -p local -m git+https
[00:00:00] Creating local fs at /poudriere/ports/local... done
[00:00:00] Checking out the ports tree... done
....

На одном компьютере poudriere может собирать порты с различными конфигурациями, в нескольких jail и из разных деревьев портов. Пользовательские конфигурации для таких комбинаций называются _наборами_. Подробности смотрите в разделе CUSTOMIZATION руководства man:poudriere[8] после установки package:ports-mgmt/poudriere[] или package:ports-mgmt/poudriere-devel[].

Базовая конфигурация, представленная здесь, размещает отдельные файлы `make.conf` для каждого jail, порта и набора в `/usr/local/etc/poudriere.d`. Имя файла в этом примере формируется путем объединения имени jail, имени порта и имени набора: `13amd64-local-workstation-make.conf`. Системный `make.conf` и этот новый файл объединяются во время сборки, чтобы создать `make.conf`, используемый build jail.

Пакеты для сборки указываются в файле `13amd64-local-workstation-pkglist` (для портов с extref:{porters-handbook}flavors[FLAVORS] можно указать @FLAVOR):

[.programlisting]
....
editors/emacs
devel/git
devel/php-composer2@php82
ports-mgmt/pkg
...
....

Настраиваются параметры и зависимости для указанных портов:

[source, shell]
....
# poudriere options -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist
....

Наконец, пакеты собираются и создается репозиторий пакетов:

[source, shell]
....
# poudriere bulk -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist
....

Во время работы нажатие kbd:[Ctrl+t] отображает текущее состояние сборки. poudriere также создает файлы в `/poudriere/logs/bulk/jailname`, которые можно использовать с веб-сервером для отображения информации о сборке.

По завершении новые пакеты становятся доступными для установки из репозитория poudriere.

Для получения дополнительной информации об использовании poudriere см. man:poudriere[8] и основной веб-сайт: https://github.com/freebsd/poudriere/wiki[].

=== Настройка клиентов pkg для использования репозитория poudriere

Хотя можно использовать как пользовательский репозиторий вместе с официальным, иногда полезно отключить официальный репозиторий. Это делается путём создания конфигурационного файла, который переопределяет и отключает официальный конфигурационный файл. Создайте `/usr/local/etc/pkg/repos/FreeBSD.conf` со следующим содержимым:

[.programlisting]
....
FreeBSD: {
	enabled: no
}
....

Обычно проще всего предоставлять доступ к репозиторию poudriere клиентским машинам через HTTP. Настройте веб-сервер для обслуживания каталога пакетов, например: `/usr/local/poudriere/data/packages/13amd64`, где `13amd64` — это название сборки.

Если URL репозитория пакетов: `http://pkg.example.com/13amd64`, то файл конфигурации репозитория в `/usr/local/etc/pkg/repos/custom.conf` будет выглядеть так:

[.programlisting]
....
custom: {
	url: "http://pkg.example.com/13amd64",
	enabled: yes,
}
....

Если нежелательно предоставлять доступ к репозиторию пакетов через интернет, можно использовать протокол `file://` для прямого указания на репозиторий:

[.programlisting]
....
custom: {
	url: "file:///usr/local/poudriere/data/packages/11amd64",
	enabled: yes,
}
....

[[ports-nextsteps]]
== Пост-установочные вопросы

Независимо от того, было ли программное обеспечение установлено из бинарного пакета или порта, большинство сторонних приложений требуют некоторой настройки после установки. Следующие команды и расположения могут помочь определить, что было установлено вместе с приложением.

* Большинство приложений устанавливают как минимум один конфигурационный файл по умолчанию в `/usr/local/etc`. В случаях, когда приложение имеет большое количество конфигурационных файлов, создаётся подкаталог для их хранения. Часто устанавливаются примеры конфигурационных файлов, которые имеют окончание, например, `.sample`. Конфигурационные файлы следует просмотреть и, возможно, отредактировать в соответствии с потребностями системы. Для редактирования файла-примера сначала скопируйте его без расширения `.sample`.
* Приложения, которые предоставляют документацию, устанавливают её в `/usr/local/share/doc`, а многие приложения также устанавливают страницы руководств. Перед продолжением следует ознакомиться с этой документацией.
* Некоторые приложения запускают службы, которые необходимо добавить в `/etc/rc.conf` перед запуском приложения. Обычно такие приложения устанавливают скрипт запуска в `/usr/local/etc/rc.d`. Дополнительную информацию можно найти в crossref:config[configtuning-starting-services,Запуск служб].
+
[NOTE]
====
По замыслу, приложения не запускают свои стартовые скрипты при установке, а также не выполняют скрипты остановки при удалении или обновлении. Это решение остается на усмотрение системного администратора.
====

* Пользователи man:csh[1] должны выполнить `rehash`, чтобы перестроить список известных двоичных файлов в `PATH` оболочки.
* Используйте `pkg info`, чтобы определить, какие файлы, man-страницы и бинарные файлы были установлены вместе с приложением.

[[ports-broken]]
== Работа с неработающими портами

Когда порт не собирается или не устанавливается, попробуйте следующее:

. Поищите, есть ли исправление для порта в базе данных link:https://www.FreeBSD.org/support/[отчётов о проблемах]. Если оно есть, применение предложенного исправления может решить проблему.
. Обратитесь к сопровождающему порта за помощью. Введите `make maintainer` в скелете портов или прочитайте `Makefile` порта, чтобы найти адрес электронной почты сопровождающего. Не забудьте включить вывод, предшествующий ошибке, в письмо сопровождающему.
+
[NOTE]
====
Некоторые порты поддерживаются не отдельными людьми, а группой сопровождающих, представленной extref:{mailing-list-faq}[рассылкой]. Многие, но не все, такие адреса выглядят как mailto:freebsd-listname@FreeBSD.org[freebsd-listname@FreeBSD.org]. Учтите это при отправке письма.

В частности, порты, поддерживаемые mailto:ports@FreeBSD.org[ports@FreeBSD.org], не курируются конкретным человеком. Вместо этого исправления и поддержка поступают от сообщества в целом, участники которого подписаны на этот список рассылки. Добровольцы всегда нужны!
====
+
Если на письмо не получен ответ, используйте Bugzilla для отправки отчета об ошибке, следуя инструкциям в extref:{problem-reports}[Составление отчетов о проблемах в FreeBSD].
. Исправьте это! В extref:{porters-handbook}[Руководстве портировщика] содержится подробная информация об инфраструктуре портов, так что вы можете исправить случайно сломанный порт или даже предложить свой собственный!
. Установите пакет вместо порта, следуя инструкциям в crossref:ports[pkgng-intro, Использование pkg для управления бинарными пакетами].
