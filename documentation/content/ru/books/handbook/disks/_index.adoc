---
description: 'Эта глава посвящена использованию дисков и носителей данных в FreeBSD. Здесь рассматриваются SCSI- и IDE-диски, CD- и DVD-носители, диски в оперативной памяти и USB-устройства хранения данных.'
next: books/handbook/geom
params:
  path: /books/handbook/disks/
part: 'Часть III. Администрирование системы'
prev: books/handbook/audit
showBookMenu: true
tags: ["storage", "disks", "gpart", "mount", "quotas", "encrypt", "GPT", "cdrecord", "quotas", "swap", "HAST", "CD", "DVD", "resizing", "growing"]
title: 'Глава 20. Устройства хранения'
weight: 24
---

[[disks]]
= Устройства хранения
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 20
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/disks/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[disks-synopsis]]
== Обзор

Эта глава посвящена использованию дисков и носителей данных в FreeBSD. Сюда входят SCSI- и IDE-диски, CD- и DVD-носители, диски в памяти и USB-устройства хранения данных.

Прочитав эту главу, вы будете знать:

* Как добавить дополнительные жесткие диски в систему FreeBSD.
* Как увеличить размер раздела диска в FreeBSD.
* Как настроить FreeBSD для использования USB-накопителей.
* Как использовать CD и DVD носители в системе FreeBSD.
* Как использовать программы резервного копирования, доступные в FreeBSD.
* Как настроить диски в памяти.
* Что такое снимки файловой системы и как их эффективно использовать.
* Как использовать квоты для ограничения использования дискового пространства.
* Как зашифровать диски и раздел подкачки для защиты от злоумышленников.
* Как настроить сеть хранения данных с высокой доступностью.

Прежде чем читать эту главу, вы должны:

* Знать, как crossref:kernelconfig[kernelconfig,конфигурировать и установливать новое ядро FreeBSD].

[[disks-adding]]
== Добавление дисков

В этом разделе описывается, как добавить новый диск SATA к компьютеру, в котором в настоящее время установлен только один накопитель. Сначала выключите компьютер и установите диск, следуя инструкциям производителей компьютера, контроллера и диска. Перезагрузите систему и войдите в систему как `root`.

Проверьте [.filename]#/var/run/dmesg.boot#, чтобы убедиться, что новый диск обнаружен. В этом примере новый SATA-диск будет отображаться как [.filename]#ada1#.

Для этого примера на новом диске будет создан один большой раздел. Схема разделов https://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] будет использована вместо более старой и менее универсальной схемы MBR.

[NOTE]
====
Если добавляемый диск не пуст, старую информацию о разделах можно удалить с помощью `gpart delete`. Подробности см. в man:gpart[8].
====

Создается схема разделов, а затем добавляется единственный раздел. Для повышения производительности на новых дисках с большими размерами аппаратных блоков раздел выравнивается по границам одного мегабайта:

[source, shell]
....
# gpart create -s GPT ada1
# gpart add -t freebsd-ufs -a 1M ada1
....

В зависимости от использования может потребоваться несколько небольших разделов. См. man:gpart[8] для вариантов создания разделов меньше целого диска.

Информацию о разделах диска можно просмотреть с помощью `gpart show`:

[source, shell]
....
% gpart show ada1
=>        34  1465146988  ada1  GPT  (699G)
          34        2014        - free -  (1.0M)
        2048  1465143296     1  freebsd-ufs  (699G)
  1465145344        1678        - free -  (839K)
....

Создается файловая система в новом разделе на новом диске:

[source, shell]
....
# newfs -U /dev/ada1p1
....

Создается пустой каталог как _точка монтирования_ — место для подключения нового диска в файловой системе исходного диска:

[source, shell]
....
# mkdir /newdisk
....

Наконец, в файл [.filename]#/etc/fstab# добавляется запись, чтобы новый диск автоматически монтировался при загрузке:

[.programlisting]
....
/dev/ada1p1	/newdisk	ufs	rw	2	2
....

Новый диск можно подключить вручную без перезагрузки системы:

[source, shell]
....
# mount /newdisk
....

[[disks-growing]]
== Изменение размера и увеличение дисков

Емкость диска может быть увеличена без изменения уже имеющихся данных. Это часто происходит с виртуальными машинами, когда виртуальный диск оказывается слишком маленьким и его расширяют. Иногда образ диска записывается на USB-накопитель, но не использует его полную емкость. Здесь мы описываем, как изменить размер или _расширить_ содержимое диска, чтобы использовать увеличенную емкость.

Определите имя устройства диска, который нужно изменить, просмотрев [.filename]#/var/run/dmesg.boot#. В этом примере в системе только один SATA-диск, поэтому диск будет отображаться как [.filename]#ada0#.

Перечислите разделы на диске, чтобы увидеть текущую конфигурацию:

[source, shell]
....
# gpart show ada0
=>      34  83886013  ada0  GPT  (48G) [CORRUPT]
        34       128     1  freebsd-boot  (64k)
       162  79691648     2  freebsd-ufs  (38G)
  79691810   4194236     3  freebsd-swap  (2G)
  83886046         1        - free -  (512B)
....

[NOTE]
====
Если диск был отформатирован с использованием схемы разделов https://en.wikipedia.org/wiki/GUID_Partition_Table[GPT], он может отображаться как "повреждённый", поскольку резервная таблица разделов GPT больше не находится в конце диска. Восстановите резервную таблицу разделов с помощью `gpart`:

[source, shell]
....
# gpart recover ada0
ada0 recovered
....

====

Теперь дополнительное пространство на диске доступно для использования новым разделом или для расширения существующего раздела:

[source, shell]
....
# gpart show ada0
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   79691648     2  freebsd-ufs  (38G)
   79691810    4194236     3  freebsd-swap  (2G)
   83886046   18513921        - free -  (8.8G)
....

Разделы можно изменять в размере только в пределах непрерывного свободного пространства. В данном случае последним разделом на диске является раздел подкачки, но требуется изменить размер второго раздела. Поскольку разделы подкачки содержат только временные данные, их можно безопасно отмонтировать, удалить, а затем заново создать третий раздел после изменения размера второго раздела.

Отключить раздел подкачки:

[source, shell]
....
# swapoff /dev/ada0p3
....

Удалите третий раздел, указанный флагом `-i`, с диска _ada0_.

[source, shell]
....
# gpart delete -i 3 ada0
ada0p3 deleted
# gpart show ada0
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   79691648     2  freebsd-ufs  (38G)
   79691810   22708157        - free -  (10G)
....

[WARNING]
====

Существует риск потери данных при изменении таблицы разделов смонтированной файловой системы. Наилучшим вариантом будет выполнение следующих шагов на размонтированной файловой системе, загрузившись с Live CD-ROM или USB-устройства. Однако, если это крайне необходимо, смонтированную файловую систему можно изменить, отключив защитные механизмы GEOM:

[source, shell]
....
# sysctl kern.geom.debugflags=16
....

====

Измените размер раздела, оставив место для создания раздела подкачки нужного размера. Раздел, который нужно изменить, указывается с помощью `-i`, а новый желаемый размер — с помощью `-s`. Дополнительно выравнивание раздела контролируется с помощью `-a`. Это изменяет только размер раздела. Файловая система в разделе будет расширена в отдельном шаге.

[source, shell]
....
# gpart resize -i 2 -s 47G -a 4k ada0
ada0p2 resized
# gpart show ada0
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   98566144     2  freebsd-ufs  (47G)
   98566306    3833661        - free -  (1.8G)
....

Воссоздайте раздел подкачки и активируйте его. Если размер не указан с помощью `-s`, используется все оставшееся пространство:

[source, shell]
....
# gpart add -t freebsd-swap -a 4k ada0
ada0p3 added
# gpart show ada0
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   98566144     2  freebsd-ufs  (47G)
   98566306    3833661     3  freebsd-swap  (1.8G)
# swapon /dev/ada0p3
....

Увеличьте файловую систему UFS, чтобы использовать новую ёмкость изменённого раздела:

[source, shell]
....
# growfs /dev/ada0p2
Device is mounted read-write; resizing will result in temporary write suspension for /.
It's strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432
....

Если файловая система ZFS, изменение размера запускается выполнением подкоманды `online` с ключом `-e`:

[source, shell]
....
# zpool online -e zroot /dev/ada0p2
....

Как раздел, так и файловая система на нем теперь изменены в размере для использования нового доступного пространства на диске.

[[usb-disks]]
== USB-накопители

Многие внешние устройства хранения данных, такие как жесткие диски, USB-флешки, а также устройства для записи CD и DVD, используют универсальную последовательную шину (USB). FreeBSD поддерживает устройства USB 1.x, 2.0 и 3.0.

[NOTE]
====
Поддержка USB 3.0 несовместима с некоторым оборудованием, включая чипсеты Haswell (Lynx point). Если FreeBSD загружается с сообщением `failed with error 19`, отключите xHCI/USB3 в BIOS системы.
====

Поддержка USB-накопителей встроена в ядро [.filename]#GENERIC#. Для собственной сборки ядра убедитесь, что следующие строки присутствуют в конфигурационном файле ядра:

[.programlisting]
....
device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners
....

FreeBSD использует драйвер man:umass[4], который задействует подсистему SCSI для доступа к USB-устройствам хранения данных. Поскольку любое USB-устройство будет распознаваться системой как SCSI-устройство, если USB-устройство является записывающим CD- или DVD-приводом, _не_ включайте `device atapicam` в конфигурационный файл пользовательского ядра.

Оставшаяся часть этого раздела демонстрирует, как убедиться, что USB-накопитель распознаётся FreeBSD, и как настроить устройство для использования.

=== Настройка устройств

Для проверки конфигурации USB подключите USB-устройство. Используйте `dmesg`, чтобы убедиться, что устройство появилось в системном буфере сообщений. Результат должен выглядеть примерно так:

[source, shell]
....
umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0
umass0:  SCSI over Bulk-Only; quirks = 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)
da0: quirks=0x2<NO_6_BYTE>
....

Марка, файл устройства ([.filename]#da0#), скорость и размер будут отличаться в зависимости от устройства.

Поскольку USB-устройство распознаётся как SCSI, для вывода списка USB-накопителей, подключённых к системе, можно использовать `camcontrol`:

[source, shell]
....
# camcontrol devlist
<STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)
....

Или можно использовать `usbconfig` для вывода списка устройств. Дополнительную информацию об этой команде смотрите в man:usbconfig[8].

[source, shell]
....
# usbconfig
ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)
....

Если устройство не было отформатировано, обратитесь к crossref:disks[disks-adding,Добавление дисков] для получения инструкций по форматированию и созданию разделов на USB-накопителе. Если накопитель поставляется с файловой системой, он может быть смонтирован пользователем `root` с помощью инструкций из crossref:basics[mount-unmount,«Монтирование и размонтирование файловых систем»].

[WARNING]
====
Разрешение непривилегированным пользователям монтировать произвольные носители путем включения `vfs.usermount`, как описано ниже, не должно считаться безопасным с точки зрения защиты. Большинство файловых систем не предназначены для защиты от вредоносных устройств.
====

Чтобы устройство можно было монтировать обычным пользователем, одним из решений является добавление всех пользователей устройства в группу `operator` с помощью man:pw[8]. Затем убедитесь, что группа `operator` имеет права на чтение и запись устройства, добавив следующие строки в [.filename]#/etc/devfs.rules#:

[.programlisting]
....
[localrules=5]
add path 'da*' mode 0660 group operator
....

[NOTE]
====
Если в системе также установлены внутренние SCSI-диски, измените вторую строку следующим образом:

[.programlisting]
....
add path 'da[3-9]*' mode 0660 group operator
....

Это исключит первые три SCSI-диска ([.filename]#da0# — [.filename]#da2#) из принадлежности к группе `operator`. Замените _3_ на количество внутренних SCSI-дисков. Дополнительную информацию об этом файле смотрите в man:devfs.rules[5].
====

Затем включите набор правил в [.filename]#/etc/rc.conf#:

[.programlisting]
....
devfs_system_ruleset="localrules"
....

Затем настройте систему для разрешения обычным пользователям монтировать файловые системы, добавив следующую строку в [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
vfs.usermount=1
....

Поскольку это вступит в силу только после следующей перезагрузки, используйте `sysctl`, чтобы установить эту переменную сейчас:

[source, shell]
....
# sysctl vfs.usermount=1
vfs.usermount: 0 -> 1
....

Последним шагом является создание каталога, в который будет монтироваться файловая система. Этот каталог должен принадлежать пользователю, который будет монтировать файловую систему. Один из способов сделать это — создать подкаталог от имени `root`, принадлежащий этому пользователю, например [.filename]#/mnt/username#. В следующем примере замените _username_ на имя пользователя, а _usergroup_ на основную группу пользователя:

[source, shell]
....
# mkdir /mnt/username
# chown username:usergroup /mnt/username
....

Предположим, подключена USB-флешка, и появилось устройство [.filename]#/dev/da0s1#. Если устройство отформатировано с файловой системой FAT, пользователь может смонтировать его с помощью:

[source, shell]
....
% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username
....

Прежде чем устройство можно будет отключить, его _необходимо_ размонтировать:

[source, shell]
....
% umount /mnt/username
....

После удаления устройства в системном буфере сообщений будут отображены сообщения, аналогичные следующим:

[source, shell]
....
umass0: at uhub3, port 2, addr 3 (disconnected)
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached
(da0:umass-sim0:0:0:0): Periph destroyed
....

=== Автомонтирование съемных носителей

USB-устройства могут автоматически монтироваться при раскомментировании этой строки в [.filename]#/etc/auto_master#:

[source, shell]
....
/media		-media		-nosuid
....

Затем добавьте следующие строки в [.filename]#/etc/devd.conf#:

[source, shell]
....
notify 100 {
	match "system" "GEOM";
	match "subsystem" "DEV";
	action "/usr/sbin/automount -c";
};
....

Перезагрузите конфигурацию, если man:autofs[5] и man:devd[8] уже запущены:

[source, shell]
....
# service automount restart
# service devd restart
....

man:autofs[5] можно настроить для запуска при загрузке, добавив следующую строку в [.filename]#/etc/rc.conf#:

[.programlisting]
....
autofs_enable="YES"
....

man:autofs[5] требует, чтобы man:devd[8] был включён, как это и настроено по умолчанию.

Запустите службы немедленно с помощью:

[source, shell]
....
# service automount start
# service automountd start
# service autounmountd start
# service devd start
....

Каждая файловая система, которая может быть автоматически смонтирована, отображается как каталог в [.filename]#/media/#. Каталог именуется в соответствии с меткой файловой системы. Если метка отсутствует, каталог именуется в соответствии с устройством.

Файловая система автоматически монтируется при первом доступе и размонтируется после периода неактивности. Автомонтируемые диски также можно размонтировать вручную:

[source, shell]
....
# automount -fu
....

Этот механизм обычно используется для карт памяти и USB-флешек. Он может применяться с любыми блочными устройствами, включая оптические приводы или iSCSI LUN.

[[creating-cds]]
== Создание и использование CD-носителей

Компакт-диски (CD) обладают рядом особенностей, которые отличают их от обычных дисков. Они спроектированы так, чтобы их можно было читать непрерывно без задержек на перемещение головки между дорожками. Хотя на CD действительно есть дорожки, они обозначают участки данных, предназначенные для непрерывного чтения, а не физическое свойство диска. Файловая система ISO 9660 была разработана для работы с этими различиями.

Коллекция портов FreeBSD предоставляет несколько утилит для записи и копирования аудио- и данных на CD. В этой главе демонстрируется использование нескольких утилит командной строки. Для записи CD с графическим интерфейсом можно установить пакеты или порты package:sysutils/xcdroast[] или package:sysutils/k3b[].

[[atapicam]]
=== Поддерживаемые устройства

Ядро [.filename]#GENERIC# обеспечивает поддержку SCSI, USB и устройств чтения и записи ATAPICD. Если используется собственное ядро, параметры, которые должны присутствовать в конфигурационном файле ядра, зависят от типа устройства.

Для SCSI-устройства, записывающего CD или DVD диски, убедитесь, что присутствуют следующие параметры:

[.programlisting]
....
device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners
....

Для USB-привода убедитесь, что указаны следующие параметры:

[.programlisting]
....
device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
....

Для ATAPI устройств, записывающих CD или DVD диски, убедитесь, что указаны следующие параметры:

[.programlisting]
....
device ata	# Legacy ATA/SATA controllers
device scbus	# SCSI bus (required for ATA/SCSI)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners
....

[NOTE]
====
В версиях FreeBSD до 10.x эта строка также необходима в конфигурационном файле ядра, если устройство записи является ATAPI-устройством:

[.programlisting]
....
device atapicam
....

В качестве альтернативы, этот драйвер можно загрузить при загрузке, добавив следующую строку в файл [.filename]#/boot/loader.conf#:

[.programlisting]
....
atapicam_load="YES"
....

Это потребует перезагрузки системы, так как этот драйвер может быть загружен только во время загрузки.
====

Чтобы убедиться, что FreeBSD распознает устройство, выполните команду `dmesg` и найдите запись об этом устройстве. В системах до версии 10.x имя устройства в первой строке вывода будет [.filename]#acd0# вместо [.filename]#cd0#.

[source, shell]
....
% dmesg | grep cd
cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed
....

[[cdrecord]]
=== Запись компакт-диска

В FreeBSD для записи компакт-дисков можно использовать `cdrecord`. Эта команда устанавливается с пакетом или портом package:sysutils/cdrtools[].

Хотя `cdrecord` имеет множество опций, базовое использование просто. Укажите имя ISO-файла для записи и, если в системе несколько устройств для записи, укажите имя используемого устройства:

[source, shell]
....
# cdrecord dev=device imagefile.iso
....

Чтобы определить имя устройства записывающего привода, используйте `-scanbus`, что может дать результат, подобный следующему:

[source, shell]
....
# cdrecord -scanbus
ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jörg Schilling
Using libscg version 'schily-0.9'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *
....

Найдите запись устройство для записи CD и используйте три числа, разделенные запятыми, в качестве значения для `dev`. В данном случае устройство Yamaha имеет значение `1,5,0`, поэтому правильный ввод для указания этого устройства — `dev=1,5,0`. Обратитесь к руководству `cdrecord` для других способов указания этого значения, а также для получения информации о записи аудиодорожек и управлении скоростью записи.

Или выполните следующую команду, чтобы получить адрес записывающего устройства:

[source, shell]
....
# camcontrol devlist
<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)
....

Используйте числовые значения для `scbus`, `target` и `lun`. В этом примере `1,0,0` — это имя устройства, которое следует использовать.

[[mkisofs]]
=== Запись данных в файловую систему ISO

Для создания компакт-диска с данными файлы, которые будут составлять дорожки на диске, необходимо подготовить перед записью на CD. В FreeBSD пакет package:sysutils/cdrtools[] устанавливает `mkisofs`, который можно использовать для создания файловой системы ISO 9660, представляющей образ дерева каталогов в UNIX(R) файловой системе. Простейший способ использования — указать имя создаваемого ISO-файла и путь к файлам, которые нужно поместить в файловую систему ISO 9660:

[source, shell]
....
# mkisofs -o imagefile.iso /path/to/tree
....

Эта команда сопоставляет имена файлов в указанном пути с именами, соответствующими ограничениям стандартной файловой системы ISO 9660, и исключает файлы, не соответствующие стандарту для файловых систем ISO.

Для преодоления ограничений стандарта доступен ряд опций. В частности, `-R` включает расширения Rock Ridge, распространённые в системах UNIX(R), а `-J` включает расширения Joliet, используемые в системах Microsoft(R).

Для компакт-дисков, которые будут использоваться только в системах FreeBSD, можно применить `-U` для отключения всех ограничений на имена файлов. При использовании вместе с `-R` создаётся образ файловой системы, идентичный указанному дереву FreeBSD, даже если он нарушает стандарт ISO 9660.

Последняя опция общего назначения — `-b`. Она используется для указания местоположения загрузочного образа при создании загрузочного CD в формате "El Torito". Эта опция принимает аргумент — путь к загрузочному образу относительно корня дерева, записываемого на CD. По умолчанию `mkisofs` создаёт образ ISO в режиме "эмуляции флоппи-диска", поэтому ожидает, что загрузочный образ будет иметь размер ровно 1200, 1440 или 2880 КБ. Некоторые загрузчики, например, используемые на дистрибутивных носителях FreeBSD, не применяют режим эмуляции. В этом случае следует использовать опцию `-no-emul-boot`. Таким образом, если [.filename]#/tmp/myboot# содержит загрузочную систему FreeBSD с загрузочным образом в [.filename]#/tmp/myboot/boot/cdboot#, то следующая команда создаст [.filename]#/tmp/bootable.iso#:

[source, shell]
....
# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot
....

Полученный образ ISO можно подключить как диск в памяти с помощью:

[source, shell]
....
# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
....

Затем можно убедиться, что [.filename]#/mnt# и [.filename]#/tmp/myboot# идентичны.

Доступно множество других опций для `mkisofs`, позволяющих точно настроить его поведение. Подробности смотрите в man:mkisofs[8].

[NOTE]
====
Возможно скопировать компакт-диск с данными в файл образа, функционально эквивалентный файлу образа, созданному с помощью `mkisofs`. Для этого используйте [.filename]#dd#, указав имя устройства в качестве входного файла и имя создаваемого ISO в качестве выходного файла:

[source, shell]
....
# dd if=/dev/cd0 of=file.iso bs=2048
....

Полученный файл образа можно записать на компакт-диск, как описано в crossref:disks[cdrecord,Запись компакт-диска].
====

[[mounting-cd]]
=== Использование компакт-дисков с данными

После записи ISO-образа на компакт-диск его можно смонтировать, указав тип файловой системы, имя устройства с компакт-диском и существующую точку монтирования:

[source, shell]
....
# mount -t cd9660 /dev/cd0 /mnt
....

Поскольку `mount` предполагает, что файловая система имеет тип `ufs`, ошибка `Incorrect super block` возникнет, если не указать `-t cd9660` при монтировании компакт-диска с данными.

В то время как любой компакт-диск с данными можно смонтировать таким образом, диски с определёнными расширениями ISO 9660 могут работать неожиданно. Например, диски Joliet хранят все имена файлов в двухбайтовых символах Unicode. Если некоторые неанглийские символы отображаются как знаки вопроса, укажите локальную кодировку с помощью `-C`. Для получения дополнительной информации обратитесь к man:mount_cd9660[8].

[NOTE]
====
Для выполнения этого преобразования символов с помощью опции `-C` необходимо загрузить модуль ядра [.filename]#cd9660_iconv.ko#. Это можно сделать, добавив следующую строку в [.filename]#loader.conf#:

[.programlisting]
....
cd9660_iconv_load="YES"
....

и затем перезагрузить машину, или напрямую загрузить модуль с помощью `kldload`.
====

Изредка при попытке смонтировать компакт-диск с данными может отображаться сообщение `Device not configured`. Обычно это означает, что привод не обнаружил диск в лотке или что привод не виден на шине. Обнаружение носителя может занять несколько секунд, поэтому следует набраться терпения.

Иногда привод SCSICD может быть пропущен, потому что у него не хватило времени ответить на сброс шины. Чтобы решить эту проблему, можно создать пользовательское ядро с увеличенной задержкой SCSI по умолчанию. Добавьте следующую опцию в конфигурационный файл собственного ядра и пересоберите ядро, следуя инструкциям в crossref:kernelconfig[kernelconfig-building,“Сборка и установка собственного ядра”]:

[.programlisting]
....
options SCSI_DELAY=15000
....

Это указывает шине SCSI сделать паузу в 15 секунд во время загрузки, чтобы дать CD-приводу максимальный шанс ответить на сброс шины.

[NOTE]
====
Возможно записать файл непосредственно на CD без создания файловой системы ISO 9660. Это называется записью сырых данных на CD, и некоторые люди делают это для целей резервного копирования.

Такой диск нельзя смонтировать как обычный CD с данными. Чтобы извлечь данные, записанные на такой диск, их необходимо прочитать непосредственно с устройства. Например, следующая команда извлечёт сжатый tar-архив со второго CD-устройства в текущую рабочую директорию:

[source, shell]
....
# tar xzvf /dev/cd1
....

Для монтирования компакт-диска с данными они должны быть записаны с использованием `mkisofs`.
====

[[duplicating-audiocds]]
=== Копирование аудио-CD

Для копирования аудио-CD извлеките аудиоданные с диска в виде набора файлов, затем запишите эти файлы на чистый CD.

В crossref:disks[using-cdrecord, Копирование аудио-CD] описано, как дублировать и записывать аудио-CD. Если версия FreeBSD меньше 10.0 и устройство является ATAPI, необходимо сначала загрузить модуль `atapicam`, следуя инструкциям в crossref:disks[atapicam, Поддерживаемые устройства].

[[using-cdrecord]]
[.procedure]
.Процедура: Копирование аудио-CD
. Пакет или порт package:sysutils/cdrtools[] устанавливает `cdda2wav`. Эту команду можно использовать для извлечения всех аудиодорожек, при этом каждая дорожка записывается в отдельный WAV-файл в текущей рабочей директории:
+
[source, shell]
....
% cdda2wav -vall -B -Owav
....
+
Имя устройства не нужно указывать, если в системе только одно устройство CD. Обратитесь к руководству `cdda2wav` для получения инструкций по указанию устройства и дополнительной информации о других параметрах этой команды.
. Используйте `cdrecord` для записи файлов [.filename]#.wav#:
+
[source, shell]
....
% cdrecord -v dev=2,0 -dao -useinfo  *.wav
....
+
Убедитесь, что _2,0_ установлено правильно, как описано в crossref:disks[cdrecord, Запись CD].

[[creating-dvds]]
== Создание и использование DVD-носителей

По сравнению с компакт-диском, DVD представляет собой следующее поколение технологии хранения данных на оптических носителях. DVD может вмещать больше данных, чем любой компакт-диск, и является стандартом для издания видео.

Для записываемого DVD можно определить пять физических форматов записи:

* DVD-R: Это первый доступный формат записываемых DVD. Стандарт DVD-R определен http://www.dvdforum.org/forum.shtml[DVD Forum]. Этот формат поддерживает однократную запись.
* DVD-RW: Это перезаписываемая версия стандарта DVD-R. DVD-RW можно перезаписывать около 1000 раз.
* DVD-RAM: Это перезаписываемый формат, который можно рассматривать как съемный жесткий диск. Однако, этот носитель не совместим с большинством приводов DVD-ROM и DVD-видеоплееров, так как лишь немногие DVD-рекордеры поддерживают формат DVD-RAM. Дополнительную информацию об использовании DVD-RAM см. в crossref:disks[creating-dvd-ram, Использование DVD-RAM].
* DVD+RW: Это перезаписываемый формат, определенный https://en.wikipedia.org/wiki/DVD%2BRW_Alliance[альянсом DVD+RW Alliance]. DVD+RW можно перезаписывать около 1000 раз.
* DVD+R: Этот формат является однократно записываемой разновидностью формата DVD+RW.

Однослойный записываемый DVD может вместить до 4 700 000 000 байт, что фактически составляет 4,38 ГБ или 4485 МБ, так как 1 килобайт равен 1024 байтам.

[NOTE]
====
Необходимо различать физический носитель и приложение. Например, DVD-Video — это определённая структура файлов, которую можно записать на любой перезаписываемый DVD-носитель, такой как DVD-R, DVD+R или DVD-RW. Перед выбором типа носителя убедитесь, что и записывающее устройство, и проигрыватель DVD-Video поддерживают рассматриваемый носитель.
====

=== Конфигурация

Для записи DVD используйте man:growisofs[1]. Эта команда входит в набор утилит package:sysutils/dvd+rw-tools[], которые поддерживают все типы DVD-носителей.

Эти инструменты используют подсистему SCSI для доступа к устройствам, поэтому поддержка crossref:disks[atapicam,ATAPI/CAM] должна быть загружена или статически собрана в ядре. Эта поддержка не требуется, если устройство записи использует интерфейс USB. Подробнее о настройке USB-устройств см. в разделе crossref:disks[usb-disks,USB-накопители].

Доступ DMA также должен быть включен для устройств ATAPI, добавив следующую строку в [.filename]#/boot/loader.conf#:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

Перед попыткой использования dvd+rw-tools ознакомьтесь с http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html[примечаниями о совместимости оборудования].

[NOTE]
====
Для графического интерфейса можно использовать пакет package:sysutils/k3b[], который предоставляет удобный интерфейс к man:growisofs[1] и многим другим инструментам записи.
====

=== Запись данных на DVD

Поскольку man:growisofs[1] является интерфейсом для crossref:disks[mkisofs,mkisofs], он вызывает man:mkisofs[8] для создания структуры файловой системы и записи на DVD. Это означает, что нет необходимости создавать образ данных перед процессом записи.

Для записи данных из [.filename]#/path/to/data# на DVD+R или DVD-R используйте следующую команду:

[source, shell]
....
# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data
....

В этом примере `-J -R` передаются в man:mkisofs[8] для создания файловой системы ISO 9660 с расширениями Joliet и Rock Ridge. Подробности см. в man:mkisofs[8].

Для начальной записи сессии используется параметр `-Z` как для одиночных, так и для множественных сессий. Замените _/dev/cd0_ на имя устройства DVD. Использование `-dvd-compat` указывает, что диск будет закрыт и запись нельзя будет дополнять. Это также обеспечивает лучшую совместимость носителя с приводами DVD-ROM.

Для записи предварительно созданного образа, например _imagefile.iso_, используйте:

[source, shell]
....
# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso
....

Скорость записи должна определяться и автоматически устанавливаться в зависимости от носителя и используемого привода. Для принудительного задания скорости записи используйте `-speed=`. Примеры использования см. в man:growisofs[1].

[NOTE]
====
Для поддержки файлов размером более 4,38 ГБ необходимо создать гибридную файловую систему UDF/ISO-9660, передав параметры `-udf -iso-level 3` в man:mkisofs[8] и все связанные программы, например man:growisofs[1]. Это требуется только при создании ISO-образа или записи файлов непосредственно на диск. Поскольку диск, созданный таким образом, должен монтироваться как файловая система UDF с помощью man:mount_udf[8], он будет доступен только в операционных системах с поддержкой UDF. В противном случае файлы на диске будут выглядеть повреждёнными.

Чтобы создать ISO-файл такого типа:

[source, shell]
....
% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data
....

Для записи файлов непосредственно на диск:

[source, shell]
....
# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data
....

Когда ISO-образ уже содержит большие файлы, для записи этого образа на диск с помощью `growisofs` не требуется дополнительных параметров.

Убедитесь, что используется актуальная версия package:sysutils/cdrtools[], которая содержит man:mkisofs[8], так как более старая версия может не поддерживать большие файлы. Если последняя версия не работает, установите package:sysutils/cdrtools-devel[] и ознакомьтесь с его man:mkisofs[8].
====

=== Запись DVD-Video

DVD-Video — это определённая структура файлов, основанная на спецификациях ISO 9660 и микро-UDF (M-UDF). Поскольку DVD-Video представляет собой конкретную иерархию структуры данных, для создания DVD требуется специальная программа, например package:multimedia/dvdauthor[].

Если уже существует образ файловой системы DVD-Video, его можно записать так же, как и любой другой образ. Если для создания DVD использовался `dvdauthor` и результат находится в [.filename]#/path/to/video#, то для записи DVD-Video следует использовать следующую команду:

[source, shell]
....
# growisofs -Z /dev/cd0 -dvd-video /path/to/video
....

`-dvd-video` передается в man:mkisofs[8], чтобы указать создать файловую систему в формате DVD-Video. Эта опция подразумевает использование опции `-dvd-compat` man:growisofs[1].

=== Использование DVD+RW

В отличие от CD-RW, новая DVD+RW требует форматирования перед первым использованием. _Рекомендуется_ позволить man:growisofs[1] автоматически выполнить это, когда это уместно. Однако можно использовать `dvd+rw-format` для форматирования DVD+RW:

[source, shell]
....
# dvd+rw-format /dev/cd0
....

Выполняйте эту операцию только один раз и помните, что форматировать нужно только чистые носители DVD+RW. После форматирования DVD+RW можно записывать как обычно.

Для записи совершенно новой файловой системы, а не просто добавления данных на DVD+RW, не требуется предварительно очищать носитель. Вместо этого можно перезаписать предыдущую запись следующим образом:

[source, shell]
....
# growisofs -Z /dev/cd0 -J -R /path/to/newdata
....

Формат DVD+RW поддерживает добавление данных к предыдущей записи. Эта операция заключается в объединении нового сеанса с существующим, так как это не считается многосессионной записью. man:growisofs[1] будет _расширять_ файловую систему ISO 9660, присутствующую на носителе.

Например, чтобы добавить данные на DVD+RW, используйте следующую команду:

[source, shell]
....
# growisofs -M /dev/cd0 -J -R /path/to/nextdata
....

Те же параметры `man:mkisofs[8]`, которые использовались для записи начальной сессии, следует применять при последующих записях.

[NOTE]
====
Используйте `-dvd-compat` для лучшей совместимости носителя с приводами DVD-ROM. При использовании DVD+RW эта опция не предотвращает добавление данных.
====

Для очистки диска запустите:

[source, shell]
....
# growisofs -Z /dev/cd0=/dev/zero
....

=== Использование DVD-RW

DVD-RW поддерживает два формата дисков: инкрементальный последовательный и с ограниченной перезаписью. По умолчанию диски DVD-RW имеют последовательный формат.

Чистый DVD-RW можно записывать напрямую без форматирования. Однако DVD-RW в последовательном формате, который уже использовался, необходимо очистить перед записью нового начального сеанса.

Для очистки DVD-RW в последовательном режиме:

[source, shell]
....
# dvd+rw-format -blank=full /dev/cd0
....

[NOTE]
====
Полное стирание с использованием `-blank=full` займет около одного часа для однократной записи (1x). Быстрое стирание можно выполнить с помощью `-blank`, если DVD-RW будет записываться в режиме Disk-At-Once (DAO). Для записи DVD-RW в режиме DAO используйте команду:

[source, shell]
....
# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso
....

Поскольку man:growisofs[1] автоматически определяет быстро очищенные носители и использует запись DAO, параметр `-use-the-force-luke=dao` не требуется.

Следует использовать режим ограниченной перезаписи для любых DVD-RW, так как этот формат более гибкий по сравнению со стандартным инкрементным последовательным.
====

Для записи данных на последовательную DVD-RW используйте те же инструкции, что и для других форматов DVD:

[source, shell]
....
# growisofs -Z /dev/cd0 -J -R /path/to/data
....

Чтобы добавить данные к предыдущей записи, используйте `-M` с man:growisofs[1]. Однако если данные добавляются на DVD-RW в инкрементальном последовательном режиме, на диске будет создана новая сессия, и в результате получится многосессионный диск.

DVD-RW в формате с ограниченной перезаписью не требует очистки перед созданием новой начальной сессии. Вместо этого перезапишите диск с помощью `-Z`. Также можно расширить существующую файловую систему ISO 9660, записанную на диск, с помощью `-M`. Результатом будет односессионный DVD.

Чтобы перевести DVD-RW в формат ограниченной перезаписи, необходимо использовать следующую команду:

[source, shell]
....
# dvd+rw-format /dev/cd0
....

Для возврата к последовательному формату используйте:

[source, shell]
....
# dvd+rw-format -blank=full /dev/cd0
....

=== Многосеансовые диски

Немногие приводы DVD-ROM поддерживают многосеансовые DVD и в большинстве случаев читают только первый сеанс. DVD+R, DVD-R и DVD-RW в последовательном формате могут поддерживать несколько сеансов. Понятие множественных сеансов отсутствует для форматов DVD+RW и DVD-RW с ограниченной перезаписью.

Используя следующую команду после начального незакрытого сеанса на DVD+R, DVD-R или DVD-RW в последовательном формате, можно добавить новый сеанс на диск:

[source, shell]
....
# growisofs -M /dev/cd0 -J -R /path/to/nextdata
....

Использование этой команды с DVD+RW или DVD-RW в режиме ограниченной перезаписи приведет к добавлению данных с объединением нового сеанса с существующим. В результате получится диск с одним сеансом. Используйте этот метод для добавления данных после первоначальной записи на таких типах носителей.

[NOTE]
====
Поскольку некоторое пространство на носителе используется между каждым сеансом для отметки конца и начала сеансов, следует добавлять сеансы с большим объемом данных для оптимизации пространства на носителе. Количество сеансов ограничено 154 для DVD+R, около 2000 для DVD-R и 127 для DVD+R Double Layer.
====

=== Для получения дополнительной информации

Для получения дополнительной информации о DVD используйте команду `dvd+rw-mediainfo _/dev/cd0_`, когда диск находится в указанном приводе.

Дополнительная информация о dvd+rw-tools доступна в man:growisofs[1], на http://fy.chalmers.se/~appro/linux/DVD+RW/[веб-сайте dvd+rw-tools] и в архивах http://lists.debian.org/cdwrite/[почтовой рассылки cdwrite].

[NOTE]
====
При создании отчёта о проблеме, связанной с использованием dvd+rw-tools, всегда прилагайте вывод команды `dvd+rw-mediainfo`.
====

[[creating-dvd-ram]]
=== Использование DVD-RAM

Записывающие устройства DVD-RAM могут использовать интерфейс SCSI или ATAPI. Для устройств ATAPI необходимо включить доступ DMA, добавив следующую строку в [.filename]#/boot/loader.conf#:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

DVD-RAM можно рассматривать как съемный жесткий диск. Как и любой другой жесткий диск, DVD-RAM необходимо отформатировать перед использованием. В этом примере все дисковое пространство будет отформатировано под стандартную файловую систему UFS2:

[source, shell]
....
# dd if=/dev/zero of=/dev/acd0 bs=2k count=1
# bsdlabel -Bw acd0
# newfs /dev/acd0
....

Устройство DVD, [.filename]#acd0#, должно быть изменено в соответствии с конфигурацией.

После форматирования DVD-RAM его можно подключить как обычный жесткий диск:

[source, shell]
....
# mount /dev/acd0 /mnt
....

После монтирования DVD-RAM будет доступен как для чтения, так и для записи.

[[floppies]]
== Создание и использование дискет

Этот раздел объясняет, как отформатировать 3,5-дюймовую дискету в FreeBSD.

[.procedure]
====
*Procedure: Steps to Format a Floppy*

Дискету необходимо отформатировать на низком уровне перед использованием. Обычно это делается производителем, но форматирование — хороший способ проверить целостность носителя. Для низкоуровневого форматирования дискеты в FreeBSD используйте man:fdformat[1]. При работе с этой утилитой обратите внимание на сообщения об ошибках, так как они помогают определить, исправен диск или нет.

. Для форматирования дискеты вставьте новую дискету размером 3,5 дюйма в первый дисковод и выполните команду:
+
[source, shell]
....
# /usr/sbin/fdformat -f 1440 /dev/fd0
....
+
. После низкоуровневого форматирования диска создайте метку диска, так как она необходима системе для определения размера диска и его геометрии. Поддерживаемые значения геометрии перечислены в [.filename]#/etc/disktab#.
+
Для записи метки диска используйте man:bsdlabel[8]:
+
[source, shell]
....
# /sbin/bsdlabel -B -w /dev/fd0 fd1440
....
+
. Дискета теперь готова для высокоуровневого форматирования с файловой системой. Файловая система дискеты может быть UFS или FAT, причём FAT, как правило, является лучшим выбором для дискет.
+
Чтобы отформатировать дискету в FAT, выполните:
+
[source, shell]
....
# /sbin/newfs_msdos /dev/fd0
....
====

Диск готов к использованию. Чтобы использовать дискету, смонтируйте её с помощью man:mount_msdosfs[8]. Также можно установить и использовать package:emulators/mtools[] из Коллекции портов.

[[backup-basics]]
== Основы резервного копирования

Реализация плана резервного копирования необходима для возможности восстановления после выхода диска из строя, случайного удаления файлов, повреждения данных или полного уничтожения машины, включая уничтожение локальных резервных копий.

Тип резервного копирования и его расписание будут варьироваться в зависимости от важности данных, необходимой детализации для восстановления файлов и допустимого времени простоя. Некоторые возможные методы резервного копирования включают:

* Архивы всей системы, сохраненные на постоянных носителях вне площадки. Это обеспечивает защиту от всех перечисленных выше проблем, но восстановление происходит медленно и неудобно, особенно для непривилегированных пользователей.
* Снимки файловой системы, полезные для восстановления удалённых файлов или предыдущих версий файлов.
* Копии целых файловых систем или дисков, которые синхронизируются с другой системой в сети с использованием запланированного пакета:package:net/rsync[].
* Аппаратный или программный RAID, который минимизирует или исключает простои при отказе диска.

Обычно используется комбинация методов резервного копирования. Например, можно создать расписание для автоматического еженедельного полного резервного копирования системы, которое хранится за пределами основной площадки, и дополнить его ежечасными снимками ZFS. Кроме того, можно вручную создавать резервные копии отдельных каталогов или файлов перед их редактированием или удалением.

В этом разделе описаны некоторые утилиты, которые можно использовать для создания резервных копий и управления ими в системе FreeBSD.

=== Резервное копирование файловой системы

Традиционные программы UNIX(R) для резервного копирования файловой системы — это man:dump[8], который создаёт резервную копию, и man:restore[8], который восстанавливает данные из резервной копии. Эти утилиты работают на уровне блоков диска, ниже абстракций файлов, ссылок и каталогов, создаваемых файловыми системами. В отличие от другого программного обеспечения для резервного копирования, `dump` создаёт резервную копию всей файловой системы и не может сохранить только часть файловой системы или дерево каталогов, расположенное на нескольких файловых системах. Вместо записи файлов и каталогов `dump` записывает непосредственно блоки данных, из которых состоят файлы и каталоги.

[NOTE]
====
Если `dump` используется для корневого каталога, он не будет создавать резервные копии для [.filename]#/home#, [.filename]#/usr# и многих других каталогов, так как обычно они являются точками монтирования других файловых систем или символическими ссылками на них.
====

При восстановлении данных `restore` по умолчанию сохраняет временные файлы в [.filename]#/tmp/#. Если используется диск восстановления с малым объемом [.filename]#/tmp#, следует установить переменную `TMPDIR` в каталог с большим свободным пространством для успешного выполнения восстановления.

При использовании `dump` следует учитывать, что некоторые особенности остались с ранних времен версии 6 AT&T UNIX(R), примерно 1975 года. Параметры по умолчанию предполагают резервное копирование на 9-дорожечную магнитную ленту, а не на другой тип носителя или на современные высокоплотные ленты. Эти значения по умолчанию необходимо переопределять в командной строке.

Возможно выполнить резервное копирование файловой системы через сеть на другую систему или на ленточный накопитель, подключенный к другому компьютеру. Хотя для этого можно использовать утилиты man:rdump[8] и man:rrestore[8], они не считаются безопасными.

Вместо этого можно более безопасно использовать `dump` и `restore` через SSH-соединение. Этот пример создает полную сжатую резервную копию [.filename]#/usr# и отправляет её на указанный хост через SSH-соединение.

.Использование `dump` через ssh
[example]
====
[source, shell]
....
# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz
....
====

Этот пример устанавливает переменную окружения `RSH` для записи резервной копии на ленточный накопитель в удалённой системе через SSH-соединение:

.Использование `dump` через ssh с установленной переменной `RSH`
[example]
====
[source, shell]
....
# env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr
....
====

[TIP]
====
Системы, использующие crossref:zfs[,файловую систему Z (ZFS)], могут использовать man:zfs[8] для создания снимков, а также crossref:zfs[zfs-zfs-send,их отправки и получения] на удалённые системы или с них.
====

=== Резервное копирование каталогов

Некоторые встроенные утилиты могут делать резервное копирование и восстановление указанных файлов и каталогов по мере необходимости.

Хорошим выбором для создания резервной копии всех файлов в каталоге является man:tar[1]. Эта утилита появилась ещё в шестой версии AT&T UNIX(R) и по умолчанию предполагает рекурсивное резервное копирование на локальное ленточное устройство. С помощью ключей можно указать имя файла для резервной копии.

Этот пример создаёт сжатую резервную копию текущего каталога и сохраняет её в [.filename]#/tmp/mybackup.tgz#. При создании резервной копии убедитесь, что она не сохраняется в тот же каталог, который резервируется.

.Резервное копирование текущего каталога с помощью `tar`
[example]
====
[source, shell]
....
# tar czvf /tmp/mybackup.tgz .
....
====

Для восстановления всей резервной копии перейдите в каталог, в который нужно восстановить данные, и укажите имя резервной копии. Обратите внимание, что это перезапишет более новые версии файлов в каталоге восстановления. Если есть сомнения, восстановите данные во временный каталог или укажите имя файла внутри резервной копии для восстановления.

.Восстановление текущего каталога с помощью `tar`
[example]
====
[source, shell]
....
# tar xzvf /tmp/mybackup.tgz
....
====

Существуют десятки доступных параметров, описанных в man:tar[1]. Эта утилита также поддерживает использование шаблонов исключения для указания, какие файлы не должны включаться при резервном копировании указанного каталога или восстановлении файлов из резервной копии.

Для создания резервной копии с использованием указанного списка файлов и каталогов подходит утилита man:cpio[1]. В отличие от `tar`, `cpio` не умеет обходить дерево каталогов и требует предоставления списка файлов для резервирования.

Например, список файлов можно создать с помощью `ls` или `find`. Этот пример создаёт рекурсивный список текущего каталога, который затем передаётся в `cpio` для создания резервной копии с именем [.filename]#/tmp/mybackup.cpio#.

.Использование `ls` и `cpio` для создания рекурсивной резервной копии текущего каталога
[example]
====
[source, shell]
....
# ls -R | cpio -ovF /tmp/mybackup.cpio
....
====

Утилита для резервного копирования, которая пытается объединить возможности, предоставляемые `tar` и `cpio`, — это man:pax[1]. С течением времени различные версии `tar` и `cpio` стали немного несовместимыми. POSIX(R) создал `pax`, который пытается читать и записывать многие из различных форматов `cpio` и `tar`, а также новые собственные форматы.

Эквивалент `pax` для предыдущих примеров будет:

.Резервное копирование текущего каталога с помощью `pax`
[example]
====
[source, shell]
....
# pax -wf /tmp/mybackup.pax .
....
====

[[backups-tapebackups]]
=== Использование магнитных лент для резервного копирования

В то время как технология ленточных накопителей продолжает развиваться, современные системы резервного копирования обычно сочетают удалённое резервное копирование с локальными съёмными носителями. FreeBSD поддерживает любые ленточные накопители, использующие SCSI, такие как LTO или DAT. Поддержка SATA и USB ленточных накопителей ограничена.

Для SCSI-ленточных устройств FreeBSD использует драйвер man:sa[4] и устройства [.filename]#/dev/sa0#, [.filename]#/dev/nsa0# и [.filename]#/dev/esa0#. Физическое имя устройства — [.filename]#/dev/sa0#. При использовании [.filename]#/dev/nsa0# программа резервного копирования не перематывает ленту после записи файла, что позволяет записывать несколько файлов на одну ленту. Использование [.filename]#/dev/esa0# приводит к извлечению ленты после закрытия устройства.

В FreeBSD `mt` используется для управления операциями ленточного накопителя, например, для поиска файлов на ленте или записи управляющих меток на ленту. Например, первые три файла на ленте можно сохранить, пропустив их перед записью нового файла:

[source, shell]
....
# mt -f /dev/nsa0 fsf 3
....

Эта утилита поддерживает множество операций. Подробности смотрите в man:mt[1].

Для записи одного файла на ленту с помощью `tar` укажите имя устройства ленты и файл для резервного копирования:

[source, shell]
....
# tar cvf /dev/sa0 file
....

Для восстановления файлов из архива `tar` на ленте в текущий каталог:

[source, shell]
....
# tar xvf /dev/sa0
....

Для резервного копирования файловой системы UFS используйте `dump`. В этом примере выполняется резервное копирование [.filename]#/usr# без перемотки ленты по завершении:

[source, shell]
....
# dump -0aL -b64 -f /dev/nsa0 /usr
....

Для интерактивного восстановления файлов из файла `dump` на ленте в текущий каталог:

[source, shell]
....
# restore -i -f /dev/nsa0
....

[[backups-programs-amanda]]
=== Сторонние утилиты резервного копирования

Коллекция портов FreeBSD предоставляет множество сторонних утилит, которые можно использовать для планирования создания резервных копий, упрощения резервного копирования на ленточные накопители, а также для повышения удобства и простоты этого процесса. Многие из этих приложений работают по принципу клиент-сервер и позволяют автоматизировать резервное копирование как отдельной системы, так и всех компьютеров в сети.

Популярные утилиты включают:

 * Amanda (package:misc/amanda-server[] и package:misc/amanda-client[]),
 * Bacula (package:sysutils/bacula13-server[] и package:sysutils/bacula13-client[]),
 * Bareos (package:sysutils/bareos-server[] и package:sysutils/bareos-client[]),
 * package:net/rsync[],
 * package:sysutils/duply[], и
 * package:sysutils/duplicity[].

=== Процедура восстановления при сбое

В дополнение к регулярному резервному копированию рекомендуется выполнить следующие шаги в рамках плана подготовки к чрезвычайным ситуациям.

Создайте печатную копию вывода следующих команд:

* `gpart show`
* `more /etc/fstab`
* `pkg prime-list`
* `dmesg`

Сохраните эту распечатку и копию установочного носителя в надежном месте. В случае необходимости аварийного восстановления загрузитесь с установочного носителя и выберите `Live CD` для доступа к оболочке-спасателю — режиму аварийного восстановления. Этот режим восстановления можно использовать для просмотра текущего состояния системы и, при необходимости, для переразметки дисков и восстановления данных из резервных копий.

Затем протестируйте аварийную оболочку и резервные копии. Задокументируйте процедуру. Храните эти записи вместе с носителями, распечатками и резервными копиями. Эти заметки могут предотвратить случайное уничтожение резервных копий в стрессовой ситуации во время аварийного восстановления.

Для дополнительной безопасности храните последнюю резервную копию в удалённом месте, физически отделённом от компьютеров и дисков на значительное расстояние.

[[disks-virtual]]
== Диски в памяти

В дополнение к физическим дискам FreeBSD также поддерживает создание и использование RAM-дисков. Один из возможных вариантов применения RAM-диска — доступ к содержимому файловой системы ISO без необходимости предварительной записи на CD или DVD с последующим монтированием CD/DVD-носителя.

В FreeBSD драйвер man:md[4] используется для поддержки дисков в памяти. Ядро [.filename]#GENERIC# включает этот драйвер. При использовании пользовательского конфигурационного файла ядра убедитесь, что он содержит следующую строку:

[.programlisting]
....
device md
....

[[disks-mdconfig]]
=== Присоединение и отсоединение существующих образов

Для подключения существующего образа файловой системы используйте `mdconfig`, указав имя файла ISO и свободный номер устройства. Затем, используя этот номер устройства, подключите его к существующей точке монтирования. После подключения файлы из ISO будут доступны в точке монтирования. В этом примере _diskimage.iso_ подключается к устройству в памяти [.filename]#/dev/md0#, которое затем монтируется в [.filename]#/mnt#:

[source, shell]
....
# mdconfig -f diskimage.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
....

Обратите внимание, что `-t cd9660` был использован для монтирования формата ISO. Если номер устройства не указан с помощью `-u`, `mdconfig` автоматически выделит неиспользуемый диск в памяти и выведет имя выделенного устройства, например, [.filename]#md4#. Дополнительные сведения о данной команде и её параметрах можно найти в man:mdconfig[8].

Когда диск в памяти больше не используется, его ресурсы должны быть возвращены обратно системе. Сначала размонтируйте файловую систему, затем используйте `mdconfig` для отключения диска от системы и освобождения его ресурсов. Чтобы продолжить этот пример:

[source, shell]
....
# umount /mnt
# mdconfig -d -u 0
....

Чтобы определить, подключены ли к системе какие-либо диски в памяти, введите `mdconfig -l`.

[[disks-md-freebsd5]]
=== Создание диска в памяти на основе файла или памяти

FreeBSD также поддерживает диски в памяти, где хранилище выделяется либо с жёсткого диска, либо из области памяти. Первый метод обычно называют файловой системой на основе файла, а второй — файловой системой на основе памяти. Оба типа можно создать с помощью `mdconfig`.

Для создания новой файловой системы в памяти укажите тип `swap` и размер создаваемого диска в памяти. Затем отформатируйте диск в памяти файловой системой и смонтируйте его как обычно. В этом примере создаётся диск в памяти размером 5M на устройстве `1`. Этот диск в памяти затем форматируется файловой системой UFS перед монтированием:

[source, shell]
....
# mdconfig -a -t swap -s 5m -u 1
# newfs -U md1
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
# mount /dev/md1 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt
....

Чтобы создать новый файловый диск в памяти, сначала выделите область на диске для использования. В этом примере создается пустой файл размером 5 МБ с именем [.filename]#newimage#:

[source, shell]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
....

Затем подключите этот файл к диску в памяти, создайте метку диска и отформатируйте его с файловой системой UFS, смонтируйте диск в памяти и проверьте размер диска на основе файла:

[source, shell]
....
# mdconfig -f newimage -u 0
# bsdlabel -w md0 auto
# newfs -U md0a
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
# mount /dev/md0a /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt
....

Для создания файловой системы на основе файла или оперативной памяти с помощью `mdconfig` требуется выполнить несколько команд. В FreeBSD также доступна утилита `mdmfs`, которая автоматически настраивает диск в памяти, форматирует его с файловой системой UFS и монтирует. Например, после создания образа _newimage_ с помощью `dd`, следующая команда эквивалентна выполнению команд `bsdlabel`, `newfs` и `mount`, приведённых выше:

[source, shell]
....
# mdmfs -F newimage -s 5m md0 /mnt
....

Чтобы вместо этого создать новый диск в памяти на основе оперативной памяти с помощью `mdmfs`, используйте следующую команду:

[source, shell]
....
# mdmfs -s 5m md1 /mnt
....

Если номер устройства не указан, `mdmfs` автоматически выберет неиспользуемое устройство памяти. Подробнее о `mdmfs` см. в man:mdmfs[8].

[[snapshots]]
== Снимки файловой системы

FreeBSD предлагает функцию в сочетании с crossref:config[soft-updates,мягкими обновлениями]: создание снимков файловой системы.

Снимки UFS позволяют пользователю создавать образы указанных файловых систем и работать с ними как с файлами. Если вы используете crossref:zfs[,файловую систему Z (ZFS)], обратитесь к crossref:zfs[zfs-zfs-snapshot,"Управление снимками"] для получения информации об использовании снимков.

Файлы снимков должны быть созданы в той файловой системе, над которой выполняется действие, и пользователь может создать не более 20 снимков для каждой файловой системы. Активные снимки записываются в суперблок, поэтому они сохраняются после размонтирования и повторного монтирования, а также после перезагрузки системы. Когда снимок больше не нужен, его можно удалить с помощью man:rm[1]. Хотя снимки можно удалять в любом порядке, не все освобождаемое пространство может быть использовано, так как другой снимок может претендовать на часть освобожденных блоков.

Неизменяемый флаж файла `snapshot` устанавливается man:mksnap_ffs[8] после первоначального создания файла снимка. man:unlink[1] делает исключение для файлов снимков, так как позволяет их удалять.

Снимки создаются с помощью man:mount[8]. Чтобы создать снимок [.filename]#/var# в файле [.filename]#/var/snapshot/snap#, используйте следующую команду:

[source, shell]
....
# mount -u -o snapshot /var/snapshot/snap /var
....

Или используйте man:mksnap_ffs[8] для создания снимка:

[source, shell]
....
# mksnap_ffs /var /var/snapshot/snap
....

Файлы снимков можно найти в файловой системе, например, в [.filename]#/var#, с помощью man:find[1]:

[source, shell]
....
# find /var -flags snapshot
....

После создания моментального снимка он может быть использован несколькими способами:

* Некоторые администраторы используют файл снимка для резервного копирования, так как снимок можно перенести на компакт-диски или магнитные ленты.
* Проверка целостности файловой системы, man:fsck[8], может быть запущена на снимке. При условии, что файловая система была чистой на момент монтирования, результат всегда должен быть чистым и неизменным.
* Запуск man:dump[8] на снимке создаст дамп-файл, согласованный с файловой системой и временной меткой снимка. man:dump[8] также может создать снимок, создать образ дампа и затем удалить снимок одной командой, используя опцию `-L`.
* Снимок может быть смонтирован как замороженный образ файловой системы. Для монтирования снимка [.filename]#/var/snapshot/snap# выполните команду man:mount[8]:
+
[source, shell]
....
# mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4
# mount -r /dev/md4 /mnt
....

Замороженный [.filename]#/var# теперь доступен через [.filename]#/mnt#. Все изначально будет находиться в том же состоянии, в котором было на момент создания снимка. Единственное исключение — любые предыдущие снимки будут отображаться как файлы нулевой длины. Чтобы отмонтировать снимок, используйте:

[source, shell]
....
# umount /mnt
# mdconfig -d -u 4
....

Для получения дополнительной информации о `softupdates` и снимках файловых систем, включая технические документы, посетите веб-сайт Маршалла Кирка Маккусика по адресу http://www.mckusick.com/[http://www.mckusick.com/].

[[quotas]]
== Квоты на диске

Дисковые квоты могут использоваться для ограничения объёма дискового пространства или количества файлов, которые пользователь или члены группы могут выделить в рамках одной файловой системы. Это предотвращает ситуацию, когда один пользователь или группа пользователей потребляет всё доступное дисковое пространство.

Этот раздел описывает, как настроить квоты дисков для файловой системы UFS. Для настройки квот в файловой системе ZFS обратитесь к crossref:zfs[zfs-zfs-quota,"Квоты наборов данных, пользователей и групп"]

=== Включение квот на диске

Чтобы определить, поддерживает ли ядро FreeBSD квоты дискового пространства:

[source, shell]
....
% sysctl kern.features.ufs_quota
kern.features.ufs_quota: 1
....

В этом примере `1` указывает на поддержку квот. Если значение равно `0`, добавьте следующую строку в файл конфигурации собственного ядра и пересоберите ядро, используя инструкции из crossref:kernelconfig[kernelconfig,Настройка ядра FreeBSD]:

[.programlisting]
....
options QUOTA
....

Далее включите квоты на диски в [.filename]#/etc/rc.conf#:

[.programlisting]
....
quota_enable="YES"
....

Обычно при загрузке проверяется целостность квот для каждой файловой системы с помощью man:quotacheck[8]. Эта программа гарантирует, что данные в базе квот соответствуют данным в файловой системе. Это трудоёмкий процесс, который может значительно увеличить время загрузки системы. Чтобы пропустить этот шаг, добавьте следующую переменную в [.filename]#/etc/rc.conf#:

[.programlisting]
....
check_quotas="NO"
....

Наконец, отредактируйте [.filename]#/etc/fstab#, чтобы включить квоты диска для каждой файловой системы. Чтобы включить квоты для пользователей в файловой системе, добавьте `userquota` в поле опций записи [.filename]#/etc/fstab# для файловой системы, на которой нужно включить квоты. Например:

[.programlisting]
....
/dev/da1s2g   /home    ufs rw,userquota 1 2
....

Для включения квот групп используйте `groupquota` вместо этого. Чтобы включить квоты и для пользователей, и для групп, разделите параметры запятой:

[.programlisting]
....
/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2
....

По умолчанию файлы квот хранятся в корневом каталоге файловой системы как [.filename]#quota.user# и [.filename]#quota.group#. Дополнительную информацию можно найти в man:fstab[5]. Указание альтернативного расположения для файлов квот не рекомендуется.

После завершения настройки перезагрузите систему, и [.filename]#/etc/rc# автоматически выполнит соответствующие команды для создания начальных файлов квот для всех включённых квот в [.filename]#/etc/fstab#.

В обычном режиме работы нет необходимости вручную запускать man:quotacheck[8], man:quotaon[8] или man:quotaoff[8]. Однако рекомендуется ознакомиться с их руководствами, чтобы понимать принцип работы.

=== Установка ограничений квот

Для проверки включения квот выполните:

[source, shell]
....
# quota -v
....

Должна быть однострочная сводка об использовании диска и текущих лимитах квот для каждой файловой системы, на которой включены квоты.

Система готова к назначению квот с помощью `edquota`.

Доступно несколько вариантов для установки ограничений на объем дискового пространства, который может быть выделен пользователю или группе, а также на количество создаваемых ими файлов. Ограничения могут быть установлены на основе объема дискового пространства (блочные квоты), количества файлов (квоты inode) или их комбинации. Каждое ограничение дополнительно разделяется на две категории: жесткие и мягкие лимиты.

Жёсткий лимит не может быть превышен. Как только пользователь достигает жёсткого лимита, он не может выделить дополнительные ресурсы на этой файловой системе. Например, если у пользователя жёсткий лимит в 500 КБ на файловой системе и он уже использует 490 КБ, он может выделить только дополнительные 10 КБ. Попытка выделить дополнительные 11 КБ завершится неудачей.

Мягкие ограничения могут быть превышены на ограниченное время, известное как льготный период, который по умолчанию составляет одну неделю. Если пользователь превышает своё ограничение дольше льготного периода, мягкое ограничение становится жёстким, и дальнейшие выделения ресурсов запрещаются. Когда пользователь снова опускается ниже мягкого ограничения, льготный период сбрасывается.

В следующем примере редактируется квота для учётной записи `test`. При запуске `edquota` открывается редактор, указанный в переменной `EDITOR`, для изменения ограничений квоты. Редактор по умолчанию установлен в vi.

[source, shell]
....
# edquota -u test
Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)
....

Обычно для каждой файловой системы с включенными квотами есть две строки. Одна строка представляет ограничения на блоки, а другая — ограничения на файлы. Измените значение, чтобы изменить лимит квоты. Например, чтобы увеличить лимит блоков для [.filename]#/usr# до мягкого лимита `500` и жёсткого лимита `600`, измените значения в этой строке следующим образом:

[.programlisting]
....
/usr: kbytes in use: 65, limits (soft = 500, hard = 600)
....

Новые ограничения квот вступают в силу после выхода из редактора.

Иногда требуется установить квоты для диапазона пользователей. Это можно сделать, сначала назначив желаемую квоту для одного пользователя, а затем используя опцию `-p` для копирования этой квоты в указанный диапазон идентификаторов пользователей (UID). Следующая команда скопирует эти квоты для UID с `10,000` по `19,999`:

[source, shell]
....
# edquota -p test 10000-19999
....

Для получения дополнительной информации обратитесь к man:edquota[8].

=== Проверка ограничений квот и использования диска

Для проверки квот и использования диска отдельными пользователями или группами используйте man:quota[1]. Пользователь может просматривать только свою собственную квоту и квоту группы, в которой он состоит. Только суперпользователь может просматривать все квоты пользователей и групп. Чтобы получить сводку по всем квотам и использованию диска для файловых систем с включёнными квотами, используйте man:repquota[8].

Обычно файловые системы, на которых пользователь не занимает места, не отображаются в выводе команды `quota`, даже если для пользователя установлено ограничение квоты для этой файловой системы. Используйте `-v`, чтобы отобразить эти файловые системы. Ниже приведён пример вывода `quota -v` для пользователя, у которого установлены ограничения квоты на двух файловых системах.

[.programlisting]
....
Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60
....

В этом примере пользователь превысил мягкое ограничение в 50 Кб на [.filename]#/usr# на 15 Кб, и у него осталось 5 дней льготного периода. Звёздочка `*` указывает, что пользователь в настоящее время превысил ограничение квоты.

=== Квоты по NFS

Квоты применяются подсистемой квот на NFS-сервере. Демон man:rpc.rquotad[8] предоставляет информацию о квотах для команды `quota` на NFS-клиентах, позволяя пользователям на этих машинах просматривать свою статистику по квотам.

На NFS-сервере включите `rpc.rquotad`, удалив `+#+` из этой строки в файле [.filename]*/etc/inetd.conf*:

[.programlisting]
....
rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad
....

Затем перезапустите `inetd`:

[source, shell]
....
# service inetd restart
....

[[disks-encrypting]]
== Шифрование разделов диска

FreeBSD обеспечивает отличную защиту от несанкционированного доступа к данным в режиме онлайн. Права доступа к файлам и crossref:mac[mac,Принудительный контроль доступа] (MAC) помогают предотвратить доступ к данным неавторизованных пользователей, пока операционная система активна и компьютер включен. Однако принудительно устанавливаемые операционной системой права доступа не имеют значения, если злоумышленник получит физический доступ к компьютеру и сможет переместить его жесткий диск в другую систему для копирования и анализа данных.

Независимо от того, как злоумышленник получил доступ к жесткому диску или выключенному компьютеру, криптографические подсистемы на основе GEOM, встроенные в FreeBSD, способны защитить данные в файловых системах компьютера даже от высокомотивированных злоумышленников с значительными ресурсами. В отличие от методов шифрования, которые шифруют отдельные файлы, встроенные утилиты `gbde` и `geli` могут использоваться для прозрачного шифрования целых файловых систем. Ни один открытый текст никогда не попадает на пластину жесткого диска.

Эта глава демонстрирует, как создать зашифрованную файловую систему в FreeBSD. Сначала показан процесс с использованием `gbde`, а затем приведён тот же пример с использованием `geli`.

=== Шифрование диска с gbde

Целью средства man:gbde[4] является создание серьёзного препятствия для злоумышленника, пытающегося получить доступ к содержимому _отключённого_ устройства хранения данных. Однако, если компьютер скомпрометирован во время работы и устройство хранения активно подключено, или злоумышленник имеет доступ к корректной парольной фразе, это средство не обеспечивает защиты содержимого устройства хранения. Таким образом, важно обеспечивать физическую безопасность системы во время её работы и защищать парольную фразу, используемую механизмом шифрования.

Это средство обеспечивает несколько уровней защиты данных, хранящихся в каждом секторе диска. Оно шифрует содержимое сектора диска с использованием 128-битного AES в режиме CBC. Каждый сектор на диске шифруется с использованием уникального ключа AES. Для получения дополнительной информации о криптографической схеме, включая способ получения ключей секторов из предоставленной пользователем парольной фразы, обратитесь к man:gbde[4].

FreeBSD предоставляет модуль ядра для gbde, который можно загрузить следующей командой:

[source, shell]
....
# kldload geom_bde
....

Если используется пользовательский конфигурационный файл ядра, убедитесь, что он содержит следующую строку:

`options GEOM_BDE`

Следующий пример демонстрирует добавление нового жесткого диска в систему, который будет содержать единственный зашифрованный раздел, монтируемый в [.filename]#/private#.

[.procedure]
.Процедура: Шифрование раздела с помощью gbde
. Добавьте новый жесткий диск
+
Установите новый диск в систему, как описано в crossref:disks[disks-adding,Добавление дисков]. Для целей данного примера новый раздел жёсткого диска добавлен как [.filename]#/dev/ad4s1c#, а [.filename]#/dev/ad0s1*# представляет существующие стандартные разделы FreeBSD.
+
[source, shell]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4
....

. Создайте каталог для хранения файлов блокировок `gbde`
+
[source, shell]
....
# mkdir /etc/gbde
....
+
Файл блокировки `gbde` содержит информацию, необходимую `gbde` для доступа к зашифрованным разделам. Без доступа к файлу блокировки `gbde` не сможет расшифровать данные, содержащиеся в зашифрованном разделе, без значительного ручного вмешательства, которое не поддерживается программным обеспечением. Каждый зашифрованный раздел использует отдельный файл блокировки.
. Инициализируйте раздел `gbde`
+
Раздел gbde необходимо инициализировать перед использованием. Эта инициализация выполняется только один раз. Данная команда откроет редактор по умолчанию для настройки различных параметров конфигурации в шаблоне. Для использования с файловой системой UFS установите sector_size в значение 2048:
+
[source, shell]
....
# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size	=	2048
[...]
....
+
После сохранения изменений пользователю будет предложено дважды ввести парольную фразу, используемую для защиты данных. Парольная фраза должна быть одинаковой в обоих случаях. Способность gbde защищать данные полностью зависит от качества парольной фразы. Советы по выбору безопасной парольной фразы, которую легко запомнить, можно найти по ссылке http://world.std.com/\~reinhold/diceware.html[http://world.std.com/~reinhold/diceware.htm].
+
Такая инициализация создает файл блокировки для раздела gbde. В данном примере он сохраняется как [.filename]#/etc/gbde/ad4s1c.lock#. Файлы блокировки должны иметь расширение ".lock", чтобы корректно определяться скриптом запуска [.filename]#/etc/rc.d/gbde#.
+
[CAUTION]
====
Файлы блокировок _обязательно_ должны быть включены в резервную копию вместе с содержимым зашифрованных разделов. Без файла блокировки законный владелец не сможет получить доступ к данным на зашифрованном разделе.
====

. Присоедините зашифрованный раздел к ядру
+
[source, shell]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock
....
+
Эта команда запросит ввод парольной фразы, выбранной при инициализации зашифрованного раздела. Новое зашифрованное устройство появится в [.filename]#/dev# под именем [.filename]#/dev/имя_устройства.bde#:
+
[source, shell]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde
....

. Создайте файловую систему на зашифрованном устройстве
+
После подключения зашифрованного устройства к ядру на нем можно создать файловую систему. В этом примере создается файловая система UFS с включенными мягкими обновлениями. Убедитесь, что указан раздел с расширением [.filename]#*.bde#:
+
[source, shell]
....
# newfs -U /dev/ad4s1c.bde
....

. Смонтируйте зашифрованный раздел
+
Создайте точку монтирования и подключите зашифрованную файловую систему:
+
[source, shell]
....
# mkdir /private
# mount /dev/ad4s1c.bde /private
....

. Проверьте, что зашифрованная файловая система доступна
+
Зашифрованная файловая система теперь должна быть видна и доступна для использования:
+
[source, shell]
....
% df -H
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private
....

После каждой загрузки все зашифрованные файловые системы должны быть вручную повторно подключены к ядру, проверены на ошибки и смонтированы, прежде чем их можно будет использовать. Чтобы настроить эти шаги, добавьте следующие строки в [.filename]#/etc/rc.conf#:

[.programlisting]
....
gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"
....

Для этого необходимо ввести пароль на консоли во время загрузки. После ввода правильного пароля зашифрованный раздел будет автоматически подключен. Дополнительные параметры загрузки gbde доступны и перечислены в man:rc.conf[5].

[NOTE]
====
`sysinstall` несовместим с устройствами, зашифрованными `gbde`. Все устройства с именами `*.bde` должны быть отключены от ядра перед запуском `sysinstall`, иначе он завершится аварией во время начального сканирования устройств. Чтобы отключить зашифрованное устройство, использованное в примере, выполните следующую команду:

[source, shell]
....
# gbde detach /dev/ad4s1c
....
====

[[disks-encrypting-geli]]
=== Шифрование диска с помощью `geli`

Альтернативный криптографический класс GEOM доступен с использованием `geli`. Эта утилита управления предоставляет дополнительные возможности и использует другую схему для выполнения криптографических операций. Она обеспечивает следующие функции:

* Использует фреймворк man:crypto[9] и автоматически задействует криптографическое оборудование, когда оно доступно.
* Поддерживает несколько криптографических алгоритмов, таких как AES-XTS, AES-CBC и Camellia-CBCAES.
* Позволяет зашифровать корневой раздел. Пароль для доступа к зашифрованному корневому разделу будет запрашиваться при загрузке системы.
* Позволяет использование двух независимых ключей.
* Она быстрая, так как выполняет простое поблочное шифрование.
* Позволяет создавать резервные копии и восстанавливать мастер-ключи. Если пользователь уничтожит свои ключи, доступ к данным всё ещё можно получить, восстановив ключи из резервной копии.
* Позволяет подключить диск с одноразовым случайным ключом, что полезно для разделов подкачки и временных файловых систем.

Дополнительные возможности и примеры использования приведены в man:geli[8].

Следующий пример описывает, как сгенерировать ключевой файл, который будет использоваться как часть мастер-ключа для зашифрованного провайдера, монтируемого в [.filename]#/private#. Ключевой файл предоставит случайные данные, используемые для шифрования мастер-ключа. Мастер-ключ также будет защищён парольной фразой. Размер сектора провайдера составит 4 КБ. В примере описано, как подключиться к провайдеру `geli`, создать на нём файловую систему, смонтировать её, работать с ней и, наконец, отключить её.

[.procedure]
.Процедура: Шифрование раздела с помощью `geli`
. Загрузите поддержку `geli`
+
Поддержка `geli` доступна в виде загружаемого модуля ядра. Чтобы настроить систему для автоматической загрузки модуля при загрузке, добавьте следующую строку в файл [.filename]#/boot/loader.conf#:
+
[.programlisting]
....
geom_eli_load="YES"
....
+
Чтобы загрузуть модуля ядра сейчас:
+
[source, shell]
....
# kldload geom_eli
....
+
Для собственного ядра убедитесь, что файл конфигурации ядра содержит следующие строки:
+
[.programlisting]
....
options GEOM_ELI
device crypto
....

. Сгенеририруйте мастер-ключа
+
Следующие команды создают мастер-ключ, которым будут зашифрованы все данные. Этот ключ нельзя изменить. Вместо его прямого использования, он шифруется одним или несколькими пользовательскими ключами. Пользовательские ключи формируются из опциональной комбинации случайных байтов из файла [.filename]#/root/da2.key# и/или парольной фразы. В данном случае источником данных для ключевого файла является [.filename]#/dev/random#. Эта команда также устанавливает размер сектора провайдера ([.filename]#/dev/da2.eli#) равным 4 КБ для улучшения производительности:
+
[source, shell]
....
# dd if=/dev/random of=/root/da2.key bs=64 count=1
# geli init -K /root/da2.key -s 4096 /dev/da2
Enter new passphrase:
Reenter new passphrase:
....
+
Не обязательно использовать и парольную фразу, и файл ключа, так как каждый из этих методов защиты главного ключа может применяться отдельно.
+
Если файл ключа указан как "-", будет использован стандартный ввод. Например, следующая команда генерирует три файла ключей:
+
[source, shell]
....
# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2
....

. Присоедините поставщика с сгенерированным Ключом
+
Для подключения провайдера укажите файл ключа, имя диска и парольную фразу:
+
[source, shell]
....
# geli attach -k /root/da2.key /dev/da2
Enter passphrase:
....
+
Это создает новое устройство с расширением [.filename]#.eli#:
+
[source, shell]
....
# ls /dev/da2*
/dev/da2  /dev/da2.eli
....

. Создайте новую файловую систему
+
Далее отформатируйте устройство с файловой системой UFS и смонтируйте его в существующей точке монтирования:
+
[source, shell]
....
# dd if=/dev/random of=/dev/da2.eli bs=1m
# newfs /dev/da2.eli
# mount /dev/da2.eli /private
....
+
Зашифрованная файловая система теперь должна быть доступна для использования:
+
[source, shell]
....
# df -H
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private
....

После завершения работы с зашифрованным разделом и когда раздел [.filename]#/private# больше не нужен, рекомендуется перевести устройство в холодное хранилище, размонтировав и отключив зашифрованный раздел `geli` от ядра:

[source, shell]
....
# umount /private
# geli detach da2.eli
....

Для упрощения монтирования зашифрованных устройств `geli` во время загрузки предоставляется скрипт [.filename]#rc.d#. Для данного примера добавьте следующие строки в [.filename]#/etc/rc.conf#:

[.programlisting]
....
geli_devices="da2"
geli_da2_flags="-k /root/da2.key"
....

В этом примере [.filename]#/dev/da2# настраивается как провайдер `geli` с мастер-ключом [.filename]#/root/da2.key#. Система автоматически отключит провайдер от ядра перед завершением работы. Во время загрузки скрипт запросит парольную фразу перед подключением провайдера. До или после запроса пароля могут отображаться другие сообщения ядра. Если процесс загрузки кажется зависшим, внимательно поищите запрос пароля среди других сообщений. После ввода правильной парольной фразы провайдер будет подключен. Файловая система затем монтируется, обычно с помощью записи в [.filename]#/etc/fstab#. Инструкции по настройке автоматического монтирования файловой системы при загрузке можно найти в crossref:basics[mount-unmount,“Монтирование и размонтирование файловых систем”].

[[swap-encrypting]]
== Шифрование раздела подкачки

Как и шифрование разделов диска, шифрование раздела подкачки используется для защиты конфиденциальной информации. Рассмотрим приложение, работающее с паролями. Пока пароли находятся в физической памяти, они не записываются на диск и будут удалены после перезагрузки. Однако если FreeBSD начнёт выгружать страницы памяти для освобождения места, пароли могут быть записаны на диск в незашифрованном виде. Решением в этом случае может быть шифрование раздела подкачки.

В этой части показано, как настроить зашифрованный раздел подкачки с использованием шифрования man:gbde[8] или man:geli[8]. Предполагается, что раздел подкачки — это [.filename]#/dev/ada0s1b#.

=== Настройка зашифрованного раздела подкачки

Разделы подкачки по умолчанию не шифруются, и перед продолжением работы следует удалить из них все конфиденциальные данные. Чтобы перезаписать текущий раздел подкачки случайными данными, выполните следующую команду:

[source, shell]
....
# dd if=/dev/random of=/dev/ada0s1b bs=1m
....

Для шифрования раздела подкачки с помощью man:gbde[8] добавьте суффикс `.bde` к строке подкачки в [.filename]#/etc/fstab#:

[.programlisting]
....
# Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.bde	none		swap	sw		0	0
....

Для шифрования раздела подкачки с помощью man:geli[8] используйте суффикс `.eli`:

[.programlisting]
....
# Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw		0	0
....

По умолчанию man:geli[8] использует алгоритм AES с длиной ключа 128 бит. Обычно стандартных настроек достаточно. При необходимости эти значения по умолчанию можно изменить в поле options файла [.filename]#/etc/fstab#. Доступные флаги:

aalgo::
Алгоритм проверки целостности данных, используемый для обеспечения отсутствия изменений в зашифрованных данных. Список поддерживаемых алгоритмов приведен в man:geli[8].

ealgo::
Алгоритм шифрования, используемый для защиты данных. Список поддерживаемых алгоритмов приведён в man:geli[8].

keylen::
Длина ключа, используемого для алгоритма шифрования. Подробнее о поддерживаемых длинах ключей для каждого алгоритма шифрования смотрите в man:geli[8].

sectorsize::
Размер блоков, на которые разбиваются данные перед шифрованием. Увеличение размера секторов повышает производительность за счет большего расхода пространства. Рекомендуемый размер — 4096 байт.

В этом примере настраивается зашифрованный раздел подкачки с использованием алгоритма AES-XTS с длиной ключа 128 бит и размером сектора 4 килобайта:

[.programlisting]
....
# Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=AES-XTS,keylen=128,sectorsize=4096	0	0
....

=== Проверка зашифрованного раздела подкачки

После перезагрузки системы корректную работу зашифрованного раздела подкачки можно проверить с помощью `swapinfo`.

Если используется man:gbde[8]:

[source, shell]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde   542720        0   542720     0
....

Если используется man:geli[8]:

[source, shell]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli   542720        0   542720     0
....

[[disks-hast]]
== Высокодоступное хранилище (HAST)

Высокая доступность — одно из основных требований для серьёзных бизнес-приложений, а высокодоступное хранилище является ключевым компонентом в таких средах. В FreeBSD framework Highly Available STorage (HAST) обеспечивает прозрачное хранение одних и тех же данных на нескольких физически разделённых машинах, соединённых через сеть TCP/IP. HAST можно рассматривать как сетевой RAID1 (зеркало), аналогичный системе хранения DRBD(R), используемой на платформе GNU/Linux(R). В сочетании с другими функциями высокой доступности FreeBSD, такими как CARP, HAST позволяет создавать высокодоступные кластеры хранения, устойчивые к аппаратным сбоям.

Основные возможности HAST:

* Может использоваться для маскировки ошибок ввода-вывода на локальных жестких дисках.
* Файлово-системно агностичен, так как работает с любой файловой системой, поддерживаемой FreeBSD.
* Эффективная и быстрая повторная синхронизация, так как синхронизируются только блоки, изменённые во время простоя узла.
* Может использоваться в уже развернутой среде для добавления дополнительной избыточности.
* Вместе с CARP, Heartbeat или другими инструментами он может использоваться для создания надежной и отказоустойчивой системы хранения данных.

Прочитав этот раздел, вы узнаете:

* Что такое HAST, как он работает и какие возможности предоставляет.
* Как настроить и использовать HAST в FreeBSD.
* Как интегрировать CARP и man:devd[8] для создания надежной системы хранения данных.

Прежде чем читать этот раздел, вы должны:

* Понимать основы UNIX(R) и FreeBSD (crossref:basics[basics,Основы FreeBSD]).
* Знать, как настраивать сетевые интерфейсы и другие основные подсистемы FreeBSD (crossref:config[config-tuning,Настройка и оптимизация]).
* Хорошо разбираться в сетевых возможностях FreeBSD (crossref:partiv[network-communication,"Сетевое взаимодействие"]).

Проект HAST был поддержан The FreeBSD Foundation при участии http://www.omc.net/[http://www.omc.net/] и http://www.transip.nl/[http://www.transip.nl/].

=== Работа HAST

HAST обеспечивает синхронную репликацию на блочном уровне между двумя физическими машинами: _primary_ (основной) узел и _secondary_ (вторичный) узел. Вместе эти две машины называются кластером.

Поскольку HAST работает в конфигурации "основной-вторичный", он позволяет только одному узлу кластера быть активным в любой момент времени. Основной узел, также называемый _активным_, обрабатывает все запросы ввода-вывода для устройств, управляемых HAST. Вторичный узел автоматически синхронизируется с основным.

Физические компоненты системы HAST включают локальный диск на основном узле и диск на удаленном, резервном узле.

HAST работает синхронно на блочном уровне, что делает его прозрачным для файловых систем и приложений. HAST предоставляет обычные GEOM-провайдеры в [.filename]#/dev/hast/# для использования другими инструментами или приложениями. Нет разницы между использованием устройств, предоставляемых HAST, и использованием обычных дисков или разделов.

Каждая операция записи, удаления или сброса данных отправляется как на локальный диск, так и на удалённый диск через TCP/IP. Каждая операция чтения выполняется с локального диска, если только локальный диск не содержит актуальных данных или не возникает ошибка ввода-вывода. В таких случаях операция чтения отправляется на вторичный узел.

HAST стремится обеспечить быстрое восстановление после сбоев. По этой причине важно сократить время синхронизации после отказа узла. Для быстрой синхронизации HAST использует битовую карту грязных экстентов на диске и синхронизирует только их в процессе обычной синхронизации, за исключением начальной синхронизации.

Существует множество способов обработки синхронизации. HAST реализует несколько режимов репликации для работы с различными методами синхронизации:

* _memsync_: В этом режиме операция записи считается завершённой, когда локальная операция записи завершена и когда удалённый узел подтверждает получение данных, но до фактического сохранения данных. Данные на удалённом узле будут сохранены сразу после отправки подтверждения. Этот режим предназначен для уменьшения задержки, но при этом обеспечивает хорошую надёжность. Этот режим используется по умолчанию.
* _fullsync_: В этом режиме операция записи считается завершённой, когда завершается как локальная, так и удалённая запись. Это самый безопасный и самый медленный режим репликации.
* _async_: В этом режиме операция записи считается завершенной, как только завершается локальная запись. Это самый быстрый и самый опасный режим репликации. Он должен использоваться только при репликации на удаленный узел, где задержка слишком высока для других режимов.

=== Конфигурация HAST

Фреймворк HAST состоит из нескольких компонентов:

* Демон man:hastd[8], который обеспечивает синхронизацию данных. При запуске этого демона он автоматически загружает модуль `geom_gate.ko`.
* Служебная программа управления пользовательским пространством man:hastctl[8].
* Файл конфигурации man:hast.conf[5]. Этот файл должен существовать до запуска hastd.

Пользователи, которые предпочитают статически встраивать поддержку `GEOM_GATE` в ядро, должны добавить следующую строку в файл конфигурации собственного ядра, а затем пересобрать ядро, следуя инструкциям в crossref:kernelconfig[kernelconfig,Настройка ядра FreeBSD]:

[.programlisting]
....
options	GEOM_GATE
....

Следующий пример описывает настройку двух узлов в режиме первичный-вторичный с использованием HAST для репликации данных между ними. Узлы будут называться `hasta` с IP-адресом `172.16.0.1` и `hastb` с IP-адресом `172.16.0.2`. Оба узла будут иметь выделенный жесткий диск [.filename]#/dev/ad6# одинакового размера для работы с HAST. Пул HAST, иногда называемый ресурсом или провайдером GEOM в [.filename]#/dev/hast/#, будет называться `test`.

Настройка HAST выполняется с помощью файла [.filename]#/etc/hast.conf#. Этот файл должен быть идентичным на обоих узлах. Простейшая конфигурация выглядит следующим образом:

[.programlisting]
....
resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}
....

Для более сложной настройки обратитесь к man:hast.conf[5].

[TIP]
====
Также можно использовать имена хостов в операторах `remote`, если хосты разрешаемы и определены либо в [.filename]#/etc/hosts#, либо в локальном DNS.
====

После создания конфигурации на обоих узлах можно создать пул HAST. Выполните следующие команды на обоих узлах, чтобы разместить начальные метаданные на локальном диске и запустить man:hastd[8]:

[source, shell]
....
# hastctl create test
# service hastd onestart
....

[NOTE]
====
Невозможно использовать провайдеры GEOM с существующей файловой системой или преобразовать существующее хранилище в пул под управлением HAST. Эта процедура требует хранения некоторых метаданных на провайдере, и на существующем провайдере не будет достаточно необходимого пространства.
====

Роль `primary` или `secondary` узла HAST выбирается администратором или программным обеспечением, таким как Heartbeat, с помощью man:hastctl[8]. На основном узле `hasta` выполните следующую команду:

[source, shell]
....
# hastctl role primary test
....

Выполните эту команду на дополнительном узле, `hastb`:

[source, shell]
....
# hastctl role secondary test
....

Проверьте результат, выполнив `hastctl` на каждом узле:

[source, shell]
....
# hastctl status test
....

Проверьте строку `status` в выводе. Если там указано `degraded`, значит, с файлом конфигурации что-то не так. На каждом узле должно быть указано `complete`, что означает начало синхронизации между узлами. Синхронизация завершается, когда `hastctl status` сообщает о 0 байтах в `dirty` экстентах.

Следующий шаг — создать файловую систему на провайдере GEOM и смонтировать её. Это должно быть выполнено на узле `primary`. Создание файловой системы может занять несколько минут в зависимости от размера жёсткого диска. В этом примере создаётся файловая система UFS на [.filename]#/dev/hast/test#:

[source, shell]
....
# newfs -U /dev/hast/test
# mkdir /hast/test
# mount /dev/hast/test /hast/test
....

После правильной настройки структуры HAST последним шагом является обеспечение автоматического запуска HAST во время загрузки системы. Добавьте следующую строку в [.filename]#/etc/rc.conf#:

[.programlisting]
....
hastd_enable="YES"
....

==== Конфигурация отказоустойчивости

Цель данного примера — создать надежную систему хранения, устойчивую к отказу любого узла. Если основной узел выходит из строя, резервный узел готов взять на себя управление без перерывов, проверить и смонтировать файловую систему, продолжив работу без потери данных.

Для выполнения этой задачи используется Протокол избыточности общих адресов (CARP — Common Address Redundancy Protocol), который обеспечивает автоматическое переключение на резервный узел на IP-уровне. CARP позволяет нескольким узлам в одном сетевом сегменте совместно использовать один IP-адрес. Настройте CARP на обоих узлах кластера в соответствии с документацией, доступной в crossref:advanced-networking[carp,“Common Address Redundancy Protocol (CARP)”]. В этом примере каждый узел будет иметь свой собственный управляющий IP-адрес и общий IP-адрес _172.16.0.254_. Основной узел HAST в кластере должен быть основным узлом CARP.

Созданный в предыдущем разделе пул HAST теперь готов к экспорту на другие узлы в сети. Это можно осуществить, экспортировав его через NFS или Samba, используя общий IP-адрес _172.16.0.254_. Единственная оставшаяся нерешенной проблема — это автоматический переход на резервный узел в случае отказа основного.

В случае перехода интерфейсов CARP в состояние "включен" или "выключен", операционная система FreeBSD генерирует событие man:devd[8], что позволяет отслеживать изменения состояния интерфейсов CARP. Изменение состояния интерфейса CARP указывает на то, что один из узлов вышел из строя или вернулся в онлайн. Эти события изменения состояния позволяют запускать скрипт для автоматической обработки переключения при отказе в HAST.

Для отслеживания изменений состояния на интерфейсах CARP добавьте следующую конфигурацию в [.filename]#/etc/devd.conf# на каждом узле, заменив `<vhid>` на идентификатор виртуального хоста и `<ifname>` на имя соответствующего интерфейса:

[.programlisting]
....
notify 30 {
	match "system" "CARP";
	match "subsystem" "<vhid>@<ifname>";
	match "type" "MASTER";
	action "/usr/local/sbin/carp-hast-switch primary";
};

notify 30 {
	match "system" "CARP";
	match "subsystem" "<vhid>@<ifname>";
	match "type" "BACKUP";
	action "/usr/local/sbin/carp-hast-switch secondary";
};
....

Перезапустите man:devd[8] на обоих узлах, чтобы новая конфигурация вступила в силу:

[source, shell]
....
# service devd restart
....

Когда состояние указанного интерфейса изменяется (переход вверх или вниз), система генерирует уведомление, позволяющее подсистеме man:devd[8] запустить указанный скрипт автоматического переключения [.filename]#/usr/local/sbin/carp-hast-switch#. Для дополнительных пояснений о данной конфигурации обратитесь к man:devd.conf[5].

Вот пример скрипта автоматического переключения при отказе:

[.programlisting]
....
#!/bin/sh

# Original script by Freddie Cash <fjwcash@gmail.com>
# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>
# and Viktor Petersson <vpetersson@wireload.net>

# The names of the HAST resources, as listed in /etc/hast.conf
resources="test"

# delay in mounting HAST resource after becoming primary
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	primary)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" > /dev/null 2>&1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] && break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."

		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	secondary)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2>&1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac
....

В двух словах, скрипт выполняет следующие действия, когда узел становится основным:

* Переводит пул HAST в primary на другом узле.
* Проверяет файловую систему в пуле HAST.
* Подключает пул.

Когда узел становится вторичным:

* Размонтирует пул HAST.
* Переводит пул HAST в состояние secondary.

[CAUTION]
====
Это просто пример скрипта, который служит доказательством концепции. Он не обрабатывает все возможные сценарии и может быть расширен или изменён любым способом, например, для запуска или остановки необходимых служб.
====

[TIP]
====
Для этого примера использовалась стандартная файловая система UFS. Чтобы сократить время, необходимое для восстановления, можно использовать журналируемую UFS или файловую систему ZFS.
====

Вместо использования высокодоступного хранилища локально, его также можно предоставить в общее пользование другим компьютерам в сети через crossref:network-servers[network-nfs,NFS], crossref:network-servers[network-iscsi,iSCSI], man:sshfs[1] или программы из портов (например, package:net/samba419[]).

Более подробная информация с дополнительными примерами доступна по адресу http://wiki.FreeBSD.org/HAST[http://wiki.FreeBSD.org/HAST].

=== Устранение неполадок

HAST, как правило, должен работать без проблем. Однако, как и с любым другим программным продуктом, могут возникнуть ситуации, когда он работает не так, как предполагается. Источники проблем могут быть разными, но главное правило — обеспечить синхронизацию времени между узлами кластера.

При устранении неполадок HAST уровень отладки man:hastd[8] следует повысить, запустив `hastd` с параметром `-d`. Этот аргумент можно указать несколько раз для дальнейшего повышения уровня отладки. Также рекомендуется использовать `-F`, что запускает `hastd` в foreground.

[[disks-hast-sb]]
==== Восстановление после раскола кластера

_Раскол_ (split-brain) возникает, когда узлы кластера не могут связаться друг с другом, и оба настроены как первичные. Это опасная ситуация, так как она позволяет обоим узлам вносить противоречивые изменения в данные. Данная проблема должна быть устранена вручную системным администратором.

Администратор должен либо определить, на каком узле находятся более важные изменения, либо выполнить слияние вручную. Затем следует позволить HAST выполнить полную синхронизацию узла с повреждёнными данными. Для этого выполните следующие команды на узле, который требует повторной синхронизации:

[source, shell]
....
# hastctl role init test
# hastctl create test
# hastctl role secondary test
....
